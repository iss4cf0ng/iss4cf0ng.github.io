<!DOCTYPE html><html lang="en-us" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>[Book] C++ Concurrency In Action (Second Edition) | ISSAC/iss4cf0ng's blog</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":true,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy","copyFinish":"copied","expand":"expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/brands.min.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
@font-face {
 font-family: 'Font Awesome 6 Brands';
 src: local('Font Awesome 6 Brands'), url('/lib/fontawesome/fa-brands.woff2') format('woff2');
}
@font-face {
 font-family: 'Font Awesome 6 Free';
 src: local('Font Awesome 6 Free'), url('/lib/fontawesome/fa-regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ISSAC/iss4cf0ng's blog" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/About/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/Alien/"><span class="navItemTitle">Alien</span></a></li><li class="navItem"><a class="navBlock" href="/2026/01/28/2026-1-28-ToolsDuplexSpy-v2-0-0/"><span class="navItemTitle">DuplexSpy</span></a></li><li class="navItem"><a class="navBlock" href="/Notes/"><span class="navItemTitle">Notes</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>[Book] C++ Concurrency In Action (Second Edition)</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2026-01-08T11:14:40.000Z" id="date"> 2026-01-08</time></div></span><br><span>Last Update: <div class="control"><time datetime="2026-02-17T07:02:57.652Z" id="updated"> 2026-02-17</time></div></span><br><span>Word Count: <div class="control">4.5k</div></span><br><span>Read Time: <div class="control">28 min</div></span></div></div><hr><div id="post-content"><h1 id="El-Libro"><a href="#El-Libro" class="headerlink" title="El Libro"></a>El Libro</h1><p align="center" class='item-img' data-src='/images/books/CppConcurrency/libro.png'><img src="/images/books/CppConcurrency/libro.png" width="500">
</p>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>This article is used to keep notes and summaries of the book “C++ Concurrency In Action (Second Edition)”.<br>The content will be continuously updated as I read through the book.</p>
<h1 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h1><h1 id="Chapter-1-Hello-world-of-concurrency"><a href="#Chapter-1-Hello-world-of-concurrency" class="headerlink" title="Chapter.1 - Hello, world of concurrency"></a>Chapter.1 - Hello, world of concurrency</h1><h2 id="1-1-What-is-concurrency"><a href="#1-1-What-is-concurrency" class="headerlink" title="1.1 - What is concurrency"></a>1.1 - What is concurrency</h2><p>At the simplest and most basic level, <strong>concurrency</strong> is about two or more separate activities happening at the same time. You can watch football while I go swimming, and so on.</p>
<p>When we talk about concurrency in terms of computers, we mean a single system performing multiple independent activities in parallel, rather than sequentially, or one after the other.</p>
<h3 id="Concurrency-vs-Parallelism"><a href="#Concurrency-vs-Parallelism" class="headerlink" title="Concurrency vs. Parallelism"></a>Concurrency vs. Parallelism</h3><p>Concurrency and parallelism have largely overlapping meanings with respect to multithreaded code. Indeed, to many they mean the same thing.</p>
<p>The difference is primarily a matter of nuance, focus, and intent. Both terms are about running multiple tasks simultaneously, using the available hardware, but parallelism is much more performance-oriented.  </p>
<p>People talk about <strong>parallelism</strong> when their primary concern is talking advantage of the avaiable hardware to increase the performance of bulk data processing.</p>
<p>People talk about <strong>concurrency</strong> when their primary concern is separation of concerns, or responsiveness.</p>
<h2 id="1-4-Getting-Started"><a href="#1-4-Getting-Started" class="headerlink" title="1.4 - Getting Started"></a>1.4 - Getting Started</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;iostream&gt;<br>#include &lt;thread&gt;<br><br>void hello()<br>&#123;<br>    std::cout &lt;&lt; &quot;Hello concurrent world.\n;<br>&#125;<br><br>int main()<br>&#123;<br>    std::thread t(hello);<br>    t.join();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Every thread has to have an <strong>initial function</strong>, where the new thread of execution begins. For the initial thread in an application, this is <strong>main()</strong>, but for every other thread it’s specified in the constructor of a <strong>std::thread</strong> object——in this case, the <strong>std::thread</strong> objecct named <strong>t</strong> has the new <strong>hellow()</strong> function as its initial function.</p>
<p>With <strong>join()</strong>, the program possibily ends before the new thread had a chance to run.</p>
<h1 id="Chapter-2-Managing-threads"><a href="#Chapter-2-Managing-threads" class="headerlink" title="Chapter.2 - Managing threads"></a>Chapter.2 - Managing threads</h1><h2 id="2-1-Basic-thread-management"><a href="#2-1-Basic-thread-management" class="headerlink" title="2.1 - Basic thread management"></a>2.1 - Basic thread management</h2><p>Every C++ program has at least one thread, which is started by the C++ runtime: the thread running main().</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class background_task<br>&#123;<br>public:<br>    void operator()() const<br>    &#123;<br>        do_something();<br>        do_something_else();<br>    &#125;<br>&#125;;<br>background_task f;<br>std::thread my_thread(f);<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">std::thread my_thread(background_task());<br></code></pre></td></tr></table></figure>
<p>One type of callable object that avoids this problem is a <strong>lambda expression</strong>. This is a new feature from C++11:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">std::thread my_thread([] &#123;<br>    do_something();<br>    do_something_else();<br>&#125;)<br></code></pre></td></tr></table></figure></p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">struct func<br>&#123;<br>    int&amp; i;<br>    func(int&amp; i_): i(_)&#123;&#125;<br>    void operator()()<br>    &#123;<br>        for (unsigned j = 0; j &lt; 10000000; ++j)<br>        &#123;<br>            do_something(i);<br>        &#125;<br>    &#125;<br>&#125;;<br><br>void oops()<br>&#123;<br>    int some_local_state=0;<br>    func my_func(some_local_state);<br>    std::thread my_thread(my_func);<br>    my_thread.detach();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>In this case, the new thread associated with <code>my_thread</code> will probably still be running when <code>oops</code> exists, because you’ve explicitly decided not to wait for it by calling <code>detach()</code>. The program will be terminated if <code>detach()</code> isn’t called.</p>
<p>If the thread is still running, you have this scenario: the nexst call to <code>do_something(i)</code> will access an already destroyed variable. This is like normal single-threaded code——allowing a pointer or reference to a local variable to persist beyond the function exit is never a good idea——but it’s earier to make the mistake with multithreaded code, because it isn’t necessarily immediately apparent that this has happened.</p>
<p>In particular, it’s a bad idea to create a thread within a function that has access to the local variables in that function, unless the thread is guarateed to finish before the function exits.</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">struct func;<br>void f()<br>&#123;<br>    int some_local_state = 0;<br>    func my_func(some_local_state);<br>    std::thread t(my_func);<br><br>    try<br>    &#123;<br>        do_something_in_current_thread();<br>    &#125;<br>    catch (...)<br>    &#123;<br>        t.join();<br>        throw;<br>    &#125;<br><br>    t.join();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-2-Passing-arguments-to-a-thread-function"><a href="#2-2-Passing-arguments-to-a-thread-function" class="headerlink" title="2.2 - Passing arguments to a thread function"></a>2.2 - Passing arguments to a thread function</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void f(int i, std::string const&amp; s);<br><br>std::thread t(f, 3, &quot;hello&quot;);<br></code></pre></td></tr></table></figure>
<p>Note that even though f takes a <code>std::string</code> as the second parameter, the string literal is passwd as a char const* and converted to a std::string only in the context of the new thread. This is particularly important when the argument supplied is a pointer to an automatic variable, as follows:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void f(int i, std::string const&amp; s);<br>void oops(int some_param)<br>&#123;<br>    char buffer[1024];<br>    sprintf(buffer, &quot;%i%, some_param);<br>    std::thread t(f, 3, buffer);<br>    t.detach();<br>&#125;<br></code></pre></td></tr></table></figure><br>In this case, it’s the pointer to the local variable <code>buffer</code> that’s passed through to the new thread and there’s a significant chance that the <code>oops</code> function will exit before the buffer has been converted to a <code>std::string</code> on the new thread, thus leading to undefined behavior. This solution is to cast to std::string before passing the buffer to the <code>std::thread</code> constructor:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void f(int i, std::string const&amp; s);<br>void oops(int some_param)<br>&#123;<br>    char buffer[1024];<br>    sprintf(buffer, &quot;%i%, some_param);<br>    std::thread t(f, 3, std::string(buffer));<br>    t.detach();<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h2 id="2-3-Transferring-ownership-of-a-thread"><a href="#2-3-Transferring-ownership-of-a-thread" class="headerlink" title="2.3 - Transferring ownership of a thread"></a>2.3 - Transferring ownership of a thread</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void some_function();<br>void some_other_function();<br>std::thread t1(some_function);<br>std::thread t2 = std::move(t1);<br>t1 = std::thread(some_other_function);<br>std::thread t3;<br>t3 = std::move(t2);<br>t1 = std::move(t3); //This assignment will terminate the program!<br></code></pre></td></tr></table></figure>
<p>First, a new thread is started and associated with <code>t1</code>. Ownership is then transferred over to <code>t2</code> when <code>t2</code> is constructed, by invoking <code>std::move()</code> to explicitly move ownership. At this point, <code>t1</code> no longer has an associated thread of execution; the thread running <code>some_function</code> is now associated with <code>t2</code>.</p>
<p>The final move tansfers ownership of the thread running <code>some_function</code> back to <code>t1</code> where it started. But in this case <code>t1</code> already had an associated thread (which was running some_other_function), so <code>std::terminate()</code> is called to terminated the program.</p>
<p>You cannot just drop a thread by assigning a new value to the <code>std::thread</code> object that manages it.</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">std::thread f()<br>&#123;<br>    void some_function();<br>    return std::thread(some_function);<br>&#125;<br>std::thread g()<br>&#123;<br>    void some_other_function(int);<br>    std::thread t(some_other_function, 42);<br><br>    return t;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Likewise, if ownership should be transferred into a function, it can accept an instance of <code>std::thread</code> by value as one of the parameters, as shown here:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void f(std::thread t);<br>void g()<br>&#123;<br>    void some_function();<br>    f(std::thread(some_function));<br>    std::thread t(some_function);<br><br>    f(std::move(t));<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class scoped_thread<br>&#123;<br>    std::thread t;<br>public:<br>    explicit scoped_thread(std::thread t_): t(std::move(t_))<br>    &#123;<br>        if (!t.joinable())<br>            throw std::logic_error(&quot;No thread&quot;);<br>    &#125;<br><br>    ~scoped_thread()<br>    &#123;<br>        t.join();<br>    &#125;<br><br>    scoped_thread(scoped_thread const&amp;) = delete;<br>    scoped_thread&amp; operator=(scoped_thread const&amp;)=delete;<br>&#125;;<br><br>struct func;<br>void f()<br>&#123;<br>    int some_local_state;<br>    scoped_thread t&#123;std::thread(func(some_local_state))&#125;;<br>    do_something_in_current_thread();<br>&#125;<br></code></pre></td></tr></table></figure></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void do_work(unsigned id);<br>void f()<br>&#123;<br>    std::vector&lt;std::thread&gt; threads;<br>    for (unsigned i = 0; i &lt; 20; ++i)<br>    &#123;<br>        threads.emplace_back(do_work, i);<br>    &#125;<br><br>    for (auto&amp; entry: threads)<br>        entry.join();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-5-Identifying-threads"><a href="#2-5-Identifying-threads" class="headerlink" title="2.5 - Identifying threads"></a>2.5 - Identifying threads</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">std::thread::id master_thread;<br>void some_core_part_of_algorithm()<br>&#123;<br>    if (std::this_thread::get_id() == master_thread)<br>    &#123;<br>        do_master_thread_work();<br>    &#125;<br><br>    do_common_work();<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="Chapter-3-Sharing-data-between-threads"><a href="#Chapter-3-Sharing-data-between-threads" class="headerlink" title="Chapter.3 - Sharing data between threads"></a>Chapter.3 - Sharing data between threads</h1><p>If you’re sharing data between threads, you need to have rules for which thread can access which bit of data when, and how any updates are communicated to the other threads that care about the data.</p>
<p>Incorrect use of shared data is one of the biggest causes of concurrency-related bugs, and the consequence can be serious.</p>
<h2 id="3-1-Problems-with-sharing-data-between-threads"><a href="#3-1-Problems-with-sharing-data-between-threads" class="headerlink" title="3.1 - Problems with sharing data between threads"></a>3.1 - Problems with sharing data between threads</h2><p>The probles with sharing data between threads are all due to the consequences of modifying data. <strong>If all shared data is read-only, there’s no problem, because the data read by on thread is unaffected by whether or not another thread is reading the same data</strong>.</p>
<p>Once concept that’s widely used to help programmers reason about their code is <strong>invariants</strong>——statements that are always true about a particular data struct, such as “this variable contains” the number of items in the list.” This invariants are often broken during an update, especially if the data structure is of any complexity or the update requires modification of more than one value.</p>
<h3 id="Race-conditions"><a href="#Race-conditions" class="headerlink" title="Race conditions"></a>Race conditions</h3><p>In concurrency, a race condition is anything where the outcome depends on the relative ordering of execution of operations on two or more threads; the threads race to perform their respective operations. This term is usually used to mean a <strong>problematic</strong> race condition.</p>
<p>The C++ standard also defines the term <strong>data race</strong> to mean the specific type of race condition; data races cause the dreaded <strong>undefined behavior</strong>.</p>
<h3 id="Avoiding-problematic-race-conditions"><a href="#Avoiding-problematic-race-conditions" class="headerlink" title="Avoiding problematic race conditions"></a>Avoiding problematic race conditions</h3><p>The simplest option is to wrap your data structure with a protection mechanism to ensure that only the thread performing a modification can see the intermediate states <strong>where the invariants are broken</strong>.</p>
<p>We can use <strong>memory model</strong>, <strong>lock-free</strong> to solve this problem.</p>
<h2 id="3-2-Protecting-shared-data-with-mutexes"><a href="#3-2-Protecting-shared-data-with-mutexes" class="headerlink" title="3.2 - Protecting shared data with mutexes"></a>3.2 - Protecting shared data with mutexes</h2><p><strong>Mutex</strong> stands for <strong>Mutual Exclusion</strong>.</p>
<p>Before accessing a shared data structure, you <strong>lock</strong> the mutex associated with that data, and when you’ve finished accessing the data structure, you <strong>unlock</strong> the mutex.</p>
<p>Mutexes are the most general of the data-rpotection mechanisms available in C++, but they’re not a silver bullet; it’s important to structure your code to protect in right data and avoid race conditions inherent in your interfaces.</p>
<p>Mutexes also come with their own problems in the form of a <strong>deadlock</strong> and protecting either too much or too little data.</p>
<h3 id="Using-mutexes-in-C"><a href="#Using-mutexes-in-C" class="headerlink" title="Using mutexes in C++"></a>Using mutexes in C++</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;mutex&gt;<br>#include &lt;algorithm&gt;<br><br>std::list&lt;int&gt; some_list;<br>std::mutex some_mutex;<br><br>void add_to_list(int new_value)<br>&#123;<br>    std::lock_guard&lt;std::mutex&gt; guard(some_mutex);<br>    some_list.push_back(new_value);<br>&#125;<br><br>bool list_contains(int value_to_find)<br>&#123;<br>    std::lock_guard&lt;std::mutex&gt; guard(some_mutex);<br>    return std::find(some_list.begin(),some_list.end(),value_to_find)<br>    != some_list.end();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>If one of he member functions returns a pointer or reference to the protected data, then it doesn’t matter that the member functions all lock the mutex in a nice, orderly fashion, because you’ve blown a big hole in the protection. **Any code that has access to that pointer or reference can now access (and potentially modify) the protected data without locking the mutex.</p>
<p>Protecting data with mutex therefore requires careful interface design to ensure that the mutex is locked befored there’s any access to the protected data and that there are no backdoor.</p>
<h3 id="Structuring-code-for-protecting-shared-data"><a href="#Structuring-code-for-protecting-shared-data" class="headerlink" title="Structuring code for protecting shared data"></a>Structuring code for protecting shared data</h3><p>Protecting data with mutex is not quite as easy as slapping an <code>std::guard</code> object in every member function; one stray pointer or reference, and all that protection is for nothing.</p>
<p>As well as checking that the member functions don’t pass out pointers or references to their callers, it’s also important to check that they don’t pass there pointers or references <strong>IN</strong> to functions they call that arent’s under you control, this is dangerous.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class some_data<br>&#123;<br>    int a;<br>    std::string b;<br>public:<br>    void do_something();<br>&#125;;<br>class data_wrapper<br>&#123;<br>private:<br>    some_data data;<br>    std::mutex m;<br>public:<br>    template&lt;typename Function&gt;<br>    void process_data(Function func)<br>    &#123;<br>        std::lock_guard&lt;std::mutex&gt; l(m);<br>        func(data);<br>    &#125;<br>&#125;;<br><br>some_data* unprotected;<br>void malicious_function(some_data&amp; protected_data)<br>&#123;<br>    unprotected=&amp;protected_data;<br>&#125;<br><br>data_wrapper x;<br>void foo()<br>&#123;<br>    x.process_data(malicious_function);<br>    upprotected-&gt;do_something();<br>&#125;<br></code></pre></td></tr></table></figure><br>In this example, the code in <code>process_data</code> looks harmless enough, nicely protected with <code>std::lock_guard</code>, but the call to the user-supplied <code>func</code> function means that <code>foo</code> can pass in <code>malicious_function</code> to <strong>bypass the protection</strong> and then call <code>do_something()</code> without the mutex being locked.</p>
<blockquote>
<p>Guidline: Don’t pass pointers and references to protected data outside the scope of the lock, whether by returning them from a function, storing them in externally visible memory, or passing them as arguments to user-supplied functions.</p>
</blockquote>
<p>Just because you’re using a mutex or other mechanism to protect shared data, it doesn’t mean you’re protected from race conditions; you still have to ensure that the appropriate data is protected.</p>
<p>Consider the doubly linked list example. If you protected access to the pointers of each node individually, you’d be no better off than with code that used no mutexes, because the race condition could still happen——it’s not the individual nodes that need protecting for the individual steps but the whole data structure, for the whole delete operation. The easiest solution in this case is to have a single mutex that protects the entire list.</p>
<h3 id="Deadlock-the-problem-and-a-solution"><a href="#Deadlock-the-problem-and-a-solution" class="headerlink" title="Deadlock: the problem and a solution"></a>Deadlock: the problem and a solution</h3><p>Imagine a pair of threads arguing over locks on mutexes: each of a pair of threads needs to lock both of a pair of mutexes to perform some operation, and each thread has one mutex and is waiting for the other. Neither thread can proceed, because each is waiting for the other to release its mutex. This scenario is called <strong>deadlock</strong>, and it’s the biggest problem with having to lock two or more mutexes in order to perform an operation.</p>
<p>The common advice for avoiding deadlock is to always lock the two mutexes in the same order.</p>
<p>The C++ Standard Library has a cure for this in the form of <code>std::lock</code>——a function that can lock two or more mutexes at once without risk of deadlock.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class some_big_object;<br>void swap(some_big_object&amp; lhs, some_big_object&amp; rhs);<br>class X<br>&#123;<br>private:<br>    some_big_object some_detail;<br>    std::mutex m;<br>public:<br>    X(some_big_object const&amp; sd): some_detail(sd) &#123;&#125;<br><br>    friend void swap(X&amp; lhs, X&amp; rhs)<br>    &#123;<br>        if (&amp;lhs==&amp;rhs)<br>            return;<br><br>        std::lock(lhs.m, rhs.m);<br>        std::lock_guard&lt;std::mutex&gt; lock_a(lhs.m, std::adopt_lock);<br>        std::lock_guard&lt;std::mutex&gt; lock_b(rhs.m, std::adopt_lock);<br>        swap(lhs.some_detail, rhs.some_detail);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>First, the arguments are checked to ensure they are different instances, because attempting to acquire a lock on <code>std::mutex</code> when you already hold it is undefined behavior (A mutex that does permit multiple locks by the same thread is provided in the form of <code>std::recursive_mutex</code>.).<br>Then, the call to <code>std::lock()</code> locks the two mutexes, and two <code>std::lock_guard</code> instances are constructed and, one for each mutex.<br>The <code>std::adopt_lock</code> parameter is supplied in addition to the mutex to indicate to the <code>std::lock_guard</code> objects that the mutexes are already locked, and they should adopt the ownership of the existing lock on the mutex rather than attempt to lock the mutex in the constructor.</p>
<p>C++17 provides additional support for this scenario, in the form of a new RAII termplate, <code>std::scoped_lock&lt;&gt;</code>. This is exactly equivalent to <code>std::lock_guard&lt;&gt;</code>, except that it is a <strong>variadic template</strong>, accepting a <strong>list</strong> of mutex types as template parameters, and a <strong>list</strong> of mutexes as constructor arguments. The mutexes supplied to the constructor are locked using the same algorithm as <code>std::lock</code>, so that when the constructor completes they are all locked, and they are then all unlocked in the destructor.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void swap(X&amp; lhs, X&amp; rhs)<br>&#123;<br>    if(&amp;lhs==&amp;rhs)<br>        return;<br>    std::scoped_lock guard(lhs.m,rhs.m);<br>    swap(lhs.some_detail,rhs.some_detail);<br>&#125;<br></code></pre></td></tr></table></figure><br>This example uses another feature added with C++17: automatic deduction of class template parameters.<br>This line is equivalent to the equivalent to the fully specified version:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">std::scoped_lock&lt;std::mutex, std::mutex&gt; guard(lhs.m, rhs.m);<br></code></pre></td></tr></table></figure></p>
<p>The existence of <code>std::scoped_lock</code> means that most of the cases where you would have used <code>std::lock</code> prior to C++17 can now be written using <code>std::scoped_lock</code>, with less potential for mistakes.</p>
<p>You have to rely on your discipline as developers to ensure you don’t get get deadlock. This isn’t easy: deadlocks are one of the nastiest problems to encounter in multithreaded code and are often unpredictable, with everything working fine the majority of the time.</p>
<h3 id="Futher-guidlines-for-avoiding-deadlock"><a href="#Futher-guidlines-for-avoiding-deadlock" class="headerlink" title="Futher guidlines for avoiding deadlock"></a>Futher guidlines for avoiding deadlock</h3><p>Deadlock doesn’t only occur with locks. You can create deadlock with two threads and no locks by having each thread call <code>join()</code> on the <code>std::thread</code> object for the other. In this case, neither thread can make progress because it’s waiting for the other to finish.</p>
<p>The guidlines for avoiding deadlock all boil down to one idea: don’t wait for another thread if there’s a chance it’s waiting for you.</p>
<ul>
<li><strong>Avoid nested locks</strong>:<br>Don’t acquire a lock if you already hold one. If you stick to this guidline, it’s impossible to get a deadlock from the lock usage alone because each thread only ever holds a single lock. You should still get deadlock from other things (like the threads waiting for each other), but mutex locks are probably the most common cause of deadlock.</li>
<li><strong>Avoid calling user-suplied code while holding a lock</strong>:<br>This is a simple follow-on from the previous guidline. Because the code is user-supplied, you have no idea what it could do; it could do anything, including acquiring a lock.</li>
<li><strong>Acquire locks in a fixed order</strong>:<br>If you absolutely must acquire two or more locks, and you can’t acquire them as a single operation with <code>std::lock</code>, the next best thing is to acquire them in the same order in every thread.</li>
<li><strong>Use a lock hiearchy</strong>:<br>Although this is a particular case of defining lock ordering, a lock hierarchy can provide a means of checking that the convention is adhered to at runtime. The idea is that you divide your application into layers and identify all the mutexes that may be locked in any given layer.</li>
<li><strong>Extending these guidlines beyond locks</strong>:<br>Deadlocks also occur with any synchronization construct that can lead to a wait cycle.\<br>If you’re going to wait for a thread to finish, it might be worth identifying a thread hierarchy, so that a thread waits only for threads lower down the hierarchy. One simple way to do this is to ensure that your threads are joined in the same function that started them.</li>
</ul>
<h3 id="Flexible-locking-with-std-unique-lock"><a href="#Flexible-locking-with-std-unique-lock" class="headerlink" title="Flexible locking with std::unique_lock"></a>Flexible locking with <code>std::unique_lock</code></h3><p>Once you’ve designed your code to avoid deadlock, <code>std::lock()</code> and <code>std::lock_guard</code> cover most of the cases of simle locking, but sometimes more flexibility is required.</p>
<p><code>std::unique_lock</code> provides a bit more flexibility than <code>std::lock_guard</code> by relaxing the invariants; an <code>std::unique_lock</code> instance doesn’t always own the mutex that it’s associated with.</p>
<p>You can pass <code>std::adopt_lock</code> as a second argument to the constructor to have the lock object manage the lock on a mutex, you can also pass <code>std::defer_lock</code> as the second argument to indicate that the mutex should remain unlocked on construction.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class some_big_object;<br>void swap(some_big_object&amp; lhs,some_big_object&amp; rhs);<br>class X<br>&#123;<br>private:<br>    some_big_object some_detail;<br>    std::mutex m;<br>public:<br>    X(some_big_object const&amp; sd):some_detail(sd)&#123;&#125;<br>    friend void swap(X&amp; lhs, X&amp; rhs)<br>    &#123;<br>        if (&amp;lhs == &amp;rhs)<br>            return;<br><br>        std::unique_lock&lt;std::mutex&gt; lock_a(lhs.m, std::defer_lock);<br>        std::unique_lock&lt;std::mutex&gt; lock_b(rhs.m, std::defer_lock);<br>        std::lock(lock_a, lock_b);<br>        swap(lhs.some_detail, rhs.some_detail);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>Using <code>std::unique_lock</code> and <code>std::defer_lock</code>, rather than <code>std::lock_guard</code> and <code>std::adopt_lock</code>.</p>
<p><code>std::unique_lock</code> objects could be passed to <code>std::lock()</code>, because <code>std::unique_lock</code> provides <code>lock()</code>, <code>try_lock()</code>, and <code>unlock()</code> member functions.</p>
<h3 id="Transferring-mutex-ownership-between-scopes"><a href="#Transferring-mutex-ownership-between-scopes" class="headerlink" title="Transferring mutex ownership between scopes"></a>Transferring mutex ownership between scopes</h3><p>Because <code>std::unique_lock</code> instances don’t have to own their associated mutexes, the ownership of mutex can be transferred between instances by moving the instances around.</p>
<h3 id="Locking-at-an-appropriate-granularity"><a href="#Locking-at-an-appropriate-granularity" class="headerlink" title="Locking at an appropriate granularity"></a>Locking at an appropriate granularity</h3><p>The lock granularity is a hand-waving term to describe the amount of data protected by a single lock. A fine-grained lock protects a small amount of data, and a coarse-grained lock protects a large amount of data.</p>
<h2 id="3-3-Alternative-facilities-for-protecting-shared-data"><a href="#3-3-Alternative-facilities-for-protecting-shared-data" class="headerlink" title="3.3 - Alternative facilities for protecting shared data"></a>3.3 - Alternative facilities for protecting shared data</h2><h1 id="Chapter-4-Synchronizing-concurrent-operations"><a href="#Chapter-4-Synchronizing-concurrent-operations" class="headerlink" title="Chapter.4 - Synchronizing concurrent operations"></a>Chapter.4 - Synchronizing concurrent operations</h1><p>Sometimes you don’t just need to protect the data, you also need to synchronize actions on separate threads. One thread might need to wait for another thread to complete a task before the thread can complete its own, for example. In general, it’s common to want a thread to wait for a specific event to happen or a condition to be <code>true</code>.</p>
<h2 id="4-1-Waiting-for-an-event-or-other-condition"><a href="#4-1-Waiting-for-an-event-or-other-condition" class="headerlink" title="4.1 - Waiting for an event or other condition"></a>4.1 - Waiting for an event or other condition</h2><p>If one thread is waiting for a second thread to complete a task, it has several options. First, it could keep checking a flag in shared data (protected by mutex) and have the second thread set the flag when it come pletes the task. This is wasteful on two counts: the thread consumes valuable processing time repeatedly checking the flag, and when the mutex is locked by the waiting thread, it can’t be locked by any other thread.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">bool flags;<br>std::mutex m;<br>void wait_for_flag()<br>&#123;<br>    std::unique_lock&lt;std::mutex&gt; lk(m);<br>    std::this_thread::sleep_for(std::chrono::miliseconds(100));<br>    lk.lock();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>In the loop, the function unlocks the mutex before the sleep, and locks it again afterward so another thread gets a chance to acquire it and set the flag.</p>
<p>This is an improvement because the thread does not waste processing time while it’s sleep, but it’s hard to get the sleep period right.</p>
<p><strong>The third and preferred option is to use the facilities from the C++ Standard Libaray to wait for the event itself</strong>.</p>
<h3 id="Waiting-for-a-condition-with-condition-variables"><a href="#Waiting-for-a-condition-with-condition-variables" class="headerlink" title="Waiting for a condition with condition variables"></a>Waiting for a condition with condition variables</h3><p>The Standard C++ Library provides two implementations of a condition variable: <code>std::condition_variable</code> and <code>std::condition_variable_any</code>. Both of these are declared in the <code>&lt;condition_variable&gt;</code> library header.</p>
<p>In both cases, they need to work with a mutex in order to provide appropriate synchronization the former is limited to working with <code>std::mutex</code>, whereas the latter can work with anything that meets the mimimal criteria for being mutex-like, hence the <code>_any</code> suffix. </p>
<p><code>std::condition_variable_any</code> is more general, there’s the potential for additional consts in terms of size, performance, or OS resources, so <code>std::condition_variable</code> should be preferred unless the additional flexibility is required.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">std::mutex mut;<br>std::queue&lt;data_chunk&gt; data_queue;<br>std::condition_variable data_cond;<br><br>void data_preparation_thread()<br>&#123;<br>    while (more_data_to_prepare())<br>    &#123;<br>        data_chunk const data = prepare_data();<br>        &#123;<br>            std::lock_guard&lt;std::mutex&gt; lk(mut);<br>            data_queue.push(data);<br>        &#125;<br><br>        data_cond.notify_one();<br>    &#125;<br>&#125;<br><br>void data_processing_thread()<br>&#123;<br>    while (true)<br>    &#123;<br>        std::unique_lock&lt;std::mutex&gt; lk(mut);<br>        data_cond.wait(<br>            lk, []&#123;return !data_queue.empty();&#125;<br>        );<br>        data_chunk data = data_queue.front();<br>        data_queue.pop();<br>        lk.unlock();<br>        process(data);<br>        if (is_last_chunk(data))<br>            break;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>You have a queue that’s used to pass the data between two therads.</li>
<li>Note that you put the code to push the data onto the queue in a smaller scope, so you notify the condition variable <strong>after</strong> unlocking the mutex.</li>
<li>On the other side of the fence, you have the processing thread. This thread first locks the mutex, but this time with a <code>std::unique_lock</code> rather than a <code>std::lock_guard</code>. The reason is <code>std::unique_lock</code> is reusable. The waiting thread must unlock the mutex while it’s waiting and lock it again afterward, and <code>std::lock_guard</code> doesn’t provide that flexibility.</li>
</ol>
<h1 id="Chapter-5-The-C-memory-model-and-operations-on-atomic-types"><a href="#Chapter-5-The-C-memory-model-and-operations-on-atomic-types" class="headerlink" title="Chapter.5 - The C++ memory model and operations on atomic types"></a>Chapter.5 - The C++ memory model and operations on atomic types</h1><p>This chapter will start by convering the basic of the memory model, then move on to the atomic types and operations, and finally cover the various types of synchronization available with the operations on atomic types.</p>
<h2 id="5-1-Memory-model-basic"><a href="#5-1-Memory-model-basic" class="headerlink" title="5.1 - Memory model basic"></a>5.1 - Memory model basic</h2><h3 id="Objects-and-memory-locations"><a href="#Objects-and-memory-locations" class="headerlink" title="Objects and memory locations"></a>Objects and memory locations</h3><p>The C++ Standard defines an object as “a region of storage”, although it goes on to assign properties to these objects, such as their type and lifetime.</p>
<p>Whatever its type, an object is stored in one or more <strong>memory locations</strong>. Each memory location is either an object (or sub-object) of a scalar type such as <code>unsigned short</code> or <code>my_class*</code> or a sequence of adjacent bit fields. If you use bit fields, this is an important point to note: though adjacent bit fields are distinct objects, they’re still counted as the same memory location.</p>
<p align="center" class='item-img' data-src='/images/books/CppConcurrency/fig5.1.png'><img src="/images/books/CppConcurrency/fig5.1.png" width="400">
</p>

<p>There are four important things to take away from this:</p>
<ol>
<li>Every variable is an object, including those that are members of other objects.</li>
<li>Every object occupies <strong>at least one</strong> memory location.</li>
<li>Variables of fundamental types such as <code>int</code> or <code>char</code> occupy exactly <strong>one</strong> memory location, whatever their size, even if they’re adjacent or part of an array.</li>
<li>Adjacent bit fields are part of the same memory location.</li>
</ol>
<h3 id="Objects-memory-locations-and-concurrency"><a href="#Objects-memory-locations-and-concurrency" class="headerlink" title="Objects, memory locations and concurrency"></a>Objects, memory locations and concurrency</h3><p>If two threads access <strong>separate</strong> memory locations, there’s no problem: everything works fine. On the other hand, if two threads access the <strong>same</strong> memory location, then you have to be careful.\<br>If neither thread is updating the memory location, you’re fine; read-only data does not need protection or synchronization.<br>If either thread is modifying the data, there’s a potential for a race condition.</p>
<p>Solutions:</p>
<ol>
<li>mutexes.</li>
<li>Synchronization properties of <strong>atomic</strong> operations.</li>
</ol>
<p>If two threads access the same memory location, each pair of accesses must have a defined ordering.</p>
<p>If there’s no enofrced ordering between two accesses to a single memory location from separate threads, one or both of those accesses is no atomic, and if one or both is a write, then this is a data race and causes undefined behavior.</p>
<h3 id="Modification-orders"><a href="#Modification-orders" class="headerlink" title="Modification orders"></a>Modification orders</h3><p>If you do use atomic operations, the compiler is responsible for ensuring that the necessary synchronization is in place.\<br>This requirement means that certain kinds of speculative execution ain’t permitted, because once a thread has seen a particular entry in the modification order, subsequent reads from that thread must return laster values, and subsequent writes from that thread to that object must occur laster in the modification order.</p>
<h2 id="5-2-Atomic-operations-and-types-in-C"><a href="#5-2-Atomic-operations-and-types-in-C" class="headerlink" title="5.2 - Atomic operations and types in C++"></a>5.2 - Atomic operations and types in C++</h2><p>An <strong>atomic operation</strong> is an indivisible operation. You can’t observe such an operation half-done from any thread in the system; it’s either done or not done.</p>
<p>If the load operation that reads the value of an object is <strong>atomic</strong>, and all modifications to that object are also <strong>atomic</strong>.</p>
<p>The flip side of this is that a non-atomic operation might be seen as half-done by another thread. If the non-atomic operation is composed of atomic operaitons (for example, assignment to <code>struct</code> with <code>atomic</code> members), then other threads may observe some sbuset of the constituent atomic operation as complete, but others as not yet started, so you might observe or end up with a value that is a mixed-up combination<br>of the various values stored.</p>
<h3 id="The-standard-atomic-types"><a href="#The-standard-atomic-types" class="headerlink" title="The standard atomic types"></a>The standard atomic types</h3><p>The standard <strong>atomic types</strong> can be found in the <code>&lt;atomic&gt;</code> header. All operations on such types are atomic, and only operations on these types are atomic in the sense of the language definition, although you can use mutexes to make other operation <strong>appear</strong> atomic.</p>
<p>This is important to know in many cases——the key use case for atomic operations is as a replacement for an operation that would otherwise use a mutex for synchronization.</p>
<p>The library provides a set of macros to identify at compile time whether the atomic types for the various integral types are lock-free.</p>
<p>Since C++17, all atomic types have a <code>static constexpr</code> member variable, <code>X::is_always_lock_free</code>, which is <code>true</code> if and only if the atomic type <code>X</code> is lock-free for all supported hardware that the output of the current compilation might run on.</p>
<h1 id="Chapter-6-Designing-lock-based-concurrent-data-structures"><a href="#Chapter-6-Designing-lock-based-concurrent-data-structures" class="headerlink" title="Chapter.6 - Designing lock-based concurrent data structures"></a>Chapter.6 - Designing lock-based concurrent data structures</h1><h1 id="Chapter-7-Designing-lock-free-concurrent-data-structures"><a href="#Chapter-7-Designing-lock-free-concurrent-data-structures" class="headerlink" title="Chapter.7 - Designing lock-free concurrent data structures."></a>Chapter.7 - Designing lock-free concurrent data structures.</h1><h1 id="Chapter-8-Designing-concurrent-code"><a href="#Chapter-8-Designing-concurrent-code" class="headerlink" title="Chapter.8 - Designing concurrent code"></a>Chapter.8 - Designing concurrent code</h1><h1 id="Chapter-10-Advanced-thread-management"><a href="#Chapter-10-Advanced-thread-management" class="headerlink" title="Chapter.10 - Advanced thread management"></a>Chapter.10 - Advanced thread management</h1><div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2026/01/09/2026-1-9-BookLinuxFirewall/">← Next [Book] Linux Firewalls: Enhancing Security with nftables and Beyond, 4/e</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2026/01/07/2026-1-7-CppTemplatesTheCompleteGuide2ed/">[Book] C++ Templates - The Complete Guide (Second Edition) Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="To Catalog">≡</a><a id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://avatars.githubusercontent.com/u/110074064?v=4" alt="Logo"></a><h1 id="Dr"><a href="/">ISSAC</a></h1><div id="description"><p>Everything is failing...</p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/iss4cf0ng/"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://gist.github.com/iss4cf0ng/"><i class="fa-solid fa-code" alt="Gist"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#El-Libro"><span class="toc-number">1.</span> <span class="toc-text">El Libro</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction"><span class="toc-number">2.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reflection"><span class="toc-number">3.</span> <span class="toc-text">Reflection</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1-Hello-world-of-concurrency"><span class="toc-number">4.</span> <span class="toc-text">Chapter.1 - Hello, world of concurrency</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-What-is-concurrency"><span class="toc-number">4.1.</span> <span class="toc-text">1.1 - What is concurrency</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Concurrency-vs-Parallelism"><span class="toc-number">4.1.1.</span> <span class="toc-text">Concurrency vs. Parallelism</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Getting-Started"><span class="toc-number">4.2.</span> <span class="toc-text">1.4 - Getting Started</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2-Managing-threads"><span class="toc-number">5.</span> <span class="toc-text">Chapter.2 - Managing threads</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Basic-thread-management"><span class="toc-number">5.1.</span> <span class="toc-text">2.1 - Basic thread management</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Passing-arguments-to-a-thread-function"><span class="toc-number">5.2.</span> <span class="toc-text">2.2 - Passing arguments to a thread function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Transferring-ownership-of-a-thread"><span class="toc-number">5.3.</span> <span class="toc-text">2.3 - Transferring ownership of a thread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.4.</span> <span class="toc-text">1234567891011121314151617181920212223242526class scoped_thread{    std::thread t;public:    explicit scoped_thread(std::thread t_): t(std::move(t_))    {        if (!t.joinable())            throw std::logic_error(&quot;No thread&quot;);    }    ~scoped_thread()    {        t.join();    }    scoped_thread(scoped_thread const&amp;) &#x3D; delete;    scoped_thread&amp; operator&#x3D;(scoped_thread const&amp;)&#x3D;delete;};struct func;void f(){    int some_local_state;    scoped_thread t{std::thread(func(some_local_state))};    do_something_in_current_thread();}</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-Identifying-threads"><span class="toc-number">5.5.</span> <span class="toc-text">2.5 - Identifying threads</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-3-Sharing-data-between-threads"><span class="toc-number">6.</span> <span class="toc-text">Chapter.3 - Sharing data between threads</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Problems-with-sharing-data-between-threads"><span class="toc-number">6.1.</span> <span class="toc-text">3.1 - Problems with sharing data between threads</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Race-conditions"><span class="toc-number">6.1.1.</span> <span class="toc-text">Race conditions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Avoiding-problematic-race-conditions"><span class="toc-number">6.1.2.</span> <span class="toc-text">Avoiding problematic race conditions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Protecting-shared-data-with-mutexes"><span class="toc-number">6.2.</span> <span class="toc-text">3.2 - Protecting shared data with mutexes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-mutexes-in-C"><span class="toc-number">6.2.1.</span> <span class="toc-text">Using mutexes in C++</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Structuring-code-for-protecting-shared-data"><span class="toc-number">6.2.2.</span> <span class="toc-text">Structuring code for protecting shared data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deadlock-the-problem-and-a-solution"><span class="toc-number">6.2.3.</span> <span class="toc-text">Deadlock: the problem and a solution</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Futher-guidlines-for-avoiding-deadlock"><span class="toc-number">6.2.4.</span> <span class="toc-text">Futher guidlines for avoiding deadlock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flexible-locking-with-std-unique-lock"><span class="toc-number">6.2.5.</span> <span class="toc-text">Flexible locking with std::unique_lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transferring-mutex-ownership-between-scopes"><span class="toc-number">6.2.6.</span> <span class="toc-text">Transferring mutex ownership between scopes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Locking-at-an-appropriate-granularity"><span class="toc-number">6.2.7.</span> <span class="toc-text">Locking at an appropriate granularity</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Alternative-facilities-for-protecting-shared-data"><span class="toc-number">6.3.</span> <span class="toc-text">3.3 - Alternative facilities for protecting shared data</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-4-Synchronizing-concurrent-operations"><span class="toc-number">7.</span> <span class="toc-text">Chapter.4 - Synchronizing concurrent operations</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Waiting-for-an-event-or-other-condition"><span class="toc-number">7.1.</span> <span class="toc-text">4.1 - Waiting for an event or other condition</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Waiting-for-a-condition-with-condition-variables"><span class="toc-number">7.1.1.</span> <span class="toc-text">Waiting for a condition with condition variables</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-5-The-C-memory-model-and-operations-on-atomic-types"><span class="toc-number">8.</span> <span class="toc-text">Chapter.5 - The C++ memory model and operations on atomic types</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-Memory-model-basic"><span class="toc-number">8.1.</span> <span class="toc-text">5.1 - Memory model basic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Objects-and-memory-locations"><span class="toc-number">8.1.1.</span> <span class="toc-text">Objects and memory locations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Objects-memory-locations-and-concurrency"><span class="toc-number">8.1.2.</span> <span class="toc-text">Objects, memory locations and concurrency</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modification-orders"><span class="toc-number">8.1.3.</span> <span class="toc-text">Modification orders</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Atomic-operations-and-types-in-C"><span class="toc-number">8.2.</span> <span class="toc-text">5.2 - Atomic operations and types in C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-standard-atomic-types"><span class="toc-number">8.2.1.</span> <span class="toc-text">The standard atomic types</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-6-Designing-lock-based-concurrent-data-structures"><span class="toc-number">9.</span> <span class="toc-text">Chapter.6 - Designing lock-based concurrent data structures</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-7-Designing-lock-free-concurrent-data-structures"><span class="toc-number">10.</span> <span class="toc-text">Chapter.7 - Designing lock-free concurrent data structures.</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-8-Designing-concurrent-code"><span class="toc-number">11.</span> <span class="toc-text">Chapter.8 - Designing concurrent code</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-10-Advanced-thread-management"><span class="toc-number">12.</span> <span class="toc-text">Chapter.10 - Advanced thread management</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {code.findCode();
document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script src="/js/slide.js"></script></body></html>