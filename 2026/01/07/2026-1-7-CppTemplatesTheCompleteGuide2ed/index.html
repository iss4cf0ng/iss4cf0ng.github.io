<!DOCTYPE html><html lang="en-us" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>[Book] C++ Templates - The Complete Guide (Second Edition) | ISSAC/iss4cf0ng's blog</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":true,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy","copyFinish":"copied","expand":"expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/brands.min.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
@font-face {
 font-family: 'Font Awesome 6 Brands';
 src: local('Font Awesome 6 Brands'), url('/lib/fontawesome/fa-brands.woff2') format('woff2');
}
@font-face {
 font-family: 'Font Awesome 6 Free';
 src: local('Font Awesome 6 Free'), url('/lib/fontawesome/fa-regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ISSAC/iss4cf0ng's blog" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/About/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/Alien/"><span class="navItemTitle">Alien</span></a></li><li class="navItem"><a class="navBlock" href="/2026/01/28/2026-1-28-ToolsDuplexSpy-v2-0-0/"><span class="navItemTitle">DuplexSpy</span></a></li><li class="navItem"><a class="navBlock" href="/Notes/"><span class="navItemTitle">Notes</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>[Book] C++ Templates - The Complete Guide (Second Edition)</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2026-01-07T06:38:34.000Z" id="date"> 2026-01-07</time></div></span><br><span>Last Update: <div class="control"><time datetime="2026-01-15T09:22:53.607Z" id="updated"> 2026-01-15</time></div></span><br><span>Word Count: <div class="control">3.6k</div></span><br><span>Read Time: <div class="control">22 min</div></span></div></div><hr><div id="post-content"><h1 id="El-libro"><a href="#El-libro" class="headerlink" title="El libro"></a>El libro</h1><p align="center" class='item-img' data-src='/images/books/CppTemplate/libro.png'><img src="/images/books/CppTemplate/libro.png" width="500">
</p>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>This article is used to keep notes and summaries of the book “C++ Templates - The Complete Guide (Second Edition)”.<br>The content will be continuously updated as I read through the book.</p>
<h1 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h1><h1 id="Chapter-1-Function-Templates"><a href="#Chapter-1-Function-Templates" class="headerlink" title="Chapter.1 - Function Templates"></a>Chapter.1 - Function Templates</h1><h2 id="1-1-Function-Templates"><a href="#1-1-Function-Templates" class="headerlink" title="1.1 - Function Templates"></a>1.1 - Function Templates</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T&gt;<br>T max(T a, T b)<br>&#123;<br>  return b &lt; a ? a : b;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>template parameters must be announced with syntax of the following form:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;comma-separated-list of parameters&gt;<br></code></pre></td></tr></table></figure><br>Here, the type parameter is <strong>T</strong>. You can use any identifier as a parameter name, but using <strong>T</strong> is the convention. The type parameter represents an arbitrary type that is determined by the caller when the caller calls the function.</p>
<p>For historical reasons, you can also use the keyworkd <em>class</em> instead of <em>typename</em> to define a type parameter.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;class T&gt;<br>T max(T a, T b)<br>&#123;<br>  return b &lt; a ? a : b;<br>&#125;<br></code></pre></td></tr></table></figure><br>Semantically there is no difference. However, because this use of <em>class</em> can be misleading(not only class types can be substituted for <strong>T</strong>), you should prefer the use of <em>typename</em> in this context.<br>The keyword <em>struct</em> cannot be used in place of <em>typename</em> when declaring type parameters.</p>
<p>Example of using max() function template:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &quot;max1.hpp&quot;<br><br>int main()<br>&#123;<br>  int i = 42;<br>  std::cout &lt;&lt; &quot;max(7, i): &quot; &lt;&lt; ::max(7, i) &lt;&lt; std::endl;<br><br>  double f1 = 3.4;<br>  double f2 = -6.7;<br>  std::cout &lt;&lt; &quot;max(f1, f2): &quot; &lt;&lt; ::max(f1, f2) &lt;&lt; std::endl;<br><br>  std::string s1 = &quot;mathematics&quot;;<br>  std::string s2 = &quot;math&quot;;<br>  std::cout &lt;&lt; &quot;max(s1, s2): &quot; &lt;&lt; ::max(s1, s2) &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><br>Output:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">max(7,i): 42<br>max(f1,f2): 3.4<br>max(s1,s2): mathematics<br></code></pre></td></tr></table></figure><br>Note that each call of the <em>max()</em> template is qualified with <em><strong>::</strong></em>. This is to ensure that our <em>max()</em> template is found in the global namespace. This is also a <em>std::max()</em> template in the standard libaray, which under some circumstances may be called or maylead to ambiguity.</p>
<p><em>void</em> is a valid template argument provided the resulting code is valid:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T&gt;<br>T foo(T*)<br>&#123;<br><br>&#125;<br><br>void *vp = nullptr;<br>foo(vp); //OK<br>//foo(void*); NOT OK<br></code></pre></td></tr></table></figure></p>
<h3 id="Two-Phase-Translation"><a href="#Two-Phase-Translation" class="headerlink" title="Two-Phase Translation"></a>Two-Phase Translation</h3><p>An attempt to instantiate a template for a type that doesn’t support all the operations used within it will result in a compile-time error:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">std::complex&lt;flat&gt; c1, c2; //doesn&#x27;t provide operator &lt;<br>...<br>::max(c1, c2);<br></code></pre></td></tr></table></figure><br>templates are <strong>compiled</strong> in two phase:</p>
<ol>
<li>Without instantiation at <strong>definition time</strong>, the template code itself is checked for correctness ignoring the template parameters:<ol>
<li>Syntax errors.</li>
<li>Using unknown names.</li>
<li>Static assertions that don’t depend on template parameters are checked.</li>
</ol>
</li>
<li>At <em>instantiation time</em>, the template code is checked(again) to ensure that all code is valid.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T&gt;<br>void foo(T t)<br>&#123;<br>  undeclared(); // first-phase compile-time error if undeclared() unknown<br>  undeclared(t); // second-phase compile-time error if undeclared(T) unknown<br>  static_assert(sizeof(int) &gt; 10, // always fails if sizeof(int)&lt;=10 &quot;int too small&quot;);<br>  static_assert(sizeof(T) &gt; 10, //fails if instantiated for T with size &lt;=10 &quot;T too small&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-2-Template-Arugment-Deduction"><a href="#1-2-Template-Arugment-Deduction" class="headerlink" title="1.2 - Template Arugment Deduction"></a>1.2 - Template Arugment Deduction</h2><p>Automatic type conversions are limited during type deduction:</p>
<ul>
<li>When declaring call parameters by reference, even trivial conversions do not apply to type deduction. Two arguments declared with the same template parameter T <strong>must match exactly</strong>.</li>
<li>When declaring call parameters by value, only trivial conversions that <em>decay</em> are supported: Qualifications with <strong>const</strong> or <strong>volatile</strong> are ignored, references convert to the referenced type, and raw arrays or functions convert to the corresponding pointer type.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T&gt;<br>T max (T a, T b);<br>… <br>int const c = 42;<br>max(i, c); // OK: T is deduced as int<br>max(c, c); // OK: T is deduced as int<br>int&amp; ir = i;<br>max(i, ir); // OK: T is deduced as int<br>int arr[4];<br>foo(&amp;i, arr); // OK: T is deduced as int*<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">max(4, 7.2); //ERROR: T can be deduced as int or double<br>std::string s;<br>foo(&quot;Hello&quot;, s); //ERROR: T can be deduced as char const[6] or std::string<br></code></pre></td></tr></table></figure>
<p>There are three ways to handle such errors:</p>
<ol>
<li>Cast the arguments so that they both match:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">max(static_cast&lt;double&gt;(4), 7.2);<br></code></pre></td></tr></table></figure></li>
<li>Specify(or qualify) explicity the type of <strong>T</strong> to prevent the compiler from attempting type deduction:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">max&lt;double&gt;(4, 7.2);<br></code></pre></td></tr></table></figure></li>
<li>Specify that the parameters may have different types.</li>
</ol>
<p>Type Deduction for Default Arguments<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T&gt;<br>void f(T = &quot;&quot;);<br><br>f(1); //OK: deduced T to be int, so that it calls f&lt;int&gt;(1)<br>f(); //ERROR: cannot deduce T<br></code></pre></td></tr></table></figure><br>To support this case:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T = std::string&gt;<br>void f(T = &quot;&quot;);<br>...<br><br>f(); //OK<br></code></pre></td></tr></table></figure></p>
<blockquote>
<p>Important: <strong>Template argument deduction is performed before default arguments are considered</strong>.</p>
</blockquote>
<h2 id="1-3-Multiple-Template-Parameters"><a href="#1-3-Multiple-Template-Parameters" class="headerlink" title="1.3 - Multiple Template Parameters"></a>1.3 - Multiple Template Parameters</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T1, typename T2&gt;<br>T1 max (T1 a, T2 b)<br>&#123;<br>  return b &lt; a ? a : b; <br>&#125;<br>… <br>auto m = ::max(4, 7.2); // OK, but type of first argument defines return type<br></code></pre></td></tr></table></figure>
<h3 id="Template-Parameters-for-Return-Types"><a href="#Template-Parameters-for-Return-Types" class="headerlink" title="Template Parameters for Return Types"></a>Template Parameters for Return Types</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T1, typename T2, typename RT&gt;<br>RT max (T1 a, T2 b);<br></code></pre></td></tr></table></figure>
<p>However, template argument deduction does not take return types into account, and <strong>RT</strong> does not appear in the types of the function call parameters. Therefore, <strong>RT</strong> cannot be deduced.</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T1, typename T2, typename RT&gt;<br>RT max (T1 a, T2 b);<br>…<br>::max&lt;int,double,double&gt;(4, 7.2); // OK, but tedious<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename RT, typename T1, typename T2&gt;<br>RT max (T1 a, T2 b);<br>…<br>::max&lt;double&gt;(4, 7.2) //OK: return type is double, T1 and T2 are deduced<br></code></pre></td></tr></table></figure>
<h3 id="Deducing-the-Return-Type"><a href="#Deducing-the-Return-Type" class="headerlink" title="Deducing the Return Type"></a>Deducing the Return Type</h3><p>Since C++14, this is possible by simply not declaring any return type(you still have to declare the return type to be <strong>auto</strong>):<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T1, typename T2&gt;<br>auto max(T1 a, T2 b)<br>&#123;<br>  return b &lt; a ? a : b;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>Before C++14, it is only possible to let the compiler determine the return type by more or less making the implementation of the function part of its declaration. In C++11 we can benefit from the fact that the trailing return type syntax allows us to use the call parameters. That is, we can declare that the return type is derived from what operator?: yields:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T1, typename T2&gt;<br>auto max(T1 a, T2 b) -&gt; decltype(b &lt; a ? a : b)<br>&#123;<br>  return b &lt; a ? a : b;<br>&#125;<br></code></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T1, typename T2&gt;<br>auto max(T1 a, T2 b) -&gt; decltype(b&lt;a?:a:b);<br></code></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;type_traits&gt;<br>template&lt;typename T1, typename T2&gt;<br>auto max(T1 a, T2 b) -&gt; typename std::decay&lt;decltype(true ? a : b)&gt;::type<br>&#123;<br>  return b &lt; a ? a : b;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h2 id="1-4-Default-Template-Arguments"><a href="#1-4-Default-Template-Arguments" class="headerlink" title="1.4 - Default Template Arguments"></a>1.4 - Default Template Arguments</h2><p>You can also define values for template parameters. These values are called <strong>default template arguments</strong> and can be used with any kind of template.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;type_traits&gt;<br>template&lt;typename T1, typename T2, typename RT = std::decay_t&lt;decltype(trye ? T1() : T2())&gt;&gt;<br>RT max(T1 a, T2 b)<br>&#123;<br>  return b &lt; a ? a : b;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Note again the usage of <code>std::decay_t&lt;&gt;</code> to ensure that no reference cna be returned.</p>
<p>Note also that this implementation requires that we are able to call default constructors for the passed types. There is another solution, using <code>std::declval</code>, which, however, <strong>make the declaration even more complicated</strong>(Section 11.2.3)</p>
<p>We can also use the <code>std::common_type&lt;&gt;</code> type trait to specify the default value for the return type:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;type_traits&gt;<br><br>template&lt;typename T1, typename T2, typename RT = std::common_type_t&lt;T1, T2&gt;&gt;<br>RT max(T1 a, T2 b)<br>&#123;<br>  return b &lt; a ? a : b;<br>&#125;<br><br>auto a = ::max(4, 7.2);<br>auto b = ::max&lt;double, int, long double&gt;(7.2, 4);<br></code></pre></td></tr></table></figure><br>However, again we have the problem that we have to specify three types to be able to specify the return type only.  </p>
<p>We would need the ability to have the return type as the first template parameter, while still begin able to deduce it from the argument types.  </p>
<p>It is possible to have default arguments for leading function template parameters even if parameters without default arguments follow:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename RT = long, typename T1, typename T2&gt;<br>RT max(T1 a, T2 b)<br>&#123;<br>  return b &lt; a ? a : b;<br>&#125;<br><br>int i;<br>long l;<br>...<br>max(i, l); //returns long(default argument of template parameter for returns type).<br>max&lt;int&gt;(4, 42); //returns int as explicitly requested<br></code></pre></td></tr></table></figure></p>
<h2 id="1-5-Overloading-Function-Templates"><a href="#1-5-Overloading-Function-Templates" class="headerlink" title="1.5 - Overloading Function Templates"></a>1.5 - Overloading Function Templates</h2><p>Like ordinary functions, function templates can be overloaded. That is, you can have different function difinitions with the same function name so that when that name is used in a function call, a C++ compiler must decide which one of the various candidates to call.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//maximum of two int values:<br>int max(int a, int b)<br>&#123;<br>  return b &lt; a ? a : b;<br>&#125;<br><br>//maximum of two values of any type:<br>template&lt;typename T&gt;<br>T max(T a, T b)<br>&#123;<br>  return b &lt; a ? a : b;<br>&#125;<br><br>int main()<br>&#123;<br>  ::max(7, 42); // calls the nontemplate for two ints<br>  ::max(7.0, 42.0); // calls max&lt;double&gt; (by argument deduction)<br>  ::max(&#x27;a&#x27;, &#x27;b&#x27;); // calls max&lt;char&gt; (by argument deduction)<br>  ::max&lt;&gt;(7, 42); // calls max&lt;int&gt; (by argument deduction)<br>  ::max&lt;double&gt;(7, 42); // calls max&lt;double&gt; (no argument deduction)<br>  ::max(&#x27;a&#x27;, 42.7); // calls the nontemplate for two ints<br>&#125;<br></code></pre></td></tr></table></figure>
<p>If the template can generate a function with a better match, however, <strong>then the template is selected</strong>.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">::max(7.0, 42.0); // calls the max&lt;double&gt; (by argument deduction)<br>::max(&#x27;a&#x27;, &#x27;b&#x27;); // calls the max&lt;char&gt; (by argument deduction)<br></code></pre></td></tr></table></figure><br>Here, the template is a better match because <strong>no conversion from double or char to int is required</strong>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">::max(&#x27;a&#x27;, 42.7);<br></code></pre></td></tr></table></figure>
<p>Because automatic type conversion is not considered for deduced template parameters but is considered for ordinary function parameters, the last call uses the nontemplate function(while <code>a</code> and <code>42.7</code> both converted to <code>int</code>).</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T1, typename T2&gt;<br>auto max (T1 a, T2 b)<br>&#123;<br>  return b &lt; a ? a : b;<br>&#125;<br>template&lt;typename RT, typename T1, typename T2&gt;<br>RT max (T1 a, T2 b)<br>&#123;<br>  return b &lt; a ? a : b;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>New, we can call <code>max()</code>:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">auto a = ::max(4, 7.2); //uses first template.<br>auto b = ::max&lt;long double&gt;(7.2, 4); //uses second template, since the number of parameters is not matched for first template.<br>auto c = ::max&lt;int&gt;(4, 7.2); //ERROR: both function templates match.<br></code></pre></td></tr></table></figure></p>
<hr>
<p>A useful example would be to overload the maximum template for pointers and ordinary C-strings:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;cstring&gt;<br>#include &lt;string&gt;<br><br>//maximum of two values of any type:<br>template&lt;typename T&gt;<br>T max(T a, T b)<br>&#123;<br>  return b &lt; a ? a : bl<br>&#125;<br><br>//maximum of two pointers:<br>template&lt;typename T&gt;<br>T* max(T *a, T *b)<br>&#123;<br>  return *b &lt; *a ? a : b;<br>&#125;<br><br>//maximum of two C-strings:<br>char const* max(char const* a, char const* b)<br>&#123;<br>  return std::strcmp(b, a) &lt; 0 ? a : b;<br>&#125;<br><br>int main()<br>&#123;<br>  int a = 7;<br>  int b = 42;<br>  auto m1 = ::max(a,b); // max() for two values of type int<br>  std::string s1 = &quot;hey&quot;;<br>  std::string s2 = &quot;you&quot;;<br>  auto m2 = ::max(s1,s2); // max() for two values of type std::string<br>  int* p1 = &amp;b;<br>  int* p2 = &amp;a;<br>  auto m3 = ::max(p1,p2); // max() for two pointers<br>  char const* x = &quot;hello&quot;;<br>  char const* y = &quot;world&quot;;<br>  auto m4 = ::max(x,y); // max() for two C-strings<br>&#125;<br></code></pre></td></tr></table></figure><br>Note that in all overloads of <code>max()</code> we pass the arguments by value. In general, it is good idea not to change more than necessary when overloading function templates. You should limit your changes to the number of parameters or to specifying template parameters explicitly. Otherwise, unexpected effects may happen.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;iostream&gt;<br><br>template&lt;typename T&gt;<br>T max(T a, T b)<br>&#123;<br>  std::cout &lt;&lt; &quot;max&lt;&gt;()&quot; &lt;&lt; endl;<br>  return b &lt; a ? a : b;<br>&#125;<br><br>// maximum of three values of any type:<br>template&lt;typename T&gt;<br>T max (T a, T b, T c)<br>&#123;<br>  return max (max(a,b), c); // uses the template version even for ints<br>&#125; // because the following declaration comes<br>  // too late:<br><br>// maximum of two int values:<br>int max (int a, int b)<br>&#123;<br>  std::cout &lt;&lt; &quot;max(int,int) \n&quot;;<br>  return b &lt; a ? a : b;<br>&#125;<br>int main()<br>&#123;<br>  ::max(47,11,33); // OOPS: uses max&lt;T&gt;() instead of max(int,int)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-6-But-Shouldn’t-We…"><a href="#1-6-But-Shouldn’t-We…" class="headerlink" title="1.6 - But, Shouldn’t We…?"></a>1.6 - But, Shouldn’t We…?</h2><h3 id="Pass-by-Value-or-by-Reference"><a href="#Pass-by-Value-or-by-Reference" class="headerlink" title="Pass by Value or by Reference?"></a>Pass by Value or by Reference?</h3><h3 id="Why-not-inline"><a href="#Why-not-inline" class="headerlink" title="Why not inline?"></a>Why not inline?</h3><p>In general, function templates don’t have to be declared with inline. Unlike ordinary.<br>The only exception to this rule are full specializations of templates for specific types, so that the resulting code is no longer generic (all template parameters are defined).</p>
<h3 id="Why-not-constexpr"><a href="#Why-not-constexpr" class="headerlink" title="Why not constexpr?"></a>Why not constexpr?</h3><p>Since C++11, you can use constexpr to provide the ability to use code to compute some values at compile time. For a lost of templates this makes sense.</p>
<p>For example, to be able to use the maximum function at compile time, you have to declare it as follows:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T1, typename T2&gt;<br>constexpr auto max(T1 a, T2 b)<br>&#123;<br>  return b &lt; a ? a : b;<br>&#125;<br></code></pre></td></tr></table></figure><br>With this, you can use the maximum function template in places with compile-time context, such as when declaring the size of a raw array:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int a[::max(sizeof(char), 1000u)];<br></code></pre></td></tr></table></figure><br>or the size of a <code>std::array&lt;&gt;</code>:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">std::array&lt;std::string, ::max(sizeof(char), 1000u)&gt; arr;<br></code></pre></td></tr></table></figure></p>
<h1 id="Chapter-2-Class-Template"><a href="#Chapter-2-Class-Template" class="headerlink" title="Chapter.2 - Class Template"></a>Chapter.2 - Class Template</h1><h2 id="2-1-Implementation-of-Class-Template-Stack"><a href="#2-1-Implementation-of-Class-Template-Stack" class="headerlink" title="2.1 - Implementation of Class Template Stack"></a>2.1 - Implementation of Class Template Stack</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//stack1.hpp<br>#include &lt;vector&gt;<br>#include &lt;cassert&gt;<br><br>template&lt;typename T&gt;<br>class Stack &#123;<br>private:<br>  std::vecotr&lt;T&gt; elems; //elements<br><br>public:<br>  void push(T const&amp; elem); //push element<br>  void pop(); //pop element<br><br>  T const&amp; top() const; //return top element<br>  bool empty() const &#123; //return whether the stack is empty.<br>    return elems.empty();<br>  &#125;<br>&#125;<br><br>template&lt;typename T&gt;<br>void Stack&lt;T&gt;::push (T const&amp; elem)<br>&#123;<br>  elems.push_back(elem); //append copy of passed elem<br>&#125;<br><br>template&lt;typename T&gt;<br>void Stack&lt;T&gt;::push (T const&amp; elem)<br>&#123;<br>  elems.push_back(elem);<br>&#125;<br><br>template&lt;typename T&gt;<br>void Stack&lt;T&gt;::pop()<br>&#123;<br>  assert(!elems.empty());<br>  elems.pop_back();<br>&#125;<br><br>template&lt;typename T&gt;<br>T const&amp; Stack&lt;T&gt;::top() const<br>&#123;<br>  assert(!elems.empty());<br>  return elems.back();<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p>If, for example, you have to declare your own copy constructor and assignment operator, it typically looks like this:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T&gt;<br>class Stack &#123;<br>  ...<br>  Stack (Stack const&amp;);             //copy constructor<br>  Stack&amp; operator= (Stack const&amp;);  //assignment operator<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><br>which is formally equivalent to:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T&gt;<br>class Stack &#123;<br>  ...<br>  Stack (Stack&lt;T&gt; const&amp;);<br>  Stack&lt;T&gt;&amp; operator= (Stack&lt;T&gt; const&amp;);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><br>but usually the <code>&lt;T&gt;</code> signals special handling of special template parameters, so it’s usually better to use the first form.</p>
<p>However, outside the class structure you’d need:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T&gt;<br>bool operator== (Stack&lt;T&gt; const&amp; lhs, Stack&lt;T&gt; const&amp; rhs);<br></code></pre></td></tr></table></figure><br>Note that in place where the name and not type of the class is required, only <code>Stack</code> may be used.</p>
<h3 id="Implementation-of-Member-Functions"><a href="#Implementation-of-Member-Functions" class="headerlink" title="Implementation of Member Functions"></a>Implementation of Member Functions</h3><p>To define a member function of a class template, you have o specify that it is a template, and you have to use the full type qualification of the class template.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T&gt;<br>void Stack&lt;T&gt;::push(T const&amp; elem)<br>&#123;<br>  elems.push_back(elem); //append copy of passed elem.<br>&#125;<br></code></pre></td></tr></table></figure>
<p>In this case, <code>push_back()</code> of the element vector is called, which appends the element at the end of the vector.</p>
<p>Note that <code>pop_back()</code> of vector removes the last elemtn but does not return it.<br>It is impossible to implement a completely exception-safe version of <code>pop()</code> that returns the removed. However, ignoring this danger, we could implement a <code>pop()</code> that returns the element just removed.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T&gt;<br>T Stack&lt;T&gt;::pop()<br>&#123;<br>  assert(!elems.empty());<br>  T elem = elems.back();  //save copy of last element.<br>  elems.pop_back();       //remove last element.<br><br>  return elem;            //return copy of saved element.<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h2 id="2-2-Use-of-Class-Template-Stack"><a href="#2-2-Use-of-Class-Template-Stack" class="headerlink" title="2.2 - Use of Class Template Stack"></a>2.2 - Use of Class Template <code>Stack</code></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//stack1.cpp<br>#include &quot;stack1.hpp:<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>int main()<br>&#123;<br>  Stack&lt;int&gt; intStack;<br>  Stack&lt;std::string&gt; stringStack;<br><br>  //manipulate int stack<br>  intStack.push(7);<br>  std::cout &lt;&lt; intStack.top() &lt;&lt; &#x27;\n&#x27;;<br><br>  //manipulate string stack<br>  stringStack.push(&quot;hello&quot;);<br>  std::cout &lt;&lt; stringStack.top() &lt;&lt; &#x27;\n&#x27;;<br>  stringStack.pop();<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p>An instantiated class template’s type can be used just like any other type.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void foo(Stack&lt;int&gt; const&amp; s)   //parameter `s` is `int` stack.<br>&#123;<br>  using IntStack = Stack&lt;int&gt;;  //IntStack is another name for `Stack&lt;int&gt;`.<br>  Stack&lt;int&gt; istack[10];        //`istack` is an array of 10 `int` stacks.<br>  IntStack istack2[10];         //`istack2` is also an array of 10 `int` stacks (same type).<br>&#125;<br></code></pre></td></tr></table></figure></p>
<hr>
<p>Template arguments may be any type, such as pointers to <code>float</code> or even stack of <code>int</code>:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Stack&lt;float*&gt; flatPtrStack;       //stack of `float` pointers.<br>Stack&lt;Stack&lt;int&gt;&gt; intStackStack;  //stack of stack of ints.<br></code></pre></td></tr></table></figure></p>
<p>Note that before C++11 you had to put whitespace between the two closing template brackets:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Stack&lt;Stack&lt;int&gt; &gt; intStackStack; // OK with all C++ versions<br></code></pre></td></tr></table></figure><br>If you didn’t do this, you were using operator &gt;&gt;, which resulted in a syntax error:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Stack&lt;Stack&lt;int&gt;&gt; intStackStack; // ERROR before C++11<br></code></pre></td></tr></table></figure><br>The reason for the old behavior was that it helped the first pass of a C++ compiler to tokenize the<br>source code independent of the semantics of the code</p>
<h2 id="2-3-Partial-Usage-of-Class-Templates"><a href="#2-3-Partial-Usage-of-Class-Templates" class="headerlink" title="2.3 - Partial Usage of Class Templates"></a>2.3 - Partial Usage of Class Templates</h2><p>Instead of print the stack contents with <code>printOn</code> it is better to implement <code>operator&lt;&lt;</code> for the stack. However, as usual <code>operator&lt;&lt;</code> has to be implemented as nonmember function, which then could call printOn() inline:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;typename T&gt;<br>class Stack &#123;<br>  ...<br>  void printOn() (std::ostream&amp; strm) const &#123;<br>    ...<br>  &#125;<br><br>  friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; strm, Stack&lt;T&gt; const&amp; s) &#123;<br>    s.printOn(strm);<br>    return strm;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>
<h2 id="2-4-Friends"><a href="#2-4-Friends" class="headerlink" title="2.4 - Friends"></a>2.4 - Friends</h2><h2 id="2-5-Specializations-of-Class-Templates"><a href="#2-5-Specializations-of-Class-Templates" class="headerlink" title="2.5 - Specializations of Class Templates"></a>2.5 - Specializations of Class Templates</h2><p>Specializing class templates allows you to optimize<br>implementations for certain types or to fix a misbehavior of certain types for an instantiation of the class template.</p>
<p>If you specialize a class template, you must also specialize all member functions. Although it is possible to specialize a single member function of a class template, once you have done so, you can no longer specialize the whole class template instance that the specialized member belongs to.</p>
<p>To specialize a class template, you have to declare the class with a leading <code>template&lt;&gt;</code> and a specification of the types for which the class template is specialized. The types are used as a template argument and must be specified directly following the name of the class:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">template&lt;&gt;<br>class Stack&lt;std::string&gt; &#123;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure></p>
<p>For these specializations, any definition of a member function must be defined as an “ordinary” member function, which each occurence of <code>T</code> begin replaced by the specialized type:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void Stack&lt;std::string&gt;::push (std::string const&amp; elem)<br>&#123;<br>  elems.push_back(elem);<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h2 id="2-6-Partial-Specialization"><a href="#2-6-Partial-Specialization" class="headerlink" title="2.6 - Partial Specialization"></a>2.6 - Partial Specialization</h2><p>Class templates can be partially specialized. You can provide special implementations for particular circumstances, but some template parameters must still be defined by the user.</p>
<p>For example, we can define a special implementation of class `Stack&gt; for pointers:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &quot;stack1.hpp&quot;<br><br>template&lt;typename T&gt;<br>class Stack&lt;T*&gt; &#123;<br>private:<br>  std::vector&lt;T*&gt; elems;<br><br>public:<br>  void push(T*);<br>  T* pop();<br>  T* top() const;<br><br>  bool empty() const &#123;<br>    return elems.empty();<br>  &#125;<br>&#125;<br><br>template&lt;typename T&gt;<br>void Stack&lt;T*&gt;::push (T* elem)<br>&#123;<br>  elems.push_back(elem);<br>&#125;<br><br>template&lt;typename T&gt;<br>T* Stack&lt;T*&gt;::pop()<br>&#123;<br>  assert(!elems.empty());<br>  T* p = elems.back();<br>  elems.pop_back();<br>  return p;<br>&#125;<br><br>template&lt;typename T&gt;<br>T* Stack&lt;T*&gt;::top() const<br>&#123;<br>  assert(!elems.empty());<br>  return elems.back();<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h2 id="2-7-Default-Class-Template-Arguments"><a href="#2-7-Default-Class-Template-Arguments" class="headerlink" title="2.7 - Default Class Template Arguments"></a>2.7 - Default Class Template Arguments</h2><h2 id="2-8-Type-Aliases"><a href="#2-8-Type-Aliases" class="headerlink" title="2.8 - Type Aliases"></a>2.8 - Type Aliases</h2><h2 id="2-9-Class-Template-Argument-Deduction"><a href="#2-9-Class-Template-Argument-Deduction" class="headerlink" title="2.9 - Class Template Argument Deduction"></a>2.9 - Class Template Argument Deduction</h2><h2 id="2-10-Templatized-Aggregates"><a href="#2-10-Templatized-Aggregates" class="headerlink" title="2.10 - Templatized Aggregates"></a>2.10 - Templatized Aggregates</h2><h1 id="Chapter-3-Nontype-Template-Parameters"><a href="#Chapter-3-Nontype-Template-Parameters" class="headerlink" title="Chapter.3 - Nontype Template Parameters"></a>Chapter.3 - Nontype Template Parameters</h1><div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2026/01/08/2026-1-8-BookCppConcurrencyInAction2ed/">← Next [Book] C++ Concurrency In Action (Second Edition)</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2026/01/05/2026-1-5-RedBlueConfrontationFromAttCk/">[Book] Practical Guide To Red-Blue Confrontation From ATT&amp;CK Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="To Catalog">≡</a><a id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://avatars.githubusercontent.com/u/110074064?v=4" alt="Logo"></a><h1 id="Dr"><a href="/">ISSAC</a></h1><div id="description"><p>Everything is failing...</p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/iss4cf0ng/"><i class="fab fa-github" alt="GitHub"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#El-libro"><span class="toc-number">1.</span> <span class="toc-text">El libro</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction"><span class="toc-number">2.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reflection"><span class="toc-number">3.</span> <span class="toc-text">Reflection</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1-Function-Templates"><span class="toc-number">4.</span> <span class="toc-text">Chapter.1 - Function Templates</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Function-Templates"><span class="toc-number">4.1.</span> <span class="toc-text">1.1 - Function Templates</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Two-Phase-Translation"><span class="toc-number">4.1.1.</span> <span class="toc-text">Two-Phase Translation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Template-Arugment-Deduction"><span class="toc-number">4.2.</span> <span class="toc-text">1.2 - Template Arugment Deduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Multiple-Template-Parameters"><span class="toc-number">4.3.</span> <span class="toc-text">1.3 - Multiple Template Parameters</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Template-Parameters-for-Return-Types"><span class="toc-number">4.3.1.</span> <span class="toc-text">Template Parameters for Return Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deducing-the-Return-Type"><span class="toc-number">4.3.2.</span> <span class="toc-text">Deducing the Return Type</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Default-Template-Arguments"><span class="toc-number">4.4.</span> <span class="toc-text">1.4 - Default Template Arguments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Overloading-Function-Templates"><span class="toc-number">4.5.</span> <span class="toc-text">1.5 - Overloading Function Templates</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-But-Shouldn%E2%80%99t-We%E2%80%A6"><span class="toc-number">4.6.</span> <span class="toc-text">1.6 - But, Shouldn’t We…?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pass-by-Value-or-by-Reference"><span class="toc-number">4.6.1.</span> <span class="toc-text">Pass by Value or by Reference?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Why-not-inline"><span class="toc-number">4.6.2.</span> <span class="toc-text">Why not inline?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Why-not-constexpr"><span class="toc-number">4.6.3.</span> <span class="toc-text">Why not constexpr?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2-Class-Template"><span class="toc-number">5.</span> <span class="toc-text">Chapter.2 - Class Template</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Implementation-of-Class-Template-Stack"><span class="toc-number">5.1.</span> <span class="toc-text">2.1 - Implementation of Class Template Stack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementation-of-Member-Functions"><span class="toc-number">5.1.1.</span> <span class="toc-text">Implementation of Member Functions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Use-of-Class-Template-Stack"><span class="toc-number">5.2.</span> <span class="toc-text">2.2 - Use of Class Template Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Partial-Usage-of-Class-Templates"><span class="toc-number">5.3.</span> <span class="toc-text">2.3 - Partial Usage of Class Templates</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Friends"><span class="toc-number">5.4.</span> <span class="toc-text">2.4 - Friends</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-Specializations-of-Class-Templates"><span class="toc-number">5.5.</span> <span class="toc-text">2.5 - Specializations of Class Templates</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-Partial-Specialization"><span class="toc-number">5.6.</span> <span class="toc-text">2.6 - Partial Specialization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-Default-Class-Template-Arguments"><span class="toc-number">5.7.</span> <span class="toc-text">2.7 - Default Class Template Arguments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-Type-Aliases"><span class="toc-number">5.8.</span> <span class="toc-text">2.8 - Type Aliases</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-Class-Template-Argument-Deduction"><span class="toc-number">5.9.</span> <span class="toc-text">2.9 - Class Template Argument Deduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-Templatized-Aggregates"><span class="toc-number">5.10.</span> <span class="toc-text">2.10 - Templatized Aggregates</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-3-Nontype-Template-Parameters"><span class="toc-number">6.</span> <span class="toc-text">Chapter.3 - Nontype Template Parameters</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {code.findCode();
document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script src="/js/slide.js"></script></body></html>