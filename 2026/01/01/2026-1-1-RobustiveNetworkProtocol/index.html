<!DOCTYPE html><html lang="en-us" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>[Code] Solution of TCP packet sticking/coalescing (sticky packet) - Designing a protocol step by step | iss4cf0ng/ISSAC's blog</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":true,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy","copyFinish":"copied","expand":"expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/brands.min.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
@font-face {
 font-family: 'Font Awesome 6 Brands';
 src: local('Font Awesome 6 Brands'), url('/lib/fontawesome/fa-brands.woff2') format('woff2');
}
@font-face {
 font-family: 'Font Awesome 6 Free';
 src: local('Font Awesome 6 Free'), url('/lib/fontawesome/fa-regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="iss4cf0ng/ISSAC's blog" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/About/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/Alien/"><span class="navItemTitle">Alien</span></a></li><li class="navItem"><a class="navBlock" href="/2026/01/28/2026-1-28-ToolsDuplexSpy-v2-0-0/"><span class="navItemTitle">DuplexSpy</span></a></li><li class="navItem"><a class="navBlock" href="/Notes/"><span class="navItemTitle">Notes</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>[Code] Solution of TCP packet sticking/coalescing (sticky packet) - Designing a protocol step by step</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2026-01-01T12:57:32.000Z" id="date"> 2026-01-01</time></div></span><br><span>Last Update: <div class="control"><time datetime="2026-01-02T09:02:59.373Z" id="updated"> 2026-01-02</time></div></span><br><span>Word Count: <div class="control">1k</div></span><br><span>Read Time: <div class="control">6 min</div></span></div></div><hr><div id="post-content"><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>This article explains how to solve a common issue in network programming—TCP packet sticking (also known as packet coalescing or sticky packets).<br>In addition, it demonstrates how to design a custom application-layer protocol for socket communication.<br>All examples in this article are implemented in C#.</p>
<hr>
<h1 id="What-Is-Sticky-Packet"><a href="#What-Is-Sticky-Packet" class="headerlink" title="What Is Sticky Packet?"></a>What Is Sticky Packet?</h1><p>If you are not familiar with socket programming, please read the following article first:</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://iss4cf0ng.github.io/2026/01/01/2026-1-1-SocketInit/">Socket Initialization with different languages.</a></p>
</blockquote>
<p>Let us start with a simple receiver implementation:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">using System;<br>using System.Net.Sockets;<br>using System.Text;<br><br>class Client<br>&#123;<br>    static void Main()<br>    &#123;<br>        TcpClient client = new TcpClient();<br><br>        client.Connect(&quot;127.0.0.1&quot;, 8080);<br><br>        NetworkStream stream = client.GetStream();<br><br>        string message = &quot;Hello from C# client&quot;;<br>        byte[] data = Encoding.UTF8.GetBytes(message);<br>        stream.Write(data, 0, data.Length);<br><br>        byte[] buffer = new byte[1024];<br>        int bytesRead = stream.Read(buffer, 0, buffer.Length);<br>        string reply = Encoding.UTF8.GetString(buffer, 0, bytesRead);<br>        Console.WriteLine(&quot;Server reply: &quot; + reply);<br><br>        client.Close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>The root cause of packet sticking lies in the following line:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">byte[] buffer = new byte[1024];<br></code></pre></td></tr></table></figure><br>Here, the receive buffer size is fixed at 1024 bytes.<br>However, the size of the data sent by the server (or client—it does not matter) is not guaranteed to be exactly 1024 bytes.</p>
<ul>
<li>If the actual message size is 1025 bytes, one byte will be lost.</li>
<li>If the actual message size is 512 bytes, it may appear safe at first.</li>
</ul>
<p align="center" class='item-img' data-src='/images/meme/mika_sliding_rollcake.png'><img src="/images/meme/mika_sliding_rollcake.png", width="600">
</p>

<p>In practice, the remote host may send messages frequently and continuously.<br>As a result, you may receive a 1024-byte buffer that actually contains two consecutive 512-byte messages.</p>
<p>If the receiver cannot distinguish between these two messages, the handler may incorrectly treat them as a single message, which can lead to logic errors or corrupted data.</p>
<p>This phenomenon is known as TCP packet sticking.</p>
<p align="center" class='item-img' data-src='/images/meme/mika_nagisa_rollcake.png'><img src="/images/meme/mika_nagisa_rollcake.png", width="600">
</p>

<hr>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>To solve this problem, the sender must explicitly inform the receiver of the message length.</p>
<p>The most common and effective approach is to prepend a message header to each payload.<br>In this section, we will design a custom application-layer protocol (OSI Layer 7) to achieve this.</p>
<h1 id="Fundamental-Design"><a href="#Fundamental-Design" class="headerlink" title="Fundamental Design"></a>Fundamental Design</h1><p>We define the protocol format as follows:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">| Header | Payload |<br></code></pre></td></tr></table></figure><br>| Field | Description |<br>| —- | —- |<br>| Header | Constant length. |<br>| Payload | Your message. |</p>
<p>The header structure is defined as:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">| Command | Parameter | Length |<br></code></pre></td></tr></table></figure><br>| Field | Size |Description |<br>| —- | —- | —- |<br>| Command | 1 byte | What the receiver should do. |<br>| Parameter | 1 byte | Parameters of the command. |<br>| Length | 4 byte | Payload’s length |</p>
<p>Example command definitions:<br>| Command | Parameter | Meaning |<br>| —- | —- | —- |<br>| 0 | 0 | Disconnect. |<br>| 1 | 0 | Message handler. |</p>
<p>At this point, we have successfully defined our protocol.<br>The next step is implementation.</p>
<hr>
<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>We will apply object-oriented programming (OOP) concepts in C#.</p>
<blockquote>
<p>Notice: Hungarian notation is used in this implementation.</p>
</blockquote>
<ol>
<li><p>Designing a class</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class clsMyProtocol<br>&#123;<br>    public const int MAX_SIZE = 65535;<br>    public const int HEADER_SIZE = 6;<br><br>    private byte _nCommand = 0;<br>    public byte m_nCommand =&gt; _nCommand;<br><br>    private byte _nParam = 0;<br>    public byte m_nParam =&gt; _nParam;<br><br>    private int _nDataLength = 0;<br>    public int m_nDataLength =&gt; _nDataLength;<br><br>    private byte[] _abMessageData = Array.Empty&lt;byte&gt;();<br>    public byte[] m_abMessageData =&gt; _abMessageData;<br><br>    private byte[] _abMoreData = Array.Empty&lt;byte&gt;();<br>    public byte[] m_abMoreData =&gt; _abMoreData;<br><br>    // Constructor for parsing received buffer<br>    public clsMyProtocol(byte[] abBuffer)<br>    &#123;<br>        if (abBuffer == null || abBuffer.Length &lt; HEADER_SIZE)<br>            return;<br><br>        using (var ms = new MemoryStream(abBuffer))<br>        using (var br = new BinaryReader(ms))<br>        &#123;<br>            _nCommand = br.ReadByte();<br>            _nParam = br.ReadByte();<br>            _nDataLength = br.ReadInt32(); // &lt;-- little-endian by default<br><br>            if (abBuffer.Length - HEADER_SIZE &gt;= _nDataLength &amp;&amp; _nDataLength &gt; 0)<br>                _abMessageData = br.ReadBytes(_nDataLength);<br><br>            int remaining = (int)(abBuffer.Length - HEADER_SIZE - _nDataLength);<br>            if (remaining &gt; 0)<br>                _abMoreData = br.ReadBytes(remaining);<br>        &#125;<br>    &#125;<br><br>    // Constructor for building packets to send<br>    public clsMyProtocol(byte nCmd, byte nParam, byte[] abMsg)<br>    &#123;<br>        _nCommand = nCmd;<br>        _nParam = nParam;<br>        _abMessageData = abMsg;<br>        _nDataLength = _abMessageData.Length;<br>    &#125;<br><br>    public byte[] fnabGetBytes()<br>    &#123;<br>        try<br>        &#123;<br>            using (var ms = new MemoryStream())<br>            using (var bw = new BinaryWriter(ms))<br>            &#123;<br>                bw.Write(_nCommand);<br>                bw.Write(_nParam);<br>                bw.Write(_nDataLength);<br>                bw.Write(_abMessageData);<br><br>                return ms.ToArray();<br>            &#125;<br>        &#125;<br>        catch (Exception ex)<br>        &#123;<br>            MessageBox.Show(ex.Message, &quot;fnabGetBytes()&quot;, MessageBoxButtons.OK, MessageBoxIcon.Error);<br>            return Array.Empty&lt;byte&gt;();<br>        &#125;<br>    &#125;<br><br>    public (byte nCommand, byte nParam, int nLength, byte[] abMsg) fnGetMsg()<br>        =&gt; (_nCommand, _nParam, _nDataLength, _abMessageData);<br><br>    public static (byte nCommand, byte nParam, int nLength) fnGetHeader(byte[] abBuffer)<br>    &#123;<br>        if (abBuffer == null || abBuffer.Length &lt; HEADER_SIZE)<br>            return (0, 0, 0);<br><br>        byte nCommand = abBuffer[0];<br>        byte nParam = abBuffer[1];<br>        int nLength = BitConverter.ToInt32(abBuffer, 2);<br><br>        return (nCommand, nParam, nLength);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>Receiver handler:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>byte[] fnabCombineBytes(byte[] abFirstBytes, int nFirstIndex, int nFirstLength, byte[] abSecondBytes, int nSecondIndex, int nSecondLength)<br>&#123;<br>    byte[] abBytes = new byte[nFirstLength + nSecondLength];<br>    using (MemoryStream ms = new MemoryStream())<br>    &#123;<br>        ms.Write(abFirstBytes, nFirstIndex, nFirstLength);<br>        ms.Write(abSecondBytes, nSecondIndex, nSecondLength);<br><br>        abBytes = ms.ToArray();<br>    &#125;<br><br>    return abBytes;<br>&#125;<br><br>void fnMsgHandler(string szMsg)<br>&#123;<br>    //todo: Message handler.<br>&#125;<br><br>void fnHandler(Socket skt)<br>&#123;<br>    clsMyProtocol myProto = null;<br><br>    int nRecvLength = 0;<br>    byte[] abStaticRecvBuffer = new byte[clsMyProtocol.MAX_SIZE];<br>    byte[] abDynamicRecvBuffer = &#123; &#125;;<br><br>    do<br>    &#123;<br>        abStaticRecvBuffer = new byte[clsMyProtocol.MAX_SIZE];<br>        nRecvLength = skt.Receive(abStaticRecvBuffer);<br><br>        if (nRecvLength &lt;= 0)<br>            break;<br>        else if (abDynamicRecvBuffer.Length &lt; clsMyProtocol.HEADER_SIZE)<br>            continue;<br>        else<br>        &#123;<br>            var headerInfo = clsMyProtocol.fnGetHeader(abDynamicRecvBuffer);<br>            while (abDynamicRecvBuffer.Length - clsMyProtocol.HEADER_SIZE &gt;= headerInfo.nLength)<br>            &#123;<br>                myProtocol = new clsMyProtocol(abDynamicRecvBuffer);<br>                abDynamicRecvBuffer = myProtocol.m_abMoreData;<br>                headerInfo = clsMyProtocol.fnGetHeader(abDynamicRecvBuffer);<br><br>                byte[] abBuffer = myProtocol.fnGetMsg().abMsg;<br><br>                if (myProtocol.m_nCommand == 0)<br>                &#123;<br>                    if (myProtocol.m_nParam == 0)<br>                    &#123;<br>                        skt.Close();<br>                    &#125;<br>                &#125;<br>                else if (myProtocol.m_nCommand == 1)<br>                &#123;<br>                    if (myProtocol.m_nParam == 0)<br>                    &#123;<br>                        string szMsg = Encoding.UTF8.GetString(abBuffer);<br><br>                        fnMsgHandler(szMsg);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    while (nRecvLength &gt; 0);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>The sender:</p>
<blockquote>
<p>Important: Both sender and receiver must share the same protocol definition.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void fnSendHelloWorld(Socket skt)<br>&#123;<br>    uint nCmd = 1;<br>    uint nParam = 0;<br>    string szMsg = &quot;Hello world!&quot;;<br>    byte[] abMsg = Encoding.UTF8.GetBytes(szMsg);<br><br>    clsMyProtocol myProtocol = new clsMyProtocol((byte)nCmd, (byte)nParam, abMsg);<br><br>    skt.Send(myProtocol.fnabGetBytes());<br>&#125;<br></code></pre></td></tr></table></figure></p>
</blockquote>
<p>With a clearly defined message header and proper buffer management, the original problem—TCP packet sticking—is effectively resolved.</p>
<p align="center" class='item-img' data-src='/images/meme/mika_XD.jpg'><img src="/images/meme/mika_XD.jpg", width="600">
</p>

<hr>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>By designing a simple yet structured application-layer protocol, you can now establish robust and reliable socket communication, even under high-throughput or bursty network conditions.</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2026/01/01/2026-1-1-SocketInit/">← Next [Learning] Socket Initialization.</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2026/01/01/DomainPenetration1/">[Book] Attack and Denfense About Domain Penetration Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="To Catalog">≡</a><a id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://avatars.githubusercontent.com/u/110074064?v=4" alt="Logo"></a><h1 id="Dr"><a href="/">ISSAC</a></h1><div id="description"><p>Everything is failing...</p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/iss4cf0ng"><i class="GitHub" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://zeroday.hitcon.org/user/ISSAC_f0ng"><i class="ZeroDay Hitcon" alt="ZeroDay Hitcon"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#What-Is-Sticky-Packet"><span class="toc-number">2.</span> <span class="toc-text">What Is Sticky Packet?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Solution"><span class="toc-number">3.</span> <span class="toc-text">Solution</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fundamental-Design"><span class="toc-number">4.</span> <span class="toc-text">Fundamental Design</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Implementation"><span class="toc-number">5.</span> <span class="toc-text">Implementation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Conclusion"><span class="toc-number">6.</span> <span class="toc-text">Conclusion</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {code.findCode();
document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script src="/js/slide.js"></script></body></html>